<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/namespaceopen3d_1_1ml_1_1impl.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:56:25 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open3D (C++ API): open3d::ml::impl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.html", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="../../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3TQPKGV6Z3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-3TQPKGV6Z3');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="open3d_logo.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open3D (C++ API)
   &#160;<span id="projectnumber">0.17.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.html','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopen3d.html">open3d</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1ml.html">ml</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html">impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">open3d::ml::impl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen3d_1_1ml_1_1impl_1_1_interpolation">InterpolationVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing interpolation weights.  <a href="structopen3d_1_1ml_1_1impl_1_1_interpolation#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen3d_1_1ml_1_1impl_1_1_interpolation-2">InterpolationVec&lt; T, VECSIZE, InterpolationMode::NEAREST_NEIGHBOR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for NEAREST_NEIGHBOR.  <a href="structopen3d_1_1ml_1_1impl_1_1_interpolation-2#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen3d_1_1ml_1_1impl_1_1_interpolation-3">InterpolationVec&lt; T, VECSIZE, InterpolationMode::LINEAR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for LINEAR (uses coordinate clamping)  <a href="structopen3d_1_1ml_1_1impl_1_1_interpolation-3#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen3d_1_1ml_1_1impl_1_1_interpolation-4">InterpolationVec&lt; T, VECSIZE, InterpolationMode::LINEAR_BORDER &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for LINEAR_BORDER (uses zero border instead of clamping)  <a href="structopen3d_1_1ml_1_1impl_1_1_interpolation-4#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1ml_1_1impl_1_1_memory_allocat">MemoryAllocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for managing memory segments within a memory allocation.  <a href="classopen3d_1_1ml_1_1impl_1_1_memory_allocat#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1ml_1_1impl_1_1_adaptor.681.de">Adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopen3d_1_1ml_1_1impl_1_1_adaptor.681.de" title="Adaptor for nanoflann.">Adaptor</a> for nanoflann.  <a href="classopen3d_1_1ml_1_1impl_1_1_adaptor.681.de#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen3d_1_1ml_1_1impl_1_1_select_nanofl">SelectNanoflannAdaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen3d_1_1ml_1_1impl_1_1_select_nanofl-2">SelectNanoflannAdaptor&lt; L2, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen3d_1_1ml_1_1impl_1_1_select_nanofl-3">SelectNanoflannAdaptor&lt; L1, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1ml_1_1impl_1_1_accumulator.68">Accumulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1ml_1_1impl_1_1_accumulator_ba">AccumulatorBackprop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1cdea72ec606986b7ada2e619ea41a8d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a> { <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8daaac544aacc3615aada24897a215f5046">LINEAR</a>
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8daedc71d68a68ed5f29b9a3e9cb2e680d9">LINEAR_BORDER</a>
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62a7f5ccbc3d30c2cd3fd04d567946cbde2">NEAREST_NEIGHBOR</a>
 }</td></tr>
<tr class="separator:a1cdea72ec606986b7ada2e619ea41a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d07a9288168e9ecab8f34e24d27fb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a> { <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fba128eca8782c4ff1d0e70ee09d99ec5d7">BALL_TO_CUBE_RADIAL</a>
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fba3bdf207d9ebb484a4aa36673674fa69f">BALL_TO_CUBE_VOLUME_PRESERVING</a>
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fbad8156d3c6735d75d8a1b8dedd0e79c8b">IDENTITY</a>
 }</td></tr>
<tr class="separator:ad39d07a9288168e9ecab8f34e24d27fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f613764e8b95ac53d1890d8da19d7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a94f613764e8b95ac53d1890d8da19d7c">Metric</a> { <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a94f613764e8b95ac53d1890d8da19d7ca2031a5a13d6caf8b506c86566d401f0d">L1</a>
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a94f613764e8b95ac53d1890d8da19d7ca431cf8c3d07b756c57361ce79e0954d0">L2</a>
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a94f613764e8b95ac53d1890d8da19d7ca1d3426e6b02d10126b29a6a4dd254f28">Linf</a>
 }</td></tr>
<tr class="memdesc:a94f613764e8b95ac53d1890d8da19d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported metrics.  <a href="namespaceopen3d_1_1ml_1_1impl.html#a94f613764e8b95ac53d1890d8da19d7c">More...</a><br /></td></tr>
<tr class="separator:a94f613764e8b95ac53d1890d8da19d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2902d456779f799905d50574750e1f62"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a> { <br />
&#160;&#160;<a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62aa85acf2e4cf435c4f7d6a0ae0b6e537a">AVERAGE</a> = 0
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62a4c3ea169e4887079fcee81e2d9c07a60">NEAREST_NEIGHBOR</a>
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62a7f5ccbc3d30c2cd3fd04d567946cbde2">NEAREST_NEIGHBOR</a>
, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62a520d9ae28496893067609b457fba01eb">MAX</a>
, <br />
&#160;&#160;<a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62a3b7d3ad96d80e65de4906f736ac9353c">CENTER</a>
<br />
 }</td></tr>
<tr class="separator:a2902d456779f799905d50574750e1f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a55a5f730132a9d229ca36a5b578274d1"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TReal , class TIndex , InterpolationMode INTERPOLATION, CoordinateMapping MAPPING, bool ALIGN_CORNERS, bool INDIVIDUAL_EXTENT, bool ISOTROPIC_EXTENT, bool POINT_IMPORTANCE&gt; </td></tr>
<tr class="memitem:a55a5f730132a9d229ca36a5b578274d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a55a5f730132a9d229ca36a5b578274d1">_CConvComputeFeaturesCPU</a> (TOut *out_features, const std::vector&lt; int &gt; &amp;filter_dims, const TFeat *filter, size_t num_out, const TReal *out_positions, size_t num_inp, const TReal *inp_positions, const TFeat *inp_features, const TFeat *inp_importance, size_t neighbors_index_size, const TIndex *neighbors_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TReal *extents, const TReal *offsets, bool normalize)</td></tr>
<tr class="separator:a55a5f730132a9d229ca36a5b578274d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae65fff6532e57f12b737eaaa228ddb"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TReal , class TIndex &gt; </td></tr>
<tr class="memitem:a5ae65fff6532e57f12b737eaaa228ddb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a5ae65fff6532e57f12b737eaaa228ddb">CConvComputeFeaturesCPU</a> (TOut *out_features, const std::vector&lt; int &gt; &amp;filter_dims, const TFeat *filter, size_t num_out, const TReal *out_positions, size_t num_inp, const TReal *inp_positions, const TFeat *inp_features, const TFeat *inp_importance, size_t neighbors_index_size, const TIndex *neighbors_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TReal *extents, const TReal *offsets, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a> interpolation, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a> coordinate_mapping, bool align_corners, bool individual_extent, bool isotropic_extent, bool normalize)</td></tr>
<tr class="separator:a5ae65fff6532e57f12b737eaaa228ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad27ea456291d89c4f87b7737687df1"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TReal , class TIndex , InterpolationMode INTERPOLATION, CoordinateMapping MAPPING, bool ALIGN_CORNERS, bool INDIVIDUAL_EXTENT, bool ISOTROPIC_EXTENT, bool POINT_IMPORTANCE&gt; </td></tr>
<tr class="memitem:a5ad27ea456291d89c4f87b7737687df1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a5ad27ea456291d89c4f87b7737687df1">_CConvBackropFilterCPU</a> (TOut *filter_backprop, const std::vector&lt; int &gt; &amp;filter_dims, size_t num_out, const TReal *out_positions, size_t num_inp, const TReal *inp_positions, const TFeat *inp_features, const TFeat *inp_importance, size_t neighbors_index_size, const TIndex *neighbors_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TReal *extents, const TReal *offsets, const TFeat *out_features_gradient, bool normalize)</td></tr>
<tr class="separator:a5ad27ea456291d89c4f87b7737687df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f83a7bf58ab46e57e8e45c88628d6b"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TReal , class TIndex &gt; </td></tr>
<tr class="memitem:ab6f83a7bf58ab46e57e8e45c88628d6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ab6f83a7bf58ab46e57e8e45c88628d6b">CConvBackpropFilterCPU</a> (TOut *filter_backprop, const std::vector&lt; int &gt; &amp;filter_dims, size_t num_out, const TReal *out_positions, size_t num_inp, const TReal *inp_positions, const TFeat *inp_features, const TFeat *inp_importance, size_t neighbors_index_size, const TIndex *neighbors_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TReal *extents, const TReal *offsets, const TFeat *out_features_gradient, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a> interpolation, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a> coordinate_mapping, bool align_corners, bool individual_extent, bool isotropic_extent, bool normalize)</td></tr>
<tr class="separator:ab6f83a7bf58ab46e57e8e45c88628d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac64bdddd123dfede9328296c820553"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TReal , class TIndex &gt; </td></tr>
<tr class="memitem:afac64bdddd123dfede9328296c820553"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#afac64bdddd123dfede9328296c820553">FillColumn</a> (const cudaStream_t &amp;stream, TFeat *columns, int in_channels, TIndex begin_idx, TIndex end_idx, TIndex num_out, const TReal *const __restrict__ out_positions, TIndex num_inp, const TReal *const __restrict__ inp_positions, const TFeat *const __restrict__ inp_features, const TFeat *const __restrict__ inp_importance, size_t neighbors_index_size, const TIndex *const __restrict__ neighbors_index, const TFeat *const __restrict__ neighbors_importance, const int64_t *const __restrict__ neighbors_row_splits, const TReal *const __restrict__ extents, const TReal *const __restrict__ offsets, const std::vector&lt; int &gt; &amp;filter_dims, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a> interpolation, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a> coordinate_mapping, bool align_corners, bool individual_extent, bool isotropic_extent, bool normalize)</td></tr>
<tr class="separator:afac64bdddd123dfede9328296c820553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915147ba8aa5ab252a532fa9823c9adb"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TReal , class TIndex &gt; </td></tr>
<tr class="memitem:a915147ba8aa5ab252a532fa9823c9adb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a915147ba8aa5ab252a532fa9823c9adb">FillColumnTranspose</a> (const cudaStream_t &amp;stream, TFeat *columns, int in_channels, TIndex begin_idx, TIndex end_idx, TIndex num_out, const TReal *const __restrict__ out_positions, TIndex num_inp, const TReal *const __restrict__ inp_positions, const TFeat *const __restrict__ inp_features, const TFeat *const __restrict__ inp_neighbors_importance_sum, const int64_t *const __restrict__ inp_neighbors_prefix_sum, size_t neighbors_index_size, const TIndex *const __restrict__ neighbors_index, const TFeat *const __restrict__ neighbors_importance, const int64_t *const __restrict__ neighbors_row_splits, const TReal *const __restrict__ extents, const TReal *const __restrict__ offsets, const std::vector&lt; int &gt; &amp;filter_dims, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a> interpolation, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a> coordinate_mapping, bool align_corners, bool individual_extent, bool isotropic_extent, bool normalize)</td></tr>
<tr class="separator:a915147ba8aa5ab252a532fa9823c9adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33c97667e644fa067e338616c765d98"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab33c97667e644fa067e338616c765d98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ab33c97667e644fa067e338616c765d98">MultiplyColumns</a> (const cudaStream_t &amp;stream, size_t rows, size_t cols, T *__restrict__ col_major_matrix, const T *const __restrict__ vector)</td></tr>
<tr class="separator:ab33c97667e644fa067e338616c765d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ada2e0303fe9ea6733181c936dd67a3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5ada2e0303fe9ea6733181c936dd67a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a5ada2e0303fe9ea6733181c936dd67a3">MultiplyAndCopyColumns</a> (const cudaStream_t &amp;stream, size_t rows, size_t cols, T *__restrict__ out_ptr, const T *const __restrict__ col_major_matrix, const T *const __restrict__ vector)</td></tr>
<tr class="separator:a5ada2e0303fe9ea6733181c936dd67a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8642d185de7ece8c2d37ea649b143a12"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TReal , class TIndex , InterpolationMode INTERPOLATION, CoordinateMapping MAPPING, bool ALIGN_CORNERS, bool INDIVIDUAL_EXTENT, bool ISOTROPIC_EXTENT, bool NORMALIZE&gt; </td></tr>
<tr class="memitem:a8642d185de7ece8c2d37ea649b143a12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a8642d185de7ece8c2d37ea649b143a12">_CConvTransposeComputeFeaturesCPU</a> (TOut *out_features, const std::vector&lt; int &gt; &amp;filter_dims, const TFeat *filter, size_t num_out, const TReal *out_positions, const TFeat *out_importance, size_t num_inp, const TReal *inp_positions, const TFeat *inp_features, const TFeat *inp_neighbors_importance_sum, const int64_t *inp_neighbors_row_splits, size_t neighbors_index_size, const TIndex *neighbors_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TReal *extents, const TReal *offsets)</td></tr>
<tr class="separator:a8642d185de7ece8c2d37ea649b143a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa392243129810b195110b9e5e8797ebe"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TReal , class TIndex &gt; </td></tr>
<tr class="memitem:aa392243129810b195110b9e5e8797ebe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#aa392243129810b195110b9e5e8797ebe">CConvTransposeComputeFeaturesCPU</a> (TOut *out_features, const std::vector&lt; int &gt; &amp;filter_dims, const TFeat *filter, size_t num_out, const TReal *out_positions, const TFeat *out_importance, size_t num_inp, const TReal *inp_positions, const TFeat *inp_features, const TFeat *inp_neighbors_importance_sum, const int64_t *inp_neighbors_row_splits, size_t neighbors_index_size, const TIndex *neighbors_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TReal *extents, const TReal *offsets, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a> interpolation, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a> coordinate_mapping, bool align_corners, bool individual_extent, bool isotropic_extent, bool normalize)</td></tr>
<tr class="separator:aa392243129810b195110b9e5e8797ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d6f8544e28101fed68f6bb1d96ac0a"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TReal , class TIndex , InterpolationMode INTERPOLATION, CoordinateMapping MAPPING, bool ALIGN_CORNERS, bool INDIVIDUAL_EXTENT, bool ISOTROPIC_EXTENT, bool NORMALIZE&gt; </td></tr>
<tr class="memitem:a07d6f8544e28101fed68f6bb1d96ac0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a07d6f8544e28101fed68f6bb1d96ac0a">_CConvTransposeBackpropFilterCPU</a> (TOut *filter_backprop, const std::vector&lt; int &gt; &amp;filter_dims, size_t num_out, const TReal *out_positions, const TFeat *out_importance, size_t num_inp, const TReal *inp_positions, const TFeat *inp_features, const TFeat *inp_neighbors_importance_sum, const int64_t *inp_neighbors_row_splits, size_t neighbors_index_size, const TIndex *neighbors_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TReal *extents, const TReal *offsets, const TFeat *out_features_gradient)</td></tr>
<tr class="separator:a07d6f8544e28101fed68f6bb1d96ac0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5767377c48823809453b9bcfa441acbf"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TReal , class TIndex &gt; </td></tr>
<tr class="memitem:a5767377c48823809453b9bcfa441acbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a5767377c48823809453b9bcfa441acbf">CConvTransposeBackpropFilterCPU</a> (TOut *filter_backprop, const std::vector&lt; int &gt; &amp;filter_dims, size_t num_out, const TReal *out_positions, const TFeat *out_importance, size_t num_inp, const TReal *inp_positions, const TFeat *inp_features, const TFeat *inp_neighbors_importance_sum, const int64_t *inp_neighbors_row_splits, size_t neighbors_index_size, const TIndex *neighbors_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TReal *extents, const TReal *offsets, const TFeat *out_features_gradient, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a> interpolation, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a> coordinate_mapping, bool align_corners, bool individual_extent, bool isotropic_extent, bool normalize)</td></tr>
<tr class="separator:a5767377c48823809453b9bcfa441acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8396125aae3812d1757ef005bc4c3ce4"><td class="memTemplParams" colspan="2">template&lt;class T , int VECSIZE&gt; </td></tr>
<tr class="memitem:a8396125aae3812d1757ef005bc4c3ce4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a8396125aae3812d1757ef005bc4c3ce4">MapSphereToCylinder</a> (Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;x, Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;y, Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;z)</td></tr>
<tr class="separator:a8396125aae3812d1757ef005bc4c3ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfff6f757e20d8bb7a1d4d91ef51a6e"><td class="memTemplParams" colspan="2">template&lt;class T , int VECSIZE&gt; </td></tr>
<tr class="memitem:a9dfff6f757e20d8bb7a1d4d91ef51a6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a9dfff6f757e20d8bb7a1d4d91ef51a6e">MapCylinderToCube</a> (Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;x, Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;y, Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;z)</td></tr>
<tr class="separator:a9dfff6f757e20d8bb7a1d4d91ef51a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad572103472cf4e42c90b41aa88b6d51e"><td class="memTemplParams" colspan="2">template&lt;bool ALIGN_CORNERS, CoordinateMapping MAPPING, class T , int VECSIZE&gt; </td></tr>
<tr class="memitem:ad572103472cf4e42c90b41aa88b6d51e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad572103472cf4e42c90b41aa88b6d51e">ComputeFilterCoordinates</a> (Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;x, Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;y, Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;z, const Eigen::Array&lt; int, 3, 1 &gt; &amp;filter_size, const Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 3 &gt; &amp;inv_extents, const Eigen::Array&lt; T, 3, 1 &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aed7ea92f45bd273dde380a45ddced592">offset</a>)</td></tr>
<tr class="separator:ad572103472cf4e42c90b41aa88b6d51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f6650b9dad6e80fb75b2cc483c00da"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TAttr &gt; </td></tr>
<tr class="memitem:a75f6650b9dad6e80fb75b2cc483c00da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a75f6650b9dad6e80fb75b2cc483c00da">InvertNeighborsListCPU</a> (const TIndex *const inp_neighbors_index, const TAttr *const inp_neighbors_attributes, const int num_attributes_per_neighbor, const int64_t *const inp_neighbors_row_splits, const size_t inp_num_queries, TIndex *out_neighbors_index, TAttr *out_neighbors_attributes, const size_t index_size, int64_t *out_neighbors_row_splits, const size_t out_num_queries)</td></tr>
<tr class="separator:a75f6650b9dad6e80fb75b2cc483c00da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba7048a0c2c5e75582268d5c6379b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ml_2impl_2misc_2_neighbor_search_common_8h.5#a9e64b37aa76347c9bf88985c9dec78c9">HOST_DEVICE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2ba7048a0c2c5e75582268d5c6379b17">SpatialHash</a> (int x, int y, int z)</td></tr>
<tr class="memdesc:a2ba7048a0c2c5e75582268d5c6379b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial hashing function for integer coordinates.  <a href="namespaceopen3d_1_1ml_1_1impl.html#a2ba7048a0c2c5e75582268d5c6379b17">More...</a><br /></td></tr>
<tr class="separator:a2ba7048a0c2c5e75582268d5c6379b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf17e3006f30d62c6d5d7826525d7e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ml_2impl_2misc_2_neighbor_search_common_8h.5#a9e64b37aa76347c9bf88985c9dec78c9">HOST_DEVICE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#adf17e3006f30d62c6d5d7826525d7e57">SpatialHash</a> (const <a class="el" href="structopen3d_1_1utility_1_1_mini_vec.451.del">utility::MiniVec</a>&lt; int, 3 &gt; &amp;xyz)</td></tr>
<tr class="separator:adf17e3006f30d62c6d5d7826525d7e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92929580642398d480c881567fef343"><td class="memTemplParams" colspan="2">template&lt;class TVecf &gt; </td></tr>
<tr class="memitem:af92929580642398d480c881567fef343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ml_2impl_2misc_2_neighbor_search_common_8h.5#a9e64b37aa76347c9bf88985c9dec78c9">HOST_DEVICE</a> <a class="el" href="structopen3d_1_1utility_1_1_mini_vec.451.del">utility::MiniVec</a>&lt; int, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#af92929580642398d480c881567fef343">ComputeVoxelIndex</a> (const TVecf &amp;pos, const typename TVecf::Scalar_t &amp;inv_voxel_size)</td></tr>
<tr class="separator:af92929580642398d480c881567fef343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24166fa5df1261dd6b3770ca65e4d907"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a24166fa5df1261dd6b3770ca65e4d907"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a24166fa5df1261dd6b3770ca65e4d907">RaggedToDenseCPU</a> (const T *const values, const int64_t *const row_splits, const size_t row_splits_size, const size_t out_col_size, const T *const default_value, const size_t default_value_size, T *out_values)</td></tr>
<tr class="separator:a24166fa5df1261dd6b3770ca65e4d907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1434b97a6fab04dad1874e85414bd0a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad1434b97a6fab04dad1874e85414bd0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad1434b97a6fab04dad1874e85414bd0a">ReduceSubarraysSumCPU</a> (const T *const values, const size_t values_size, const int64_t *const row_splits, const size_t num_arrays, T *out_sums)</td></tr>
<tr class="separator:ad1434b97a6fab04dad1874e85414bd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67e52bbf53aa080b09bc8655ab2979f"><td class="memTemplParams" colspan="2">template&lt;class T , int NDIM, class OUTPUT_ALLOCATOR &gt; </td></tr>
<tr class="memitem:aa67e52bbf53aa080b09bc8655ab2979f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#aa67e52bbf53aa080b09bc8655ab2979f">VoxelizeCPU</a> (const size_t num_points, const T *const <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, const size_t batch_size, const int64_t *const row_splits, const T *const voxel_size, const T *const points_range_min, const T *const points_range_max, const int64_t max_points_per_voxel, const int64_t max_voxels, OUTPUT_ALLOCATOR &amp;output_allocator)</td></tr>
<tr class="separator:aa67e52bbf53aa080b09bc8655ab2979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55905eecdd5e2f89aa4c576dd2586a64"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a55905eecdd5e2f89aa4c576dd2586a64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a55905eecdd5e2f89aa4c576dd2586a64">CheckVoxelSize</a> (std::string &amp;err, const size_t num_positions, const T *const positions, const T voxel_size)</td></tr>
<tr class="memdesc:a55905eecdd5e2f89aa4c576dd2586a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for debugging. Checks if the voxel size is too small.  <a href="namespaceopen3d_1_1ml_1_1impl.html#a55905eecdd5e2f89aa4c576dd2586a64">More...</a><br /></td></tr>
<tr class="separator:a55905eecdd5e2f89aa4c576dd2586a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22f42402372b29f51f9efdfb5c277cb"><td class="memTemplParams" colspan="2">template&lt;class TDerived &gt; </td></tr>
<tr class="memitem:ad22f42402372b29f51f9efdfb5c277cb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3i&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad22f42402372b29f51f9efdfb5c277cb">ComputeVoxelIndex</a> (const Eigen::ArrayBase&lt; TDerived &gt; &amp;pos, const typename TDerived::Scalar &amp;inv_voxel_size)</td></tr>
<tr class="separator:ad22f42402372b29f51f9efdfb5c277cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea439b989f189521c1727821ac45e19"><td class="memTemplParams" colspan="2">template&lt;class TReal , class TFeat , class ACCUMULATOR , class OUTPUT_ALLOCATOR &gt; </td></tr>
<tr class="memitem:a9ea439b989f189521c1727821ac45e19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a9ea439b989f189521c1727821ac45e19">_VoxelPooling</a> (size_t num_inp, const TReal *const inp_positions, int in_channels, const TFeat *inp_features, TReal voxel_size, OUTPUT_ALLOCATOR &amp;output_allocator)</td></tr>
<tr class="separator:a9ea439b989f189521c1727821ac45e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7045e1fb9e47843c246510605d1f12d6"><td class="memTemplParams" colspan="2">template&lt;class TReal , class TFeat , class ACCUMULATOR , AccumulationFn FEAT_FN&gt; </td></tr>
<tr class="memitem:a7045e1fb9e47843c246510605d1f12d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a7045e1fb9e47843c246510605d1f12d6">_VoxelPoolingBackprop</a> (TFeat *features_backprop, size_t num_inp, const TReal *const inp_positions, int in_channels, const TFeat *const inp_features, size_t num_pooled, const TReal *const pooled_positions, const TFeat *const pooled_features_gradient, TReal voxel_size)</td></tr>
<tr class="separator:a7045e1fb9e47843c246510605d1f12d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e7e987171a6b5072f2fbb204aaafc6"><td class="memTemplParams" colspan="2">template&lt;class TReal , class TFeat , class OUTPUT_ALLOCATOR &gt; </td></tr>
<tr class="memitem:a62e7e987171a6b5072f2fbb204aaafc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a62e7e987171a6b5072f2fbb204aaafc6">VoxelPooling</a> (size_t num_inp, const TReal *const inp_positions, int in_channels, const TFeat *inp_features, TReal voxel_size, OUTPUT_ALLOCATOR &amp;output_allocator, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a> position_fn, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a> feature_fn)</td></tr>
<tr class="separator:a62e7e987171a6b5072f2fbb204aaafc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d745469c230104929e05255ef40c811"><td class="memTemplParams" colspan="2">template&lt;class TReal , class TFeat &gt; </td></tr>
<tr class="memitem:a4d745469c230104929e05255ef40c811"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a4d745469c230104929e05255ef40c811">VoxelPoolingBackprop</a> (TFeat *features_backprop, size_t num_inp, const TReal *const inp_positions, int in_channels, const TFeat *const inp_features, size_t num_pooled, const TReal *const pooled_positions, const TFeat *const pooled_features_gradient, TReal voxel_size, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a> position_fn, <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a> feature_fn)</td></tr>
<tr class="separator:a4d745469c230104929e05255ef40c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0bbc4ca67a9258234590e4167126c4"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex , bool POINT_IMPORTANCE&gt; </td></tr>
<tr class="memitem:adf0bbc4ca67a9258234590e4167126c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#adf0bbc4ca67a9258234590e4167126c4">_SparseConvComputeFeaturesCPU</a> (TOut *out_features, const std::vector&lt; int &gt; &amp;filter_dims, const TFeat *filter, size_t num_out, size_t num_inp, const TFeat *inp_features, const TFeat *inp_importance, size_t neighbors_index_size, const TIndex *neighbors_index, const TKernelIndex *neighbors_kernel_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, bool normalize)</td></tr>
<tr class="separator:adf0bbc4ca67a9258234590e4167126c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec33cbd0177d9b1c1fb9801fe45cbae5"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex &gt; </td></tr>
<tr class="memitem:aec33cbd0177d9b1c1fb9801fe45cbae5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#aec33cbd0177d9b1c1fb9801fe45cbae5">SparseConvComputeFeaturesCPU</a> (TOut *out_features, const std::vector&lt; int &gt; &amp;filter_dims, const TFeat *filter, size_t num_out, size_t num_inp, const TFeat *inp_features, const TFeat *inp_importance, size_t neighbors_index_size, const TIndex *neighbors_index, const TKernelIndex *neighbors_kernel_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, bool normalize)</td></tr>
<tr class="separator:aec33cbd0177d9b1c1fb9801fe45cbae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a896262f55b1d3ae980406434a80e4"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex , bool POINT_IMPORTANCE&gt; </td></tr>
<tr class="memitem:a63a896262f55b1d3ae980406434a80e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a63a896262f55b1d3ae980406434a80e4">_SparseConvBackropFilterCPU</a> (TOut *filter_backprop, const std::vector&lt; int &gt; &amp;filter_dims, size_t num_out, size_t num_inp, const TFeat *inp_features, const TFeat *inp_importance, const TIndex *neighbors_index, const TKernelIndex *neighbors_kernel_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TFeat *out_features_gradient, bool normalize)</td></tr>
<tr class="separator:a63a896262f55b1d3ae980406434a80e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b31d4e95c88cba83800bec19cf79a1"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex &gt; </td></tr>
<tr class="memitem:af0b31d4e95c88cba83800bec19cf79a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#af0b31d4e95c88cba83800bec19cf79a1">SparseConvBackpropFilterCPU</a> (TOut *filter_backprop, const std::vector&lt; int &gt; &amp;filter_dims, size_t num_out, size_t num_inp, const TFeat *inp_features, const TFeat *inp_importance, const TIndex *neighbors_index, const TKernelIndex *neighbors_kernel_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TFeat *out_features_gradient, bool normalize)</td></tr>
<tr class="separator:af0b31d4e95c88cba83800bec19cf79a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a75ac9810dde84859cb4b320724178"><td class="memTemplParams" colspan="2">template&lt;class TReal , class TIndex , class TKernelIndex &gt; </td></tr>
<tr class="memitem:af5a75ac9810dde84859cb4b320724178"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#af5a75ac9810dde84859cb4b320724178">FillColumn</a> (const cudaStream_t &amp;stream, TReal *columns, int in_channels, TIndex begin_idx, TIndex end_idx, TIndex num_out, TIndex num_inp, const TReal *const __restrict__ inp_features, const TReal *const __restrict__ inp_importance, size_t neighbors_index_size, const TIndex *const __restrict__ neighbors_index, const TKernelIndex *const __restrict__ neighbors_kernel_index, const TReal *const __restrict__ neighbors_importance, const int64_t *const __restrict__ neighbors_row_splits, const int num_kernel_elements, bool normalize)</td></tr>
<tr class="separator:af5a75ac9810dde84859cb4b320724178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442200f9fa014ac0b6c63b3368c33d64"><td class="memTemplParams" colspan="2">template&lt;class TReal , class TIndex , class TKernelIndex &gt; </td></tr>
<tr class="memitem:a442200f9fa014ac0b6c63b3368c33d64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a442200f9fa014ac0b6c63b3368c33d64">FillColumnTranspose</a> (const cudaStream_t &amp;stream, TReal *columns, int in_channels, TIndex begin_idx, TIndex end_idx, TIndex num_out, TIndex num_inp, const TReal *const __restrict__ inp_features, const TReal *const __restrict__ inp_neighbors_importance_sum, const int64_t *const __restrict__ inp_neighbors_prefix_sum, size_t neighbors_index_size, const TIndex *const __restrict__ neighbors_index, const TKernelIndex *const __restrict__ neighbors_kernel_index, const TReal *const __restrict__ neighbors_importance, const int64_t *const __restrict__ neighbors_row_splits, const int num_kernel_elements, bool normalize)</td></tr>
<tr class="separator:a442200f9fa014ac0b6c63b3368c33d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd47065b534fb39910eff633a690263"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex , bool NORMALIZE&gt; </td></tr>
<tr class="memitem:a6bd47065b534fb39910eff633a690263"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a6bd47065b534fb39910eff633a690263">_SparseConvTransposeComputeFeaturesCPU</a> (TOut *out_features, const std::vector&lt; int &gt; &amp;filter_dims, const TFeat *filter, size_t num_out, const TFeat *out_importance, size_t num_inp, const TFeat *inp_features, const TFeat *inp_neighbors_importance_sum, const int64_t *inp_neighbors_row_splits, const TIndex *neighbor_index, const TKernelIndex *neighbors_kernel_index, const TFeat *neighbor_importance, const int64_t *neighbors_row_splits)</td></tr>
<tr class="separator:a6bd47065b534fb39910eff633a690263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc02e95ef89abfaf320cff95550d003b"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex &gt; </td></tr>
<tr class="memitem:acc02e95ef89abfaf320cff95550d003b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#acc02e95ef89abfaf320cff95550d003b">SparseConvTransposeComputeFeaturesCPU</a> (TOut *out_features, const std::vector&lt; int &gt; &amp;filter_dims, const TFeat *filter, size_t num_out, const TFeat *out_importance, size_t num_inp, const TFeat *inp_features, const TFeat *inp_neighbors_importance_sum, const int64_t *inp_neighbors_row_splits, const TIndex *neighbor_index, const TKernelIndex *neighbors_kernel_index, const TFeat *neighbor_importance, const int64_t *neighbors_row_splits, bool normalize)</td></tr>
<tr class="separator:acc02e95ef89abfaf320cff95550d003b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98cbb65c76002b07e07a78c2e2f8a28"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex , bool NORMALIZE&gt; </td></tr>
<tr class="memitem:ac98cbb65c76002b07e07a78c2e2f8a28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ac98cbb65c76002b07e07a78c2e2f8a28">_SparseConvTransposeBackpropFilterCPU</a> (TOut *filter_backprop, const std::vector&lt; int &gt; &amp;filter_dims, size_t num_out, const TFeat *out_importance, size_t num_inp, const TFeat *inp_features, const TFeat *inp_neighbors_importance_sum, const int64_t *inp_neighbors_row_splits, const TIndex *neighbors_index, const TKernelIndex *neighbors_kernel_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TFeat *out_features_gradient)</td></tr>
<tr class="separator:ac98cbb65c76002b07e07a78c2e2f8a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbe76e2c7acddc61703e43e41cd9049"><td class="memTemplParams" colspan="2">template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex &gt; </td></tr>
<tr class="memitem:abcbe76e2c7acddc61703e43e41cd9049"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#abcbe76e2c7acddc61703e43e41cd9049">SparseConvTransposeBackpropFilterCPU</a> (TOut *filter_backprop, const std::vector&lt; int &gt; &amp;filter_dims, size_t num_out, const TFeat *out_importance, size_t num_inp, const TFeat *inp_features, const TFeat *inp_neighbors_importance_sum, const int64_t *inp_neighbors_row_splits, const TIndex *neighbors_index, const TKernelIndex *neighbors_kernel_index, const TFeat *neighbors_importance, const int64_t *neighbors_row_splits, const TFeat *out_features_gradient, bool normalize)</td></tr>
<tr class="separator:abcbe76e2c7acddc61703e43e41cd9049"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2902d456779f799905d50574750e1f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2902d456779f799905d50574750e1f62">&#9670;&nbsp;</a></span>AccumulationFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">open3d::ml::impl::AccumulationFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2902d456779f799905d50574750e1f62aa85acf2e4cf435c4f7d6a0ae0b6e537a"></a>AVERAGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2902d456779f799905d50574750e1f62a4c3ea169e4887079fcee81e2d9c07a60"></a>NEAREST_NEIGHBOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2902d456779f799905d50574750e1f62a7f5ccbc3d30c2cd3fd04d567946cbde2"></a>NEAREST_NEIGHBOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2902d456779f799905d50574750e1f62a520d9ae28496893067609b457fba01eb"></a>MAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2902d456779f799905d50574750e1f62a3b7d3ad96d80e65de4906f736ac9353c"></a>CENTER&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad39d07a9288168e9ecab8f34e24d27fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39d07a9288168e9ecab8f34e24d27fb">&#9670;&nbsp;</a></span>CoordinateMapping</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">open3d::ml::impl::CoordinateMapping</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coordinate Mapping functions</p><ul>
<li>BALL_TO_CUBE_RADIAL uses radial stretching to map a sphere to a cube.</li>
<li>BALL_TO_CUBE_VOLUME_PRESERVING is using a more expensive volume preserving mapping to map a sphere to a cube.</li>
<li>IDENTITY no mapping is applied to the coordinates. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad39d07a9288168e9ecab8f34e24d27fba128eca8782c4ff1d0e70ee09d99ec5d7"></a>BALL_TO_CUBE_RADIAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad39d07a9288168e9ecab8f34e24d27fba3bdf207d9ebb484a4aa36673674fa69f"></a>BALL_TO_CUBE_VOLUME_PRESERVING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad39d07a9288168e9ecab8f34e24d27fbad8156d3c6735d75d8a1b8dedd0e79c8b"></a>IDENTITY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1cdea72ec606986b7ada2e619ea41a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdea72ec606986b7ada2e619ea41a8d">&#9670;&nbsp;</a></span>InterpolationMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">open3d::ml::impl::InterpolationMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interpolation modes LINEAR is a standard trilinear interpolation with coordinate clamping LINEAR_BORDER uses a zero border instead of clamping NEAREST_NEIGHBOR no interpolation, use nearest neighbor </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1cdea72ec606986b7ada2e619ea41a8daaac544aacc3615aada24897a215f5046"></a>LINEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1cdea72ec606986b7ada2e619ea41a8daedc71d68a68ed5f29b9a3e9cb2e680d9"></a>LINEAR_BORDER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2902d456779f799905d50574750e1f62a7f5ccbc3d30c2cd3fd04d567946cbde2"></a>NEAREST_NEIGHBOR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a94f613764e8b95ac53d1890d8da19d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f613764e8b95ac53d1890d8da19d7c">&#9670;&nbsp;</a></span>Metric</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a94f613764e8b95ac53d1890d8da19d7c">open3d::ml::impl::Metric</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported metrics. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a94f613764e8b95ac53d1890d8da19d7ca2031a5a13d6caf8b506c86566d401f0d"></a>L1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f613764e8b95ac53d1890d8da19d7ca431cf8c3d07b756c57361ce79e0954d0"></a>L2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f613764e8b95ac53d1890d8da19d7ca1d3426e6b02d10126b29a6a4dd254f28"></a>Linf&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5ad27ea456291d89c4f87b7737687df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad27ea456291d89c4f87b7737687df1">&#9670;&nbsp;</a></span>_CConvBackropFilterCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TReal , class TIndex , InterpolationMode INTERPOLATION, CoordinateMapping MAPPING, bool ALIGN_CORNERS, bool INDIVIDUAL_EXTENT, bool ISOTROPIC_EXTENT, bool POINT_IMPORTANCE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_CConvBackropFilterCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>filter_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_features_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55a5f730132a9d229ca36a5b578274d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a5f730132a9d229ca36a5b578274d1">&#9670;&nbsp;</a></span>_CConvComputeFeaturesCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TReal , class TIndex , InterpolationMode INTERPOLATION, CoordinateMapping MAPPING, bool ALIGN_CORNERS, bool INDIVIDUAL_EXTENT, bool ISOTROPIC_EXTENT, bool POINT_IMPORTANCE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_CConvComputeFeaturesCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>out_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of CConvComputeFeatures with template parameters for configuration. </p>

</div>
</div>
<a id="a07d6f8544e28101fed68f6bb1d96ac0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d6f8544e28101fed68f6bb1d96ac0a">&#9670;&nbsp;</a></span>_CConvTransposeBackpropFilterCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TReal , class TIndex , InterpolationMode INTERPOLATION, CoordinateMapping MAPPING, bool ALIGN_CORNERS, bool INDIVIDUAL_EXTENT, bool ISOTROPIC_EXTENT, bool NORMALIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_CConvTransposeBackpropFilterCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>filter_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_features_gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of CConvTransposeBackpropFilterCPU with template parameters for configuration. </p>

</div>
</div>
<a id="a8642d185de7ece8c2d37ea649b143a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8642d185de7ece8c2d37ea649b143a12">&#9670;&nbsp;</a></span>_CConvTransposeComputeFeaturesCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TReal , class TIndex , InterpolationMode INTERPOLATION, CoordinateMapping MAPPING, bool ALIGN_CORNERS, bool INDIVIDUAL_EXTENT, bool ISOTROPIC_EXTENT, bool NORMALIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_CConvTransposeComputeFeaturesCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>out_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of CConvComputeFeatures with template parameters for configuration. </p>

</div>
</div>
<a id="a63a896262f55b1d3ae980406434a80e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a896262f55b1d3ae980406434a80e4">&#9670;&nbsp;</a></span>_SparseConvBackropFilterCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex , bool POINT_IMPORTANCE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_SparseConvBackropFilterCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>filter_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_features_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf0bbc4ca67a9258234590e4167126c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0bbc4ca67a9258234590e4167126c4">&#9670;&nbsp;</a></span>_SparseConvComputeFeaturesCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex , bool POINT_IMPORTANCE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_SparseConvComputeFeaturesCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>out_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of SparseConvComputeFeatures with template parameters for configuration. </p>

</div>
</div>
<a id="ac98cbb65c76002b07e07a78c2e2f8a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98cbb65c76002b07e07a78c2e2f8a28">&#9670;&nbsp;</a></span>_SparseConvTransposeBackpropFilterCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex , bool NORMALIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_SparseConvTransposeBackpropFilterCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>filter_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_features_gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of SparseConvTransposeBackpropFilterCPU with template parameters for configuration. </p>

</div>
</div>
<a id="a6bd47065b534fb39910eff633a690263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd47065b534fb39910eff633a690263">&#9670;&nbsp;</a></span>_SparseConvTransposeComputeFeaturesCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex , bool NORMALIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_SparseConvTransposeComputeFeaturesCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>out_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbor_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of SparseConvTransposeComputeFeatures with template parameters for configuration. </p>

</div>
</div>
<a id="a9ea439b989f189521c1727821ac45e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea439b989f189521c1727821ac45e19">&#9670;&nbsp;</a></span>_VoxelPooling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TReal , class TFeat , class ACCUMULATOR , class OUTPUT_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_VoxelPooling </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TReal&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUTPUT_ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>output_allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7045e1fb9e47843c246510605d1f12d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7045e1fb9e47843c246510605d1f12d6">&#9670;&nbsp;</a></span>_VoxelPoolingBackprop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TReal , class TFeat , class ACCUMULATOR , AccumulationFn FEAT_FN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::_VoxelPoolingBackprop </td>
          <td>(</td>
          <td class="paramtype">TFeat *&#160;</td>
          <td class="paramname"><em>features_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_pooled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const&#160;</td>
          <td class="paramname"><em>pooled_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const&#160;</td>
          <td class="paramname"><em>pooled_features_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TReal&#160;</td>
          <td class="paramname"><em>voxel_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6f83a7bf58ab46e57e8e45c88628d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f83a7bf58ab46e57e8e45c88628d6b">&#9670;&nbsp;</a></span>CConvBackpropFilterCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TReal , class TIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::CConvBackpropFilterCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>filter_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_features_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a>&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a>&#160;</td>
          <td class="paramname"><em>coordinate_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>individual_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isotropic_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the backprop for the filter of a continuous convolution.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFeat</td><td>Type for the features and weights </td></tr>
    <tr><td class="paramname">TOut</td><td>Type for the output features </td></tr>
    <tr><td class="paramname">TReal</td><td>Type for point positions and extents </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type for neighbor indexing</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_backprop</td><td>Output array for the computed filter gradient with shape [depth,height,width, inp channels, out channels]</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The sizes of the filter dimensions. The size of filter_dims must be 5. The order is [depth, height, width, inp channels, out channels].</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">out_positions</td><td>The positions of the output points. The shape is [num_out, 3].</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_positions</td><td>The positions of the input points. The shape is [num_inp, 3].</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_importance</td><td>Optional importance for each input point with shape [num_inp]. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_index_size</td><td>The size of the neighbors_index array.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">extents</td><td>The spatial extents of the filter in coordinate units. extents can be a scalar or a 1D array of shape [num_out] or a 2D array of shape [num_out,3]. The shape depends on <code>individual_extent</code> and <code>isotropic_extent</code>.</td></tr>
    <tr><td class="paramname">offsets</td><td>A single 3D vector used in the filter coordinate computation. The shape is [3].</td></tr>
    <tr><td class="paramname">interpolation</td><td>The interpolation mode. Either LINEAR or NEAREST_NEIGHBOR.</td></tr>
    <tr><td class="paramname">coordinate_mapping</td><td>The coordinate mapping function. One of IDENTITY, BALL_TO_CUBE_RADIAL, BALL_TO_CUBE_VOLUME_PRESERVING.</td></tr>
    <tr><td class="paramname">align_corners</td><td>If true then the voxel centers of the outer voxels of the filter array are mapped to the boundary of the filter shape. If false then the boundary of the filter array is mapped to the boundary of the filter shape.</td></tr>
    <tr><td class="paramname">individual_extent</td><td>If true each output point has an individual extent.</td></tr>
    <tr><td class="paramname">isotropic_extent</td><td>If true each then the extent is isotropic for each output point.</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the output features are normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ae65fff6532e57f12b737eaaa228ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae65fff6532e57f12b737eaaa228ddb">&#9670;&nbsp;</a></span>CConvComputeFeaturesCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TReal , class TIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::CConvComputeFeaturesCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>out_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a>&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a>&#160;</td>
          <td class="paramname"><em>coordinate_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>individual_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isotropic_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the output features of a continuous convolution.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFeat</td><td>Type for the features and weights </td></tr>
    <tr><td class="paramname">TOut</td><td>Type for the output features </td></tr>
    <tr><td class="paramname">TReal</td><td>Type for point positions and extents </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type for neighbor indexing</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_features</td><td>Output array for the computed features with shape [num_out, out channels]</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The sizes of the filter dimensions. The size of filter_dims must be 5. The order is [depth, height, width, inp channels, out channels].</td></tr>
    <tr><td class="paramname">filter</td><td>Pointer to the filter values.</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">out_positions</td><td>The positions of the output points. The shape is [num_out, 3].</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_positions</td><td>The positions of the input points. The shape is [num_inp, 3].</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_importance</td><td>Optional importance for each input point with shape [num_inp]. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_index_size</td><td>The size of the neighbors_index array.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">extents</td><td>The spatial extents of the filter in coordinate units. extents can be a scalar or a 1D array of shape [num_out] or a 2D array of shape [num_out,3]. The shape depends on <code>individual_extent</code> and <code>isotropic_extent</code>.</td></tr>
    <tr><td class="paramname">offsets</td><td>A single 3D vector used in the filter coordinate computation. The shape is [3].</td></tr>
    <tr><td class="paramname">interpolation</td><td>The interpolation mode. Either LINEAR or NEAREST_NEIGHBOR.</td></tr>
    <tr><td class="paramname">coordinate_mapping</td><td>The coordinate mapping function. One of IDENTITY, BALL_TO_CUBE_RADIAL, BALL_TO_CUBE_VOLUME_PRESERVING.</td></tr>
    <tr><td class="paramname">align_corners</td><td>If true then the voxel centers of the outer voxels of the filter array are mapped to the boundary of the filter shape. If false then the boundary of the filter array is mapped to the boundary of the filter shape.</td></tr>
    <tr><td class="paramname">individual_extent</td><td>If true each output point has an individual extent.</td></tr>
    <tr><td class="paramname">isotropic_extent</td><td>If true each then the extent is isotropic for each output point.</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the result is normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5767377c48823809453b9bcfa441acbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5767377c48823809453b9bcfa441acbf">&#9670;&nbsp;</a></span>CConvTransposeBackpropFilterCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TReal , class TIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::CConvTransposeBackpropFilterCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>filter_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_features_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a>&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a>&#160;</td>
          <td class="paramname"><em>coordinate_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>individual_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isotropic_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the backprop for the filter of a transpose continuous convolution.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFeat</td><td>Type for the features and weights </td></tr>
    <tr><td class="paramname">TOut</td><td>Type for the output features </td></tr>
    <tr><td class="paramname">TReal</td><td>Type for point positions and extents </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type for neighbor indexing</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_backprop</td><td>Output array for the computed filter gradient with shape [depth,height,width, inp channels, out channels]</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The sizes of the filter dimensions. The size of filter_dims must be 5. The order is [depth, height, width, inp channels, out channels].</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">out_positions</td><td>The positions of the output points. The shape is [num_out, 3].</td></tr>
    <tr><td class="paramname">out_importance</td><td>Optional importance for each output point with shape [num_out]. Set to null to disable.</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_positions</td><td>The positions of the input points. The shape is [num_inp, 3].</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_neighbors_importance_sum</td><td>The sum of the neighbors_importance values for each input with shape [num_inp].</td></tr>
    <tr><td class="paramname">inp_neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>inp_neighbors_index</code>. The size of the array is <code>num_inp</code> + 1.</td></tr>
    <tr><td class="paramname">neighbors_index_size</td><td>The size of the neighbors_index array.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">extents</td><td>The spatial extents of the filter in coordinate units. extents can be a scalar or a 1D array of shape [num_out] or a 2D array of shape [num_out,3]. The shape depends on <code>individual_extent</code> and <code>isotropic_extent</code>.</td></tr>
    <tr><td class="paramname">offsets</td><td>A single 3D vector used in the filter coordinate computation. The shape is [3].</td></tr>
    <tr><td class="paramname">out_features_gradient</td><td>The gradient from the features with shape [num_out, out_channels]</td></tr>
    <tr><td class="paramname">interpolation</td><td>The interpolation mode. Either LINEAR or NEAREST_NEIGHBOR.</td></tr>
    <tr><td class="paramname">coordinate_mapping</td><td>The coordinate mapping function. One of IDENTITY, BALL_TO_CUBE_RADIAL, BALL_TO_CUBE_VOLUME_PRESERVING.</td></tr>
    <tr><td class="paramname">align_corners</td><td>If true then the voxel centers of the outer voxels of the filter array are mapped to the boundary of the filter shape. If false then the boundary of the filter array is mapped to the boundary of the filter shape.</td></tr>
    <tr><td class="paramname">individual_extent</td><td>If true each output point has an individual extent.</td></tr>
    <tr><td class="paramname">isotropic_extent</td><td>If true each then the extent is isotropic for each output point.</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the result is normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa392243129810b195110b9e5e8797ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa392243129810b195110b9e5e8797ebe">&#9670;&nbsp;</a></span>CConvTransposeComputeFeaturesCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TReal , class TIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::CConvTransposeComputeFeaturesCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>out_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a>&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a>&#160;</td>
          <td class="paramname"><em>coordinate_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>individual_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isotropic_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the output features of a transpose continuous convolution.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFeat</td><td>Type for the features and weights </td></tr>
    <tr><td class="paramname">TOut</td><td>Type for the output features </td></tr>
    <tr><td class="paramname">TReal</td><td>Type for point positions and extents </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type for neighbor indexing</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_features</td><td>Output array for the computed features with shape [num_out, out channels]</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The sizes of the filter dimensions. The size of filter_dims must be 5. The order is [depth, height, width, inp channels, out channels].</td></tr>
    <tr><td class="paramname">filter</td><td>Pointer to the filter values.</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">out_positions</td><td>The positions of the output points. The shape is [num_out, 3].</td></tr>
    <tr><td class="paramname">out_importance</td><td>Optional importance for each output point with shape [num_out]. Set to null to disable.</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_positions</td><td>The positions of the input points. The shape is [num_inp, 3].</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_neighbors_importance_sum</td><td>The sum of the neighbors_importance values for each input with shape [num_inp].</td></tr>
    <tr><td class="paramname">inp_neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>inp_neighbors_index</code>. The size of the array is <code>num_inp</code> + 1.</td></tr>
    <tr><td class="paramname">neighbors_index_size</td><td>The size of the neighbors_index array.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">extents</td><td>The spatial extents of the filter in coordinate units. extents can be a scalar or a 1D array of shape [num_out] or a 2D array of shape [num_out,3]. The shape depends on <code>individual_extent</code> and <code>isotropic_extent</code>.</td></tr>
    <tr><td class="paramname">offsets</td><td>A single 3D vector used in the filter coordinate computation. The shape is [3].</td></tr>
    <tr><td class="paramname">interpolation</td><td>The interpolation mode. Either LINEAR or NEAREST_NEIGHBOR.</td></tr>
    <tr><td class="paramname">coordinate_mapping</td><td>The coordinate mapping function. One of IDENTITY, BALL_TO_CUBE_RADIAL, BALL_TO_CUBE_VOLUME_PRESERVING.</td></tr>
    <tr><td class="paramname">align_corners</td><td>If true then the voxel centers of the outer voxels of the filter array are mapped to the boundary of the filter shape. If false then the boundary of the filter array is mapped to the boundary of the filter shape.</td></tr>
    <tr><td class="paramname">individual_extent</td><td>If true each output point has an individual extent.</td></tr>
    <tr><td class="paramname">isotropic_extent</td><td>If true each then the extent is isotropic for each output point.</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the result is normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55905eecdd5e2f89aa4c576dd2586a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55905eecdd5e2f89aa4c576dd2586a64">&#9670;&nbsp;</a></span>CheckVoxelSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::ml::impl::CheckVoxelSize </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>voxel_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for debugging. Checks if the voxel size is too small. </p>

</div>
</div>
<a id="ad572103472cf4e42c90b41aa88b6d51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad572103472cf4e42c90b41aa88b6d51e">&#9670;&nbsp;</a></span>ComputeFilterCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ALIGN_CORNERS, CoordinateMapping MAPPING, class T , int VECSIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::ComputeFilterCoordinates </td>
          <td>(</td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; int, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; T, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the filter coordinates. The input to this function are coordinates relative to the point where the convolution is evaluated. Coordinates are usually in the range [-extent/2,extent/2] with extent as the edge length of the bounding box of the filter shape. The output is a coordinate within the filter array, i.e. the range is [0, filter_size.xyz], if the point was inside the filter shape.</p>
<p>The simplest filter shape is a cuboid (MAPPING=IDENTITY) and the transformation is simply [-extent/2,extent/2] -&gt; [0, filter_size.xyz]. The other type of shape that is implemented is a sphere with MAPPING=BALL_TO_CUBE_RADIAL or MAPPING=BALL_TO_CUBE_VOLUME_PRESERVING.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ALIGN_CORNERS</td><td>If true then the voxel centers of the outer voxels of the filter array are mapped to the boundary of the filter shape. If false then the boundary of the filter array is mapped to the boundary of the filter shape.</td></tr>
    <tr><td class="paramname">MAPPING</td><td>The mapping that is applied to the input coordinates.<ul>
<li>BALL_TO_CUBE_RADIAL uses radial stretching to map a sphere to a cube.</li>
<li>BALL_TO_CUBE_VOLUME_PRESERVING is using a more expensive volume preserving mapping to map a sphere to a cube.</li>
<li>IDENTITY no mapping is applied to the coordinates.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x coordinates. Input and output variable. </td></tr>
    <tr><td class="paramname">y</td><td>y coordinates. Input and output variable. </td></tr>
    <tr><td class="paramname">z</td><td>z coordinates. Input and output variable.</td></tr>
    <tr><td class="paramname">filter_size</td><td>The spatial size of the filter array in voxels.</td></tr>
    <tr><td class="paramname">inv_extents</td><td>The reciproval of the spatial extent of the filter in coordinate units.</td></tr>
    <tr><td class="paramname">offset</td><td>An offset for shifting the center. Can be used to implement discrete filters with even filter size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad22f42402372b29f51f9efdfb5c277cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22f42402372b29f51f9efdfb5c277cb">&#9670;&nbsp;</a></span>ComputeVoxelIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3i open3d::ml::impl::ComputeVoxelIndex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayBase&lt; TDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TDerived::Scalar &amp;&#160;</td>
          <td class="paramname"><em>inv_voxel_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes an integer voxel index for a 3D position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>A 3D position. </td></tr>
    <tr><td class="paramname">inv_voxel_size</td><td>The reciprocal of the voxel size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af92929580642398d480c881567fef343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92929580642398d480c881567fef343">&#9670;&nbsp;</a></span>ComputeVoxelIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TVecf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ml_2impl_2misc_2_neighbor_search_common_8h.5#a9e64b37aa76347c9bf88985c9dec78c9">HOST_DEVICE</a> <a class="el" href="structopen3d_1_1utility_1_1_mini_vec.451.del">utility::MiniVec</a>&lt;int, 3&gt; open3d::ml::impl::ComputeVoxelIndex </td>
          <td>(</td>
          <td class="paramtype">const TVecf &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TVecf::Scalar_t &amp;&#160;</td>
          <td class="paramname"><em>inv_voxel_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes an integer voxel index for a 3D position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>A 3D position. </td></tr>
    <tr><td class="paramname">inv_voxel_size</td><td>The reciprocal of the voxel size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afac64bdddd123dfede9328296c820553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac64bdddd123dfede9328296c820553">&#9670;&nbsp;</a></span>FillColumn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TReal , class TIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::FillColumn </td>
          <td>(</td>
          <td class="paramtype">const cudaStream_t &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeat *&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>begin_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>end_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a>&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a>&#160;</td>
          <td class="paramname"><em>coordinate_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>individual_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isotropic_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies and transforms the features to a column, which can be multiplied with the filter matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFeat</td><td>Type for the features </td></tr>
    <tr><td class="paramname">TOut</td><td>Type for the output features </td></tr>
    <tr><td class="paramname">TReal</td><td>Type for point positions and extents </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type for neighbor indexing</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>Output array with shape [num_out, spatial filter dims, in_channels].</td></tr>
    <tr><td class="paramname">in_channels</td><td>Number of input channels.</td></tr>
    <tr><td class="paramname">begin_idx</td><td>Index of the first output point to process.</td></tr>
    <tr><td class="paramname">end_idx</td><td>Index after the last output point to process.</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">out_positions</td><td>The positions of the output points. The shape is [num_out, 3].</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_positions</td><td>The positions of the input points. The shape is [num_inp, 3].</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_importance</td><td>Optional importance for each input point with shape [num_inp]. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_index_size</td><td>The size of the neighbors_index array.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">extents</td><td>The spatial extents of the filter in coordinate units. extents can be a scalar or a 1D array of shape [num_out] or a 2D array of shape [num_out,3]. The shape depends on <code>individual_extent</code> and <code>isotropic_extent</code>.</td></tr>
    <tr><td class="paramname">offsets</td><td>A single 3D vector used in the filter coordinate computation. The shape is [3].</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The spatial filter size in voxels. (The filter resolution) with shape [3].</td></tr>
    <tr><td class="paramname">interpolation</td><td>The interpolation mode. Either LINEAR or NEAREST_NEIGHBOR.</td></tr>
    <tr><td class="paramname">coordinate_mapping</td><td>The coordinate mapping function. One of IDENTITY, BALL_TO_CUBE_RADIAL, BALL_TO_CUBE_VOLUME_PRESERVING.</td></tr>
    <tr><td class="paramname">align_corners</td><td>If true then the voxel centers of the outer voxels of the filter array are mapped to the boundary of the filter shape. If false then the boundary of the filter array is mapped to the boundary of the filter shape.</td></tr>
    <tr><td class="paramname">individual_extent</td><td>If true each output point has an individual extent.</td></tr>
    <tr><td class="paramname">isotropic_extent</td><td>If true each then the extent is isotropic for each output point.</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the result is normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a75ac9810dde84859cb4b320724178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a75ac9810dde84859cb4b320724178">&#9670;&nbsp;</a></span>FillColumn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TReal , class TIndex , class TKernelIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::FillColumn </td>
          <td>(</td>
          <td class="paramtype">const cudaStream_t &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TReal *&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>begin_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>end_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_kernel_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies and transforms the features to a column, which can be multiplied with the filter matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TReal</td><td>Type for positions and features. </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type for addressing neighbors. </td></tr>
    <tr><td class="paramname">TKernelIndex</td><td>Type for addressing the spatial dimension in a kernel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>Output array with shape [num_out, spatial filter dims, in_channels].</td></tr>
    <tr><td class="paramname">in_channels</td><td>Number of input channels.</td></tr>
    <tr><td class="paramname">begin_idx</td><td>Index of the first output point to process.</td></tr>
    <tr><td class="paramname">end_idx</td><td>Index after the last output point to process.</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_importance</td><td>Optional importance for each input point with shape [num_inp]. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_index_size</td><td>The size of the neighbors_index array.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_kernel_index</td><td>Defines which kernel element to use for each neighbor. This array has the same length as <code>neighbors_index</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">num_kernel_elements</td><td>The number of kernel elements. This is the size of the first dimension of the filter, i.e., The filter shape is [num_kernel_elements, in_channels, out_channels]</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the result is normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a915147ba8aa5ab252a532fa9823c9adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915147ba8aa5ab252a532fa9823c9adb">&#9670;&nbsp;</a></span>FillColumnTranspose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TReal , class TIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::FillColumnTranspose </td>
          <td>(</td>
          <td class="paramtype">const cudaStream_t &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFeat *&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>begin_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>end_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>out_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_neighbors_prefix_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a1cdea72ec606986b7ada2e619ea41a8d">InterpolationMode</a>&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#ad39d07a9288168e9ecab8f34e24d27fb">CoordinateMapping</a>&#160;</td>
          <td class="paramname"><em>coordinate_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>individual_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isotropic_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a442200f9fa014ac0b6c63b3368c33d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442200f9fa014ac0b6c63b3368c33d64">&#9670;&nbsp;</a></span>FillColumnTranspose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TReal , class TIndex , class TKernelIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::FillColumnTranspose </td>
          <td>(</td>
          <td class="paramtype">const cudaStream_t &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TReal *&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>begin_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>end_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const __restrict__&#160;</td>
          <td class="paramname"><em>inp_neighbors_prefix_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const __restrict__&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_kernel_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar as FillColumn but used in the transpose convolution to create the patch matrix. </p>

</div>
</div>
<a id="a75f6650b9dad6e80fb75b2cc483c00da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f6650b9dad6e80fb75b2cc483c00da">&#9670;&nbsp;</a></span>InvertNeighborsListCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TAttr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::InvertNeighborsListCPU </td>
          <td>(</td>
          <td class="paramtype">const TIndex *const&#160;</td>
          <td class="paramname"><em>inp_neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TAttr *const&#160;</td>
          <td class="paramname"><em>inp_neighbors_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_attributes_per_neighbor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>inp_num_queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex *&#160;</td>
          <td class="paramname"><em>out_neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAttr *&#160;</td>
          <td class="paramname"><em>out_neighbors_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>out_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>out_num_queries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverts a neighbors list, which is a tuple of the form (neighbors_index, neighbors_row_splits, neighbors_attributes). neighbors_index is a nested list of indices to the neighbors. Each entry defines an edge between two indices (points). The neighbors_row_splits defines the start and end of each sublist. neighbors_attributes is an optional array of attributes for each entry in neighbors_index.</p>
<p>Example: The neighbors for point cloud A (3 points) in point cloud B (2 points) is defined by:</p><ul>
<li>neighbors_index [0 1 0 0]</li>
<li>neighbors_row_splits [0 2 3 4]</li>
<li>optional neighbors_attributes [0.1 0.2 0.3 0.4] (1 scalar attribute)</li>
</ul>
<p>The inverted neighbors list is then the neighbors for point cloud B in A</p><ul>
<li>neighbors_index [0 1 2 0]</li>
<li>neighbors_row_splits [0 3 4]</li>
<li>optional neighbors_attributes [0.1 0.3 0.4 0.2]</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inp_neighbors_index</td><td>The nested list of neighbor indices.</td></tr>
    <tr><td class="paramname">inp_neighbors_attributes</td><td>The array of attributes for each entry in <code>inp_neighbors_index</code>. This is optional and can be set to null.</td></tr>
    <tr><td class="paramname">num_attributes_per_neighbor</td><td>The number of scalar attributes for each entry in <code>inp_neighbors_index</code>.</td></tr>
    <tr><td class="paramname">inp_neighbors_row_splits</td><td>Defines the start and end of the sublists in <code>inp_neighbors_index</code>. This is an exclusive prefix sum with 0 as the first element and the length of <code>inp_neighbors_index</code> as last element. The size is <code>inp_num_queries</code> + 1</td></tr>
    <tr><td class="paramname">inp_num_queries</td><td>The number of queries.</td></tr>
    <tr><td class="paramname">out_neighbors_index</td><td>The inverted neighbors_index list with the same size as <code>inp_neighbors_index</code> .</td></tr>
    <tr><td class="paramname">out_neighbors_attributes</td><td>The inverted array of attributes with the same size as <code>inp_neighbors_attributes</code> .</td></tr>
    <tr><td class="paramname">index_size</td><td>This is the size of <code>inp_neighbors_index</code> and <code>out_neighbors_index</code>, both have the same size.</td></tr>
    <tr><td class="paramname">out_neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>out_neighbors_index</code>.</td></tr>
    <tr><td class="paramname">out_num_queries</td><td>The number of queries with respect to the inverted neighbors list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dfff6f757e20d8bb7a1d4d91ef51a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfff6f757e20d8bb7a1d4d91ef51a6e">&#9670;&nbsp;</a></span>MapCylinderToCube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int VECSIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::MapCylinderToCube </td>
          <td>(</td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps coordinates in a cylinder with radius 1 to a cube. The input and output range of the coordinates is [-1,1]. The cylinder axis is along z. </p>

</div>
</div>
<a id="a8396125aae3812d1757ef005bc4c3ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8396125aae3812d1757ef005bc4c3ce4">&#9670;&nbsp;</a></span>MapSphereToCylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int VECSIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::MapSphereToCylinder </td>
          <td>(</td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, <a class="el" href="_fixed_radius_search_impl_8h.html#a36a1e768e2eb11edcae1d9081eb07394">VECSIZE</a>, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps coordinates in a sphere with radius 1 to a cylinder. The input and output range of the coordinates is [-1,1]. The cylinder axis is along z. </p>

</div>
</div>
<a id="a5ada2e0303fe9ea6733181c936dd67a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ada2e0303fe9ea6733181c936dd67a3">&#9670;&nbsp;</a></span>MultiplyAndCopyColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::MultiplyAndCopyColumns </td>
          <td>(</td>
          <td class="paramtype">const cudaStream_t &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *__restrict__&#160;</td>
          <td class="paramname"><em>out_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const __restrict__&#160;</td>
          <td class="paramname"><em>col_major_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const __restrict__&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies each column with a scalar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_ptr</td><td>Output pointer</td></tr>
    <tr><td class="paramname">col_major_matrix</td><td>Matrix with shape [rows, cols] in column major storage order.</td></tr>
    <tr><td class="paramname">vector</td><td>A vector with shape [cols]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab33c97667e644fa067e338616c765d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33c97667e644fa067e338616c765d98">&#9670;&nbsp;</a></span>MultiplyColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::MultiplyColumns </td>
          <td>(</td>
          <td class="paramtype">const cudaStream_t &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *__restrict__&#160;</td>
          <td class="paramname"><em>col_major_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const __restrict__&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies each column with a scalar in-place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_major_matrix</td><td>Matrix with shape [rows, cols] in column major storage order.</td></tr>
    <tr><td class="paramname">vector</td><td>A vector with shape [cols]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24166fa5df1261dd6b3770ca65e4d907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24166fa5df1261dd6b3770ca65e4d907">&#9670;&nbsp;</a></span>RaggedToDenseCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::RaggedToDenseCPU </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const&#160;</td>
          <td class="paramname"><em>row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row_splits_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>out_col_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>default_value_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a dense tensor from a ragged tensor.</p>
<p>Example where each value has size 2: values = [[0,0],[1,1],[2,2],[3,3],[4,4]] row_splits = [0,2,5] out_col_size=3 default_value=[-1,-1] default_value_size = 2</p>
<p>will return</p>
<p>out_values = [[[0,0],[1,1],[-1,-1]], [[2,2],[3,3],[4,4]]]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Linear memory with all values.</td></tr>
    <tr><td class="paramname">row_splits</td><td>Defines the start and end of each entry in the ragged tensor. This is an exclusive prefix sum with 0 as the first element and the length of all values as the last element.</td></tr>
    <tr><td class="paramname">row_splits_size</td><td>The length of the row_splits vector.</td></tr>
    <tr><td class="paramname">out_col_size</td><td>The output column size. This is the second dim of the dense output tensor.</td></tr>
    <tr><td class="paramname">default_value</td><td>The default value to use if there are not enough values for filling the row.</td></tr>
    <tr><td class="paramname">default_value_size</td><td>The size of the default value.</td></tr>
    <tr><td class="paramname">out_values</td><td>This is the output array. The size of the array must be [row_splits_size-1, out_col_size, default_value_size]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1434b97a6fab04dad1874e85414bd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1434b97a6fab04dad1874e85414bd0a">&#9670;&nbsp;</a></span>ReduceSubarraysSumCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::ReduceSubarraysSumCPU </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>values_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const&#160;</td>
          <td class="paramname"><em>row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out_sums</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduces subarrays in linear memory with the sum operation. The sum for empty subarrays is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The linear array with all values </td></tr>
    <tr><td class="paramname">values_size</td><td>Number of elements of <code>values</code> </td></tr>
    <tr><td class="paramname">row_splits</td><td>Defines the start and end of each subarray. This is an exclusive prefix sum with 0 as the first element and the length of <code>values</code> as last element. The size is <code>num_arrays</code> + 1 </td></tr>
    <tr><td class="paramname">num_arrays</td><td>The number of subarrays </td></tr>
    <tr><td class="paramname">out_sums</td><td>The preallocated output array with size <code>num_arrays</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0b31d4e95c88cba83800bec19cf79a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b31d4e95c88cba83800bec19cf79a1">&#9670;&nbsp;</a></span>SparseConvBackpropFilterCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::SparseConvBackpropFilterCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>filter_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_features_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the backprop for the filter of a sparse convolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp</td><td>Pointer to temporary memory. If nullptr then the required size of temporary memory will be written to <code>temp_size</code> and no work is done. This function can make use of more memory and returns the maximum size that can be used in max_temp_size.</td></tr>
    <tr><td class="paramname">temp_size</td><td>The size of the temporary memory in bytes. This is used as an output if temp is nullptr and returns the minimum temp size required.</td></tr>
    <tr><td class="paramname">max_temp_size</td><td>This is used as an output if temp is nullptr and returns the maximum temp size that can be used.</td></tr>
    <tr><td class="paramname">texture_alignment</td><td>The texture alignment in bytes. This is used for allocating segments within the temporary memory.</td></tr>
    <tr><td class="paramname">filter_backrop</td><td>Output array for the computed filter gradient with shape [depth,height,width, inp channels, out channels]</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The sizes of the filter dimensions. The size of filter_dims must be &gt;=3. The order is [num kernel elements, inp channels, out channels].</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_importance</td><td>Optional importance for each input point with shape [num_inp]. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_kernel_index</td><td>Defines which kernel element to use for each neighbor. This array has the same length as <code>neighbors_index</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">out_features_gradient</td><td>The gradient signal from the features.</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the output features are normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec33cbd0177d9b1c1fb9801fe45cbae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec33cbd0177d9b1c1fb9801fe45cbae5">&#9670;&nbsp;</a></span>SparseConvComputeFeaturesCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::SparseConvComputeFeaturesCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>out_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neighbors_index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the output features of a sparse convolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_features</td><td>Output array for the computed features with shape [num_out, out channels]</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The sizes of the filter dimensions. The size of filter_dims must be &gt;=3. The order is [num kernel elements, inp channels, out channels].</td></tr>
    <tr><td class="paramname">filter</td><td>Pointer to the filter values.</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_importance</td><td>Optional importance for each input point with shape [num_inp]. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_index_size</td><td>The size of the neighbors_index array.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_kernel_index</td><td>Defines which kernel element to use for each neighbor. This array has the same length as <code>neighbors_index</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Array of the same length as <code>neighbors_importance</code>. Defines which of the kernel elements to use in the matrix multiplication.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the result is normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcbe76e2c7acddc61703e43e41cd9049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbe76e2c7acddc61703e43e41cd9049">&#9670;&nbsp;</a></span>SparseConvTransposeBackpropFilterCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::SparseConvTransposeBackpropFilterCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>filter_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbors_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbors_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_features_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the backprop for the filter of a transpose sparse convolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_backrop</td><td>Output array for the computed filter gradient with shape [depth,height,width, inp channels, out channels]</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The sizes of the filter dimensions. The size of filter_dims must be &gt;=3. The order is [num kernel elements, inp channels, out channels].</td></tr>
    <tr><td class="paramname">filter</td><td>Pointer to the filter values.</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">out_importance</td><td>Optional importance for each output point with shape [num_out]. Set to null to disable.</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_neighbors_importance_sum</td><td>The sum of the neighbors_importance values for each input with shape [num_inp].</td></tr>
    <tr><td class="paramname">inp_neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>inp_neighbors_index</code>. The size of the array is <code>num_inp</code> + 1.</td></tr>
    <tr><td class="paramname">neighbors_index_size</td><td>The size of the neighbors_index array.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_kernel_index</td><td>Defines which kernel element to use for each neighbor. This array has the same length as <code>neighbors_index</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">out_features_gradient</td><td>The gradient from the features with shape [num_out, out_channels]</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the result is normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc02e95ef89abfaf320cff95550d003b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc02e95ef89abfaf320cff95550d003b">&#9670;&nbsp;</a></span>SparseConvTransposeComputeFeaturesCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TFeat , class TOut , class TIndex , class TKernelIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::SparseConvTransposeComputeFeaturesCPU </td>
          <td>(</td>
          <td class="paramtype">TOut *&#160;</td>
          <td class="paramname"><em>out_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>out_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_neighbors_importance_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inp_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex *&#160;</td>
          <td class="paramname"><em>neighbor_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TKernelIndex *&#160;</td>
          <td class="paramname"><em>neighbors_kernel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>neighbor_importance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the output features of a transpose sparse convolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_features</td><td>Output array for the computed features with shape [num_out, out channels]</td></tr>
    <tr><td class="paramname">filter_dims</td><td>The sizes of the filter dimensions. The size of filter_dims must be &gt;=3. The order is [num kernel elements, inp channels, out channels].</td></tr>
    <tr><td class="paramname">filter</td><td>Pointer to the filter values.</td></tr>
    <tr><td class="paramname">num_out</td><td>The number of output points.</td></tr>
    <tr><td class="paramname">out_importance</td><td>Optional importance for each output point with shape [num_out]. Set to null to disable.</td></tr>
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_features</td><td>The input features with shape [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">inp_neighbors_importance_sum</td><td>The sum of the neighbors_importance values for each input with shape [num_inp].</td></tr>
    <tr><td class="paramname">inp_neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>inp_neighbors_index</code>. The size of the array is <code>num_inp</code> + 1.</td></tr>
    <tr><td class="paramname">neighbors_index</td><td>The array with lists of neighbors for each output point. The start and end of each sublist is defined by <code>neighbors_row_splits</code>.</td></tr>
    <tr><td class="paramname">neighbors_kernel_index</td><td>Defines which kernel element to use for each neighbor. This array has the same length as <code>neighbors_index</code>.</td></tr>
    <tr><td class="paramname">neighbors_importance</td><td>Optional importance for each entry in <code>neighbors_index</code>. Set to null to disable.</td></tr>
    <tr><td class="paramname">neighbors_row_splits</td><td>The prefix sum which defines the start and end of the sublists in <code>neighbors_index</code>. The size of the array is <code>num_out</code> + 1.</td></tr>
    <tr><td class="paramname">normalize</td><td>If true then the result is normalized either by the number of points (neighbors_importance is null) or by the sum of the respective values in neighbors_importance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf17e3006f30d62c6d5d7826525d7e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf17e3006f30d62c6d5d7826525d7e57">&#9670;&nbsp;</a></span>SpatialHash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ml_2impl_2misc_2_neighbor_search_common_8h.5#a9e64b37aa76347c9bf88985c9dec78c9">HOST_DEVICE</a> size_t open3d::ml::impl::SpatialHash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopen3d_1_1utility_1_1_mini_vec.451.del">utility::MiniVec</a>&lt; int, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ba7048a0c2c5e75582268d5c6379b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba7048a0c2c5e75582268d5c6379b17">&#9670;&nbsp;</a></span>SpatialHash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ml_2impl_2misc_2_neighbor_search_common_8h.5#a9e64b37aa76347c9bf88985c9dec78c9">HOST_DEVICE</a> size_t open3d::ml::impl::SpatialHash </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spatial hashing function for integer coordinates. </p>

</div>
</div>
<a id="aa67e52bbf53aa080b09bc8655ab2979f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67e52bbf53aa080b09bc8655ab2979f">&#9670;&nbsp;</a></span>VoxelizeCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NDIM, class OUTPUT_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::VoxelizeCPU </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const&#160;</td>
          <td class="paramname"><em>row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>points_range_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>points_range_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>max_points_per_voxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>max_voxels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUTPUT_ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>output_allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function voxelizes a point cloud. The function returns the integer coordinates of the voxels that contain points and a compact list of the indices that associate the voxels to the points.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating-point data type for the point positions.</td></tr>
    <tr><td class="paramname">NDIM</td><td>The number of dimensions of the points.</td></tr>
    <tr><td class="paramname">OUTPUT_ALLOCATOR</td><td>Type of the output_allocator. See <code>output_allocator</code> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of points.</td></tr>
    <tr><td class="paramname">points</td><td>Array with the point positions. The shape is [num_points,NDIM].</td></tr>
    <tr><td class="paramname">batch_size</td><td>The batch size of points.</td></tr>
    <tr><td class="paramname">row_splits</td><td>row_splits for defining batches.</td></tr>
    <tr><td class="paramname">voxel_size</td><td>The edge lengths of the voxel. The shape is [NDIM]. This pointer points to host memory!</td></tr>
    <tr><td class="paramname">points_range_min</td><td>The lower bound of the domain to be voxelized. The shape is [NDIM]. This pointer points to host memory!</td></tr>
    <tr><td class="paramname">points_range_max</td><td>The upper bound of the domain to be voxelized. The shape is [NDIM]. This pointer points to host memory!</td></tr>
    <tr><td class="paramname">max_points_per_voxel</td><td>This parameter limits the number of points that are recorderd for each voxel.</td></tr>
    <tr><td class="paramname">max_voxels</td><td>This parameter limits the number of voxels that will be generated.</td></tr>
    <tr><td class="paramname">output_allocator</td><td>An object that implements functions for allocating the output arrays. The object must implement functions AllocVoxelCoords(int32_t** ptr, int64_t rows, int64_t cols), AllocVoxelPointIndices(int64_t** ptr, int64_t size), AllocVoxelPointRowSplits(int64_t** ptr, int64_t size) and AllocVoxelBatchSplits(int64_t** ptr, int64_t size). All functions should allocate memory and return a pointer to that memory in ptr. The arguments size, rows, and cols define the size of the array as the number of elements. All functions must accept zero size arguments. In this case ptr does not need to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62e7e987171a6b5072f2fbb204aaafc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e7e987171a6b5072f2fbb204aaafc6">&#9670;&nbsp;</a></span>VoxelPooling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TReal , class TFeat , class OUTPUT_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::VoxelPooling </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TReal&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUTPUT_ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>output_allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a>&#160;</td>
          <td class="paramname"><em>position_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a>&#160;</td>
          <td class="paramname"><em>feature_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pooling operation for point clouds. Aggregates points that are inside the same voxel.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TReal</td><td>Scalar type for point positions.</td></tr>
    <tr><td class="paramname">TFeat</td><td>Scalar type for the features.</td></tr>
    <tr><td class="paramname">OUTPUT_ALLOCATOR</td><td>Type of the output_allocator. See <code>output_allocator</code> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_inp</td><td>The number of input points.</td></tr>
    <tr><td class="paramname">inp_positions</td><td>Array with 3D point positions.</td></tr>
    <tr><td class="paramname">in_channels</td><td>The number of input feature channels.</td></tr>
    <tr><td class="paramname">inp_features</td><td>The array with the point features. The shape is [num_inp, in_channels].</td></tr>
    <tr><td class="paramname">voxel_size</td><td>The voxel size (voxel edge length) used for pooling.</td></tr>
    <tr><td class="paramname">output_allocator</td><td>An object that implements functions for allocating the output arrays. The object must implement functions AllocPooledPositions(TReal** ptr, size_t num) and AllocPooledFeatures(TFeat** ptr, size_t num, channels), with 'num' as the number of output points and 'channels' as <code>in_channels</code> . Both functions should allocate memory and return a pointer to that memory in ptr. Both functions must accept the argument num==0. In this case ptr does not need to be set. Note that AllocPooledPositions must allocate memory for num*3*sizeof(TReal) bytes.</td></tr>
    <tr><td class="paramname">position_fn</td><td>Defines how the new point positions will be computed. AVERAGE computes the center of gravity for the points within one voxel. NEAREST_NEIGHBOR selects the point closest to the voxel center. CENTER uses the voxel center for the position of the generated point.</td></tr>
    <tr><td class="paramname">feature_fn</td><td>Defines how the new features will be computed. AVERAGE computes the average feature vector. NEAREST_NEIGHBOR selects the feature vector of the point closest to the voxel center. MAX uses the maximum feature among all points within the voxel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d745469c230104929e05255ef40c811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d745469c230104929e05255ef40c811">&#9670;&nbsp;</a></span>VoxelPoolingBackprop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TReal , class TFeat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::ml::impl::VoxelPoolingBackprop </td>
          <td>(</td>
          <td class="paramtype">TFeat *&#160;</td>
          <td class="paramname"><em>features_backprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const&#160;</td>
          <td class="paramname"><em>inp_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const&#160;</td>
          <td class="paramname"><em>inp_features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_pooled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TReal *const&#160;</td>
          <td class="paramname"><em>pooled_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFeat *const&#160;</td>
          <td class="paramname"><em>pooled_features_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TReal&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a>&#160;</td>
          <td class="paramname"><em>position_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopen3d_1_1ml_1_1impl.html#a2902d456779f799905d50574750e1f62">AccumulationFn</a>&#160;</td>
          <td class="paramname"><em>feature_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backpropagation to the features for VoxelPooling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">features_backprop</td><td>The output array with the gradients for the features.</td></tr>
    <tr><td class="paramname">num_pooled</td><td>The number of points after pooling with <code>VoxelPooling</code>.</td></tr>
    <tr><td class="paramname">pooled_positions</td><td>Array with the 3D positions after pooling.</td></tr>
    <tr><td class="paramname">pooled_features_gradient</td><td>Array with the point features after pooling.</td></tr>
  </table>
  </dd>
</dl>
<p>See <code>VoxelPooling</code> for the description of the remaining parameters. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/namespaceopen3d_1_1ml_1_1impl.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:56:26 GMT -->
</html>
