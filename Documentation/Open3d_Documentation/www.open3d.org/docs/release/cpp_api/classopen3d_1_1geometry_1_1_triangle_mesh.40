<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/classopen3d_1_1geometry_1_1_triangle_mesh.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:55:57 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open3D (C++ API): open3d::geometry::TriangleMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.html", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="../../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3TQPKGV6Z3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-3TQPKGV6Z3');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="open3d_logo.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open3D (C++ API)
   &#160;<span id="projectnumber">0.17.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.html','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopen3d.html">open3d</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">open3d::geometry::TriangleMesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Triangle mesh contains vertices and triangles represented by the indices to the vertices.  
 <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="geometry_2_triangle_mesh_8h_source.50f.delay">TriangleMesh.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for open3d::geometry::TriangleMesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classopen3d_1_1geometry_1_1_triangle_mesh.61" usemap="#open3d::geometry::TriangleMesh_map" alt=""/>
  <map id="open3d::geometry::TriangleMesh_map" name="open3d::geometry::TriangleMesh_map">
<area href="classopen3d_1_1geometry_1_1_mesh_base.412.de" title="MeshBash Class." alt="open3d::geometry::MeshBase" shape="rect" coords="0,112,195,136"/>
<area href="classopen3d_1_1geometry_1_1_geometry3_d.402" title="The base geometry class for 3D geometries." alt="open3d::geometry::Geometry3D" shape="rect" coords="0,56,195,80"/>
<area href="classopen3d_1_1geometry_1_1_geometry.400.del" title="The base geometry class." alt="open3d::geometry::Geometry" shape="rect" coords="0,0,195,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopen3d_1_1geometry_1_1_triangle_mesh_1">Material</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2d8c6f82481d56ba06e849991261924"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ae2d8c6f82481d56ba06e849991261924">TriangleMesh</a> ()</td></tr>
<tr class="memdesc:ae2d8c6f82481d56ba06e849991261924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ae2d8c6f82481d56ba06e849991261924">More...</a><br /></td></tr>
<tr class="separator:ae2d8c6f82481d56ba06e849991261924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f5666200f972bed5b78dd3b0e1f9ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ad1f5666200f972bed5b78dd3b0e1f9ec">TriangleMesh</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;vertices, const std::vector&lt; Eigen::Vector3i &gt; &amp;triangles)</td></tr>
<tr class="memdesc:ad1f5666200f972bed5b78dd3b0e1f9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized Constructor.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ad1f5666200f972bed5b78dd3b0e1f9ec">More...</a><br /></td></tr>
<tr class="separator:ad1f5666200f972bed5b78dd3b0e1f9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7046aa1902fbc4e5688109930402ca5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7046aa1902fbc4e5688109930402ca5d">~TriangleMesh</a> () override</td></tr>
<tr class="separator:a7046aa1902fbc4e5688109930402ca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea92820de31c1fcbf62e5c6d9516540"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4ea92820de31c1fcbf62e5c6d9516540">Clear</a> () override</td></tr>
<tr class="memdesc:a4ea92820de31c1fcbf62e5c6d9516540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all elements in the geometry.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4ea92820de31c1fcbf62e5c6d9516540">More...</a><br /></td></tr>
<tr class="separator:a4ea92820de31c1fcbf62e5c6d9516540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a6954168e7b35c70cdcd0f98086783"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a76a6954168e7b35c70cdcd0f98086783">Transform</a> (const Eigen::Matrix4d &amp;transformation) override</td></tr>
<tr class="memdesc:a76a6954168e7b35c70cdcd0f98086783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation (4x4 matrix) to the geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a76a6954168e7b35c70cdcd0f98086783">More...</a><br /></td></tr>
<tr class="separator:a76a6954168e7b35c70cdcd0f98086783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039c1d00b33423cb5371d6ba157557a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a039c1d00b33423cb5371d6ba157557a1">Rotate</a> (const Eigen::Matrix3d &amp;R, const Eigen::Vector3d &amp;center) override</td></tr>
<tr class="memdesc:a039c1d00b33423cb5371d6ba157557a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rotation to the geometry coordinates and normals. Given a rotation matrix \(R\), and center \(c\), a given point \(p\) is transformed according to \(R (p - c) + c\).  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a039c1d00b33423cb5371d6ba157557a1">More...</a><br /></td></tr>
<tr class="separator:a039c1d00b33423cb5371d6ba157557a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb4bc21a1a623c719892967d996e314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a1eb4bc21a1a623c719892967d996e314">operator+=</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;mesh)</td></tr>
<tr class="separator:a1eb4bc21a1a623c719892967d996e314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24042df732dd8cd2b8272c7302a1154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ae24042df732dd8cd2b8272c7302a1154">operator+</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;mesh) const</td></tr>
<tr class="separator:ae24042df732dd8cd2b8272c7302a1154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f81b23e6538ab3d984824e93fb6e8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a46f81b23e6538ab3d984824e93fb6e8c">HasTriangles</a> () const</td></tr>
<tr class="memdesc:a46f81b23e6538ab3d984824e93fb6e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the mesh contains triangles.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a46f81b23e6538ab3d984824e93fb6e8c">More...</a><br /></td></tr>
<tr class="separator:a46f81b23e6538ab3d984824e93fb6e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b745727a70875ba9bd3e8b706c131d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ab6b745727a70875ba9bd3e8b706c131d">HasTriangleNormals</a> () const</td></tr>
<tr class="memdesc:ab6b745727a70875ba9bd3e8b706c131d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the mesh contains triangle normals.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ab6b745727a70875ba9bd3e8b706c131d">More...</a><br /></td></tr>
<tr class="separator:ab6b745727a70875ba9bd3e8b706c131d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5109ef64ef2e20467e1560935e8ccfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ac5109ef64ef2e20467e1560935e8ccfb">HasAdjacencyList</a> () const</td></tr>
<tr class="memdesc:ac5109ef64ef2e20467e1560935e8ccfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the mesh contains adjacency normals.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ac5109ef64ef2e20467e1560935e8ccfb">More...</a><br /></td></tr>
<tr class="separator:ac5109ef64ef2e20467e1560935e8ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d50d05a4904038823231aa8252c4d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a84d50d05a4904038823231aa8252c4d2">HasTriangleUvs</a> () const</td></tr>
<tr class="separator:a84d50d05a4904038823231aa8252c4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec00b3beae972048fa4a3e1f711b548"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7ec00b3beae972048fa4a3e1f711b548">HasTextures</a> () const</td></tr>
<tr class="memdesc:a7ec00b3beae972048fa4a3e1f711b548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the mesh has texture.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7ec00b3beae972048fa4a3e1f711b548">More...</a><br /></td></tr>
<tr class="separator:a7ec00b3beae972048fa4a3e1f711b548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc871b155b0282561652ab8db5ac5cc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#afc871b155b0282561652ab8db5ac5cc0">HasMaterials</a> () const</td></tr>
<tr class="separator:afc871b155b0282561652ab8db5ac5cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66abc01744c37d5eeefe0d7b6d3d8c8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a66abc01744c37d5eeefe0d7b6d3d8c8e">HasTriangleMaterialIds</a> () const</td></tr>
<tr class="separator:a66abc01744c37d5eeefe0d7b6d3d8c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac701002ed8fbbf5ec30c261338794501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ac701002ed8fbbf5ec30c261338794501">NormalizeNormals</a> ()</td></tr>
<tr class="memdesc:ac701002ed8fbbf5ec30c261338794501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize both triangle normals and vertex normals to length 1.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ac701002ed8fbbf5ec30c261338794501">More...</a><br /></td></tr>
<tr class="separator:ac701002ed8fbbf5ec30c261338794501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af324cfbefa0bed22b0325a2a34bf6069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af324cfbefa0bed22b0325a2a34bf6069">ComputeTriangleNormals</a> (bool normalized=true)</td></tr>
<tr class="memdesc:af324cfbefa0bed22b0325a2a34bf6069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute triangle normals, usually called before rendering.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af324cfbefa0bed22b0325a2a34bf6069">More...</a><br /></td></tr>
<tr class="separator:af324cfbefa0bed22b0325a2a34bf6069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b31309a8d8c1f94a7ff0434a884f0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4b31309a8d8c1f94a7ff0434a884f0eb">ComputeVertexNormals</a> (bool normalized=true)</td></tr>
<tr class="memdesc:a4b31309a8d8c1f94a7ff0434a884f0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute vertex normals, usually called before rendering.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4b31309a8d8c1f94a7ff0434a884f0eb">More...</a><br /></td></tr>
<tr class="separator:a4b31309a8d8c1f94a7ff0434a884f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0f8d836ee1eea6ecc540c43bc1e9d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#acf0f8d836ee1eea6ecc540c43bc1e9d1">ComputeAdjacencyList</a> ()</td></tr>
<tr class="memdesc:acf0f8d836ee1eea6ecc540c43bc1e9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute adjacency list, call before adjacency list is needed.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#acf0f8d836ee1eea6ecc540c43bc1e9d1">More...</a><br /></td></tr>
<tr class="separator:acf0f8d836ee1eea6ecc540c43bc1e9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f090ed23456400c4192992d199bdad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a34f090ed23456400c4192992d199bdad">RemoveDuplicatedVertices</a> ()</td></tr>
<tr class="memdesc:a34f090ed23456400c4192992d199bdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that removes duplicated verties, i.e., vertices that have identical coordinates.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a34f090ed23456400c4192992d199bdad">More...</a><br /></td></tr>
<tr class="separator:a34f090ed23456400c4192992d199bdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9514b3c8075e0066fd041a853f23f0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a9514b3c8075e0066fd041a853f23f0b7">RemoveDuplicatedTriangles</a> ()</td></tr>
<tr class="memdesc:a9514b3c8075e0066fd041a853f23f0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that removes duplicated triangles, i.e., removes triangles that reference the same three vertices and have the same orientation.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a9514b3c8075e0066fd041a853f23f0b7">More...</a><br /></td></tr>
<tr class="separator:a9514b3c8075e0066fd041a853f23f0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1782c3de14f8553de0a946b8900bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aab1782c3de14f8553de0a946b8900bce">RemoveUnreferencedVertices</a> ()</td></tr>
<tr class="memdesc:aab1782c3de14f8553de0a946b8900bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes vertices from the triangle mesh that are not referenced in any triangle of the mesh.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aab1782c3de14f8553de0a946b8900bce">More...</a><br /></td></tr>
<tr class="separator:aab1782c3de14f8553de0a946b8900bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49a80312d128fbfa70eeb8525cc24ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aa49a80312d128fbfa70eeb8525cc24ec">RemoveDegenerateTriangles</a> ()</td></tr>
<tr class="memdesc:aa49a80312d128fbfa70eeb8525cc24ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that removes degenerate triangles, i.e., triangles that reference a single vertex multiple times in a single triangle.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aa49a80312d128fbfa70eeb8525cc24ec">More...</a><br /></td></tr>
<tr class="separator:aa49a80312d128fbfa70eeb8525cc24ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a667e04a73010d302eb60af0ea1cbf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a0a667e04a73010d302eb60af0ea1cbf9">RemoveNonManifoldEdges</a> ()</td></tr>
<tr class="memdesc:a0a667e04a73010d302eb60af0ea1cbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that removes all non-manifold edges, by successively deleting triangles with the smallest surface area adjacent to the non-manifold edge until the number of adjacent triangles to the edge is <code>&lt;= 2</code>.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a0a667e04a73010d302eb60af0ea1cbf9">More...</a><br /></td></tr>
<tr class="separator:a0a667e04a73010d302eb60af0ea1cbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a42d9e899de697300c602bc8ad9251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a51a42d9e899de697300c602bc8ad9251">MergeCloseVertices</a> (double eps)</td></tr>
<tr class="memdesc:a51a42d9e899de697300c602bc8ad9251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that will merge close by vertices to a single one. The vertex position, normal and color will be the average of the vertices.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a51a42d9e899de697300c602bc8ad9251">More...</a><br /></td></tr>
<tr class="separator:a51a42d9e899de697300c602bc8ad9251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add35eb810d82fe03e39dfb3984ccdc96"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#add35eb810d82fe03e39dfb3984ccdc96">FilterSharpen</a> (int number_of_iterations, double strength, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a> scope=<a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">FilterScope::All</a>) const</td></tr>
<tr class="memdesc:add35eb810d82fe03e39dfb3984ccdc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to sharpen triangle mesh.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#add35eb810d82fe03e39dfb3984ccdc96">More...</a><br /></td></tr>
<tr class="separator:add35eb810d82fe03e39dfb3984ccdc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15d30fa98b93c2ebc365380e3b3ebe8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ae15d30fa98b93c2ebc365380e3b3ebe8">FilterSmoothSimple</a> (int number_of_iterations, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a> scope=<a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">FilterScope::All</a>) const</td></tr>
<tr class="memdesc:ae15d30fa98b93c2ebc365380e3b3ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to smooth triangle mesh with simple neighbour average.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ae15d30fa98b93c2ebc365380e3b3ebe8">More...</a><br /></td></tr>
<tr class="separator:ae15d30fa98b93c2ebc365380e3b3ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2667927e4b8f4a62a635a1a2f490eb8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af2667927e4b8f4a62a635a1a2f490eb8">FilterSmoothLaplacian</a> (int number_of_iterations, double lambda_filter, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a> scope=<a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">FilterScope::All</a>) const</td></tr>
<tr class="memdesc:af2667927e4b8f4a62a635a1a2f490eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to smooth triangle mesh using Laplacian.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af2667927e4b8f4a62a635a1a2f490eb8">More...</a><br /></td></tr>
<tr class="separator:af2667927e4b8f4a62a635a1a2f490eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ed81f5e181b8342239b3d7c5ec1a90"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a20ed81f5e181b8342239b3d7c5ec1a90">FilterSmoothTaubin</a> (int number_of_iterations, double lambda_filter=0.5, double mu=-0.53, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a> scope=<a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">FilterScope::All</a>) const</td></tr>
<tr class="memdesc:a20ed81f5e181b8342239b3d7c5ec1a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to smooth triangle mesh using method of Taubin, "Curve and Surface Smoothing Without Shrinkage", 1995. Applies in each iteration two times FilterSmoothLaplacian, first with lambda_filter and second with mu as smoothing parameter. This method avoids shrinkage of the triangle mesh.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a20ed81f5e181b8342239b3d7c5ec1a90">More...</a><br /></td></tr>
<tr class="separator:a20ed81f5e181b8342239b3d7c5ec1a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601b6d4b19f75e1677af5d02e881e2f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a601b6d4b19f75e1677af5d02e881e2f3">EulerPoincareCharacteristic</a> () const</td></tr>
<tr class="separator:a601b6d4b19f75e1677af5d02e881e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e78ff8b6358ef24f5285e6bbc863e61"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector2i &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a9e78ff8b6358ef24f5285e6bbc863e61">GetNonManifoldEdges</a> (bool allow_boundary_edges=true) const</td></tr>
<tr class="separator:a9e78ff8b6358ef24f5285e6bbc863e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b5ac2ab386ac85bfe056f0bf22bab9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a41b5ac2ab386ac85bfe056f0bf22bab9">IsEdgeManifold</a> (bool allow_boundary_edges=true) const</td></tr>
<tr class="separator:a41b5ac2ab386ac85bfe056f0bf22bab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af589b9fdfa2885c95a15977dd0874a24"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af589b9fdfa2885c95a15977dd0874a24">GetNonManifoldVertices</a> () const</td></tr>
<tr class="separator:af589b9fdfa2885c95a15977dd0874a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292f2d129637b15598fbbeec0b6b57e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a292f2d129637b15598fbbeec0b6b57e1">IsVertexManifold</a> () const</td></tr>
<tr class="separator:a292f2d129637b15598fbbeec0b6b57e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2895032074c34dd9375e3d3eecc81718"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector2i &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a2895032074c34dd9375e3d3eecc81718">GetSelfIntersectingTriangles</a> () const</td></tr>
<tr class="separator:a2895032074c34dd9375e3d3eecc81718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ee35dd23c4a786be63e3da3f305062"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ae5ee35dd23c4a786be63e3da3f305062">IsSelfIntersecting</a> () const</td></tr>
<tr class="separator:ae5ee35dd23c4a786be63e3da3f305062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597075686ecda8953d33f3cbe57c385"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a0597075686ecda8953d33f3cbe57c385">IsBoundingBoxIntersecting</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;other) const</td></tr>
<tr class="separator:a0597075686ecda8953d33f3cbe57c385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5abd918be627b6397bd8c149a0b0e47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ac5abd918be627b6397bd8c149a0b0e47">IsIntersecting</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;other) const</td></tr>
<tr class="separator:ac5abd918be627b6397bd8c149a0b0e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c336042cff2009101c6611a518abadd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7c336042cff2009101c6611a518abadd">IsOrientable</a> () const</td></tr>
<tr class="separator:a7c336042cff2009101c6611a518abadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf57ddb4e13f2ceb33e6785cc864a46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#abbf57ddb4e13f2ceb33e6785cc864a46">IsWatertight</a> () const</td></tr>
<tr class="separator:abbf57ddb4e13f2ceb33e6785cc864a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804035e82e0a721c23321c63d1697cfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a804035e82e0a721c23321c63d1697cfc">OrientTriangles</a> ()</td></tr>
<tr class="separator:a804035e82e0a721c23321c63d1697cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652be3b74a111590f1f41d1bdad8ec14"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Eigen::Vector2i, std::vector&lt; int &gt;, <a class="el" href="structopen3d_1_1utility_1_1hash__eigen.44c.d">utility::hash_eigen</a>&lt; Eigen::Vector2i &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a652be3b74a111590f1f41d1bdad8ec14">GetEdgeToTrianglesMap</a> () const</td></tr>
<tr class="separator:a652be3b74a111590f1f41d1bdad8ec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade21d10ceaf1299ea18d192f0668dd6f"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Eigen::Vector2i, std::vector&lt; int &gt;, <a class="el" href="structopen3d_1_1utility_1_1hash__eigen.44c.d">utility::hash_eigen</a>&lt; Eigen::Vector2i &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ade21d10ceaf1299ea18d192f0668dd6f">GetEdgeToVerticesMap</a> () const</td></tr>
<tr class="separator:ade21d10ceaf1299ea18d192f0668dd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91258e5fa363de720104f55d86ab793"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ac91258e5fa363de720104f55d86ab793">GetTriangleArea</a> (size_t triangle_idx) const</td></tr>
<tr class="separator:ac91258e5fa363de720104f55d86ab793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e5e2bcce2ae099a91bec61692b191a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af3e5e2bcce2ae099a91bec61692b191a">GetSurfaceArea</a> () const</td></tr>
<tr class="separator:af3e5e2bcce2ae099a91bec61692b191a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5f651b67b968269a7466875a9e69aa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4f5f651b67b968269a7466875a9e69aa">GetSurfaceArea</a> (std::vector&lt; double &gt; &amp;triangle_areas) const</td></tr>
<tr class="separator:a4f5f651b67b968269a7466875a9e69aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a4bfec706044d1c97edd2df30d9e98"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a18a4bfec706044d1c97edd2df30d9e98">GetVolume</a> () const</td></tr>
<tr class="separator:a18a4bfec706044d1c97edd2df30d9e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fdc61d44a6569a0b66afa3f4a10229"><td class="memItemLeft" align="right" valign="top">Eigen::Vector4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ae0fdc61d44a6569a0b66afa3f4a10229">GetTrianglePlane</a> (size_t triangle_idx) const</td></tr>
<tr class="separator:ae0fdc61d44a6569a0b66afa3f4a10229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1568965f2cb441cf6439b7ee57cd2929"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a1568965f2cb441cf6439b7ee57cd2929">SamplePointsUniformlyImpl</a> (size_t number_of_points, std::vector&lt; double &gt; &amp;triangle_areas, double surface_area, bool use_triangle_normal)</td></tr>
<tr class="separator:a1568965f2cb441cf6439b7ee57cd2929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2536a9b85f8060c7468da8378d696057"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a2536a9b85f8060c7468da8378d696057">SamplePointsUniformly</a> (size_t number_of_points, bool use_triangle_normal=false)</td></tr>
<tr class="separator:a2536a9b85f8060c7468da8378d696057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e1b29798f6e04d80de9e2638bf1c96"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a28e1b29798f6e04d80de9e2638bf1c96">SamplePointsPoissonDisk</a> (size_t number_of_points, double init_factor=5, const std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; pcl_init=nullptr, bool use_triangle_normal=false)</td></tr>
<tr class="separator:a28e1b29798f6e04d80de9e2638bf1c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c0abffb559c91c5f4f5d50b8a2c1a4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a10c0abffb559c91c5f4f5d50b8a2c1a4">SubdivideMidpoint</a> (int number_of_iterations) const</td></tr>
<tr class="separator:a10c0abffb559c91c5f4f5d50b8a2c1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c4ef9c1c9229213ecd05a15845d4d4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a19c4ef9c1c9229213ecd05a15845d4d4">SubdivideLoop</a> (int number_of_iterations) const</td></tr>
<tr class="separator:a19c4ef9c1c9229213ecd05a15845d4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd07290669043643698e660d9e670ce"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a5dd07290669043643698e660d9e670ce">SimplifyVertexClustering</a> (double voxel_size, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a84f9db88a4d0d23d755136ddfa7e6bd7">SimplificationContraction</a> contraction=<a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a84f9db88a4d0d23d755136ddfa7e6bd7ab1897515d548a960afe49ecf66a29021">SimplificationContraction::Average</a>) const</td></tr>
<tr class="separator:a5dd07290669043643698e660d9e670ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a96a4bc20b515c111e3e756d7e4d1e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ab2a96a4bc20b515c111e3e756d7e4d1e">SimplifyQuadricDecimation</a> (int target_number_of_triangles, double maximum_error, double boundary_weight) const</td></tr>
<tr class="separator:ab2a96a4bc20b515c111e3e756d7e4d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a0a850d21ec4d0fa297787ae28868c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a64a0a850d21ec4d0fa297787ae28868c">SelectByIndex</a> (const std::vector&lt; size_t &gt; &amp;indices, bool cleanup=true) const</td></tr>
<tr class="separator:a64a0a850d21ec4d0fa297787ae28868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f547f8869c3094427a184c5fa2ac519"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a8f547f8869c3094427a184c5fa2ac519">Crop</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou">AxisAlignedBoundingBox</a> &amp;bbox) const</td></tr>
<tr class="separator:a8f547f8869c3094427a184c5fa2ac519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dcfcf69c0c9ad1cf8e6b1ac70ef525"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a69dcfcf69c0c9ad1cf8e6b1ac70ef525">Crop</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> &amp;bbox) const</td></tr>
<tr class="separator:a69dcfcf69c0c9ad1cf8e6b1ac70ef525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ffe6ee562b74d1d48786c97f55bb0e"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; int &gt;, std::vector&lt; size_t &gt;, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a15ffe6ee562b74d1d48786c97f55bb0e">ClusterConnectedTriangles</a> () const</td></tr>
<tr class="memdesc:a15ffe6ee562b74d1d48786c97f55bb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that clusters connected triangles, i.e., triangles that are connected via edges are assigned the same cluster index.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a15ffe6ee562b74d1d48786c97f55bb0e">More...</a><br /></td></tr>
<tr class="separator:a15ffe6ee562b74d1d48786c97f55bb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c51a951a1ee0110a48b2ef7757b43c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a41c51a951a1ee0110a48b2ef7757b43c">RemoveTrianglesByIndex</a> (const std::vector&lt; size_t &gt; &amp;triangle_indices)</td></tr>
<tr class="memdesc:a41c51a951a1ee0110a48b2ef7757b43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes the triangles with index in <code>triangle_indices</code>. Call <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aab1782c3de14f8553de0a946b8900bce">RemoveUnreferencedVertices</a> to clean up vertices afterwards.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a41c51a951a1ee0110a48b2ef7757b43c">More...</a><br /></td></tr>
<tr class="separator:a41c51a951a1ee0110a48b2ef7757b43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fb06b3e541042a8f9f29e1c0e64de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af88fb06b3e541042a8f9f29e1c0e64de">RemoveTrianglesByMask</a> (const std::vector&lt; bool &gt; &amp;triangle_mask)</td></tr>
<tr class="memdesc:af88fb06b3e541042a8f9f29e1c0e64de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes the triangles that are masked in <code>triangle_mask</code>. Call <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aab1782c3de14f8553de0a946b8900bce">RemoveUnreferencedVertices</a> to clean up vertices afterwards.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af88fb06b3e541042a8f9f29e1c0e64de">More...</a><br /></td></tr>
<tr class="separator:af88fb06b3e541042a8f9f29e1c0e64de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3d0d742b2d0fd200b40b852890f5ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4b3d0d742b2d0fd200b40b852890f5ff">RemoveVerticesByIndex</a> (const std::vector&lt; size_t &gt; &amp;vertex_indices)</td></tr>
<tr class="memdesc:a4b3d0d742b2d0fd200b40b852890f5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes the vertices with index in <code>vertex_indices</code>. Note that also all triangles associated with the vertices are removeds.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4b3d0d742b2d0fd200b40b852890f5ff">More...</a><br /></td></tr>
<tr class="separator:a4b3d0d742b2d0fd200b40b852890f5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685b36e7ec28d4dd6655f5a2e72802ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a685b36e7ec28d4dd6655f5a2e72802ab">RemoveVerticesByMask</a> (const std::vector&lt; bool &gt; &amp;vertex_mask)</td></tr>
<tr class="memdesc:a685b36e7ec28d4dd6655f5a2e72802ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes the vertices that are masked in <code>vertex_mask</code>. Note that also all triangles associated with the vertices are removed.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a685b36e7ec28d4dd6655f5a2e72802ab">More...</a><br /></td></tr>
<tr class="separator:a685b36e7ec28d4dd6655f5a2e72802ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52410a1d4ce4f94955d3a15130d7400"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aa52410a1d4ce4f94955d3a15130d7400">DeformAsRigidAsPossible</a> (const std::vector&lt; int &gt; &amp;constraint_vertex_indices, const std::vector&lt; Eigen::Vector3d &gt; &amp;constraint_vertex_positions, size_t max_iter, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a6f7e206d12e10f059ca530cd04c4d07a">DeformAsRigidAsPossibleEnergy</a> energy=<a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a6f7e206d12e10f059ca530cd04c4d07aa111552792d2df37209e4e9815a8524a8">DeformAsRigidAsPossibleEnergy::Spokes</a>, double smoothed_alpha=0.01) const</td></tr>
<tr class="memdesc:aa52410a1d4ce4f94955d3a15130d7400"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deforms the mesh using the method by Sorkine and Alexa, "As-Rigid-As-Possible Surface Modeling", 2007.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aa52410a1d4ce4f94955d3a15130d7400">More...</a><br /></td></tr>
<tr class="separator:aa52410a1d4ce4f94955d3a15130d7400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classopen3d_1_1geometry_1_1_mesh_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">open3d::geometry::MeshBase</a></td></tr>
<tr class="memitem:a7f0a38e96630f55717dfd3392fe62aa4 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a7f0a38e96630f55717dfd3392fe62aa4">MeshBase</a> ()</td></tr>
<tr class="memdesc:a7f0a38e96630f55717dfd3392fe62aa4 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a7f0a38e96630f55717dfd3392fe62aa4">More...</a><br /></td></tr>
<tr class="separator:a7f0a38e96630f55717dfd3392fe62aa4 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719475a1bc584de3df7deeda89217eb5 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a719475a1bc584de3df7deeda89217eb5">~MeshBase</a> () override</td></tr>
<tr class="separator:a719475a1bc584de3df7deeda89217eb5 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0968a4f71bdbbc116850df571f80272c inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a0968a4f71bdbbc116850df571f80272c">IsEmpty</a> () const override</td></tr>
<tr class="memdesc:a0968a4f71bdbbc116850df571f80272c inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> iff the geometry is empty.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a0968a4f71bdbbc116850df571f80272c">More...</a><br /></td></tr>
<tr class="separator:a0968a4f71bdbbc116850df571f80272c inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c4c2ef12c0a5a4d50d7974cb779d06 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ad6c4c2ef12c0a5a4d50d7974cb779d06">GetMinBound</a> () const override</td></tr>
<tr class="memdesc:ad6c4c2ef12c0a5a4d50d7974cb779d06 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min bounds for geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ad6c4c2ef12c0a5a4d50d7974cb779d06">More...</a><br /></td></tr>
<tr class="separator:ad6c4c2ef12c0a5a4d50d7974cb779d06 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ceff192f28d34b1893bb592c535072 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a36ceff192f28d34b1893bb592c535072">GetMaxBound</a> () const override</td></tr>
<tr class="memdesc:a36ceff192f28d34b1893bb592c535072 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max bounds for geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a36ceff192f28d34b1893bb592c535072">More...</a><br /></td></tr>
<tr class="separator:a36ceff192f28d34b1893bb592c535072 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7af34654077e96288094255aa10de5 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#aca7af34654077e96288094255aa10de5">GetCenter</a> () const override</td></tr>
<tr class="memdesc:aca7af34654077e96288094255aa10de5 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the center of the geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#aca7af34654077e96288094255aa10de5">More...</a><br /></td></tr>
<tr class="separator:aca7af34654077e96288094255aa10de5 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a7bcbb473ab0d382f8a604fe01da47 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou">AxisAlignedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a81a7bcbb473ab0d382f8a604fe01da47">GetAxisAlignedBoundingBox</a> () const override</td></tr>
<tr class="separator:a81a7bcbb473ab0d382f8a604fe01da47 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9583383d79c612d1396750f3ad190a inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#adf9583383d79c612d1396750f3ad190a">GetOrientedBoundingBox</a> (bool robust=false) const override</td></tr>
<tr class="separator:adf9583383d79c612d1396750f3ad190a inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b821b781c20c9d1e2d3fd586763626e inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a3b821b781c20c9d1e2d3fd586763626e">GetMinimalOrientedBoundingBox</a> (bool robust=false) const override</td></tr>
<tr class="separator:a3b821b781c20c9d1e2d3fd586763626e inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa364e4164bb9dfd420732106a0046c3b inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">MeshBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#aa364e4164bb9dfd420732106a0046c3b">Translate</a> (const Eigen::Vector3d &amp;translation, bool relative=true) override</td></tr>
<tr class="memdesc:aa364e4164bb9dfd420732106a0046c3b inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply translation to the geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#aa364e4164bb9dfd420732106a0046c3b">More...</a><br /></td></tr>
<tr class="separator:aa364e4164bb9dfd420732106a0046c3b inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad300c61bbb35ea3b174b04f8eb5fa042 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">MeshBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ad300c61bbb35ea3b174b04f8eb5fa042">Scale</a> (const double scale, const Eigen::Vector3d &amp;center) override</td></tr>
<tr class="memdesc:ad300c61bbb35ea3b174b04f8eb5fa042 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply scaling to the geometry coordinates. Given a scaling factor \(s\), and center \(c\), a given point \(p\) is transformed according to \(s (p - c) + c\).  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ad300c61bbb35ea3b174b04f8eb5fa042">More...</a><br /></td></tr>
<tr class="separator:ad300c61bbb35ea3b174b04f8eb5fa042 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2e94203dc3b39392b9266407e00aac inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">MeshBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a5f2e94203dc3b39392b9266407e00aac">operator+=</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">MeshBase</a> &amp;mesh)</td></tr>
<tr class="separator:a5f2e94203dc3b39392b9266407e00aac inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2c246764d9cf09ccf582435570598a inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">MeshBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ace2c246764d9cf09ccf582435570598a">operator+</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">MeshBase</a> &amp;mesh) const</td></tr>
<tr class="separator:ace2c246764d9cf09ccf582435570598a inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ee6962ded8a7de44d38f4e737fdad0 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ab7ee6962ded8a7de44d38f4e737fdad0">HasVertices</a> () const</td></tr>
<tr class="memdesc:ab7ee6962ded8a7de44d38f4e737fdad0 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>True</code> if the mesh contains vertices.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ab7ee6962ded8a7de44d38f4e737fdad0">More...</a><br /></td></tr>
<tr class="separator:ab7ee6962ded8a7de44d38f4e737fdad0 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e672e8e3eac58844656f81a1154b074 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a3e672e8e3eac58844656f81a1154b074">HasVertexNormals</a> () const</td></tr>
<tr class="memdesc:a3e672e8e3eac58844656f81a1154b074 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>True</code> if the mesh contains vertex normals.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a3e672e8e3eac58844656f81a1154b074">More...</a><br /></td></tr>
<tr class="separator:a3e672e8e3eac58844656f81a1154b074 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77341c2d09a3a5bbab23e92b3df88400 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a77341c2d09a3a5bbab23e92b3df88400">HasVertexColors</a> () const</td></tr>
<tr class="memdesc:a77341c2d09a3a5bbab23e92b3df88400 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>True</code> if the mesh contains vertex colors.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a77341c2d09a3a5bbab23e92b3df88400">More...</a><br /></td></tr>
<tr class="separator:a77341c2d09a3a5bbab23e92b3df88400 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f5f6dc5af988b69c7d9f7ac4294bea inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">MeshBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ab0f5f6dc5af988b69c7d9f7ac4294bea">NormalizeNormals</a> ()</td></tr>
<tr class="memdesc:ab0f5f6dc5af988b69c7d9f7ac4294bea inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize vertex normals to length 1.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ab0f5f6dc5af988b69c7d9f7ac4294bea">More...</a><br /></td></tr>
<tr class="separator:ab0f5f6dc5af988b69c7d9f7ac4294bea inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760c1f0ddd8fb5121309fbf5f439a881 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">MeshBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a760c1f0ddd8fb5121309fbf5f439a881">PaintUniformColor</a> (const Eigen::Vector3d &amp;<a class="el" href="_triangle_mesh_buffers_8cpp.html#aa332976d803be75beb81e81af320bfcb">color</a>)</td></tr>
<tr class="memdesc:a760c1f0ddd8fb5121309fbf5f439a881 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns each vertex in the <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40" title="Triangle mesh contains vertices and triangles represented by the indices to the vertices.">TriangleMesh</a> the same color.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a760c1f0ddd8fb5121309fbf5f439a881">More...</a><br /></td></tr>
<tr class="separator:a760c1f0ddd8fb5121309fbf5f439a881 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a818a84de36ef3b34f46ee1d5204684 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a8a818a84de36ef3b34f46ee1d5204684">ComputeConvexHull</a> () const</td></tr>
<tr class="memdesc:a8a818a84de36ef3b34f46ee1d5204684 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes the convex hull of the triangle mesh using qhull.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a8a818a84de36ef3b34f46ee1d5204684">More...</a><br /></td></tr>
<tr class="separator:a8a818a84de36ef3b34f46ee1d5204684 inherit pub_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classopen3d_1_1geometry_1_1_geometry3_d')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402">open3d::geometry::Geometry3D</a></td></tr>
<tr class="memitem:a3bee61a0da428535d0eb9f62786fcab1 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a3bee61a0da428535d0eb9f62786fcab1">~Geometry3D</a> () override</td></tr>
<tr class="separator:a3bee61a0da428535d0eb9f62786fcab1 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2ab7fb19c0fc8f4ccbc9a776be2e23 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402">Geometry3D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a5c2ab7fb19c0fc8f4ccbc9a776be2e23">Rotate</a> (const Eigen::Matrix3d &amp;R)</td></tr>
<tr class="separator:a5c2ab7fb19c0fc8f4ccbc9a776be2e23 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classopen3d_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classopen3d_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del">open3d::geometry::Geometry</a></td></tr>
<tr class="memitem:a1c2eb5a3e6c0a47cc31e38d086d07c54 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a1c2eb5a3e6c0a47cc31e38d086d07c54">~Geometry</a> ()</td></tr>
<tr class="separator:a1c2eb5a3e6c0a47cc31e38d086d07c54 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194473f920417162aa501bfb7df1d4b9 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">GeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a194473f920417162aa501bfb7df1d4b9">GetGeometryType</a> () const</td></tr>
<tr class="memdesc:a194473f920417162aa501bfb7df1d4b9 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of registered geometry types.  <a href="classopen3d_1_1geometry_1_1_geometry.400.del#a194473f920417162aa501bfb7df1d4b9">More...</a><br /></td></tr>
<tr class="separator:a194473f920417162aa501bfb7df1d4b9 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669ce49f3f489ec8816fb3ad228de081 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a669ce49f3f489ec8816fb3ad228de081">Dimension</a> () const</td></tr>
<tr class="memdesc:a669ce49f3f489ec8816fb3ad228de081 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the geometry is 2D or 3D.  <a href="classopen3d_1_1geometry_1_1_geometry.400.del#a669ce49f3f489ec8816fb3ad228de081">More...</a><br /></td></tr>
<tr class="separator:a669ce49f3f489ec8816fb3ad228de081 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cba98e39c57eb2544eedfb525807a06 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a7cba98e39c57eb2544eedfb525807a06">GetName</a> () const</td></tr>
<tr class="separator:a7cba98e39c57eb2544eedfb525807a06 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229d9bdaded622121f443cbb81626b8 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a4229d9bdaded622121f443cbb81626b8">SetName</a> (const std::string &amp;<a class="el" href="_o3_d_visualizer_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="separator:a4229d9bdaded622121f443cbb81626b8 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0d704fcb8fe632b9d4f310766870a51e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a0d704fcb8fe632b9d4f310766870a51e">ComputeTriangleArea</a> (const Eigen::Vector3d &amp;p0, const Eigen::Vector3d &amp;p1, const Eigen::Vector3d &amp;p2)</td></tr>
<tr class="memdesc:a0d704fcb8fe632b9d4f310766870a51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes the area of a mesh triangle.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a0d704fcb8fe632b9d4f310766870a51e">More...</a><br /></td></tr>
<tr class="separator:a0d704fcb8fe632b9d4f310766870a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ce14c4c8ab19d08a179d58533c94bd"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector3i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ad5ce14c4c8ab19d08a179d58533c94bd">GetOrderedTriangle</a> (int vidx0, int vidx1, int vidx2)</td></tr>
<tr class="separator:ad5ce14c4c8ab19d08a179d58533c94bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46707c4a7e41d4e82fc0460d3c568bda"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a46707c4a7e41d4e82fc0460d3c568bda">ComputeTrianglePlane</a> (const Eigen::Vector3d &amp;p0, const Eigen::Vector3d &amp;p1, const Eigen::Vector3d &amp;p2)</td></tr>
<tr class="separator:a46707c4a7e41d4e82fc0460d3c568bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52db96d3c6e509bac5a2ceecc9d8c1cc"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector2i&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a52db96d3c6e509bac5a2ceecc9d8c1cc">GetOrderedEdge</a> (int vidx0, int vidx1)</td></tr>
<tr class="memdesc:a52db96d3c6e509bac5a2ceecc9d8c1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to get an edge with ordered vertex indices.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a52db96d3c6e509bac5a2ceecc9d8c1cc">More...</a><br /></td></tr>
<tr class="separator:a52db96d3c6e509bac5a2ceecc9d8c1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5965a7bc530e8063507ca47a337c473a"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a5965a7bc530e8063507ca47a337c473a">CreateFromPointCloudAlphaShape</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;pcd, double alpha, std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_tetra_mesh.423.d">TetraMesh</a> &gt; tetra_mesh=nullptr, std::vector&lt; size_t &gt; *pt_map=nullptr)</td></tr>
<tr class="memdesc:a5965a7bc530e8063507ca47a337c473a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alpha shapes are a generalization of the convex hull. With decreasing alpha value the shape schrinks and creates cavities. See Edelsbrunner and Muecke, "Three-Dimensional Alpha Shapes", 1994.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a5965a7bc530e8063507ca47a337c473a">More...</a><br /></td></tr>
<tr class="separator:a5965a7bc530e8063507ca47a337c473a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab3d477f56928c447e28913484cf3c9"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a6ab3d477f56928c447e28913484cf3c9">CreateFromPointCloudBallPivoting</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;pcd, const std::vector&lt; double &gt; &amp;radii)</td></tr>
<tr class="separator:a6ab3d477f56928c447e28913484cf3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dacf0b62186999a6449f7332a1a5d54"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4dacf0b62186999a6449f7332a1a5d54">CreateFromPointCloudPoisson</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;pcd, size_t depth=8, float <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#a2474a5474cbff19523a51eb1de01cda4">width</a>=0.0f, float scale=1.1f, bool linear_fit=false, int n_threads=-1)</td></tr>
<tr class="memdesc:a4dacf0b62186999a6449f7332a1a5d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes a triangle mesh from an oriented <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> pcd. This implements the Screened Poisson Reconstruction proposed in Kazhdan and Hoppe, "Screened Poisson Surface
Reconstruction", 2013. This function uses the original implementation by Kazhdan. See <a href="https://github.com/mkazhdan/PoissonRecon">https://github.com/mkazhdan/PoissonRecon</a>.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4dacf0b62186999a6449f7332a1a5d54">More...</a><br /></td></tr>
<tr class="separator:a4dacf0b62186999a6449f7332a1a5d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7887ba3429f25dd882d4445cade594b1"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7887ba3429f25dd882d4445cade594b1">CreateTetrahedron</a> (double radius=1.0, bool create_uv_map=false)</td></tr>
<tr class="separator:a7887ba3429f25dd882d4445cade594b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93952e5fd1b8c30d6a9205a2aab55da6"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a93952e5fd1b8c30d6a9205a2aab55da6">CreateOctahedron</a> (double radius=1.0, bool create_uv_map=false)</td></tr>
<tr class="separator:a93952e5fd1b8c30d6a9205a2aab55da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4d59a4dc7706d6dc2497030ec983d3"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a1a4d59a4dc7706d6dc2497030ec983d3">CreateIcosahedron</a> (double radius=1.0, bool create_uv_map=false)</td></tr>
<tr class="separator:a1a4d59a4dc7706d6dc2497030ec983d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7518102a6d34c351a0d2746bd97751"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a9e7518102a6d34c351a0d2746bd97751">CreateFromOrientedBoundingBox</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> &amp;obox, const Eigen::Vector3d &amp;scale=Eigen::Vector3d::Ones(), bool create_uv_map=false)</td></tr>
<tr class="separator:a9e7518102a6d34c351a0d2746bd97751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af021770830e75cc803dc449a3d7ea9d6"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af021770830e75cc803dc449a3d7ea9d6">CreateBox</a> (double <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#a2474a5474cbff19523a51eb1de01cda4">width</a>=1.0, double <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#ad12fc34ce789bce6c8a05d8a17138534">height</a>=1.0, double depth=1.0, bool create_uv_map=false, bool map_texture_to_each_face=false)</td></tr>
<tr class="separator:af021770830e75cc803dc449a3d7ea9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3d6d87ae64e86a20c90e134424ad04"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#afc3d6d87ae64e86a20c90e134424ad04">CreateSphere</a> (double radius=1.0, int resolution=20, bool create_uv_map=false)</td></tr>
<tr class="separator:afc3d6d87ae64e86a20c90e134424ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d789a436c3500b1eec51d304dbcb42"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ab6d789a436c3500b1eec51d304dbcb42">CreateCylinder</a> (double radius=1.0, double <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#ad12fc34ce789bce6c8a05d8a17138534">height</a>=2.0, int resolution=20, int split=4, bool create_uv_map=false)</td></tr>
<tr class="separator:ab6d789a436c3500b1eec51d304dbcb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbf5a268ec72582a78a882f474e198a"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a4bbf5a268ec72582a78a882f474e198a">CreateCone</a> (double radius=1.0, double <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#ad12fc34ce789bce6c8a05d8a17138534">height</a>=2.0, int resolution=20, int split=1, bool create_uv_map=false)</td></tr>
<tr class="separator:a4bbf5a268ec72582a78a882f474e198a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9780fe9ca63211dbda959c5e7f4fc0"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#acb9780fe9ca63211dbda959c5e7f4fc0">CreateTorus</a> (double torus_radius=1.0, double tube_radius=0.5, int radial_resolution=30, int tubular_resolution=20)</td></tr>
<tr class="separator:acb9780fe9ca63211dbda959c5e7f4fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa494192578437efa1ba34a5dded2b2f"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aaa494192578437efa1ba34a5dded2b2f">CreateArrow</a> (double cylinder_radius=1.0, double cone_radius=1.5, double cylinder_height=5.0, double cone_height=4.0, int resolution=20, int cylinder_split=4, int cone_split=1)</td></tr>
<tr class="separator:aaa494192578437efa1ba34a5dded2b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9599cdc1c8f4a5efb92016319daee05"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#af9599cdc1c8f4a5efb92016319daee05">CreateCoordinateFrame</a> (double <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#a439227feff9d7f55384e8780cfc2eb82">size</a>=1.0, const Eigen::Vector3d &amp;origin=Eigen::Vector3d(0.0, 0.0, 0.0))</td></tr>
<tr class="separator:af9599cdc1c8f4a5efb92016319daee05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec762c32c18d5d8a7f3259662a79cb"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a3dec762c32c18d5d8a7f3259662a79cb">CreateMobius</a> (int length_split=70, int width_split=15, int twists=1, double radius=1, double flatness=1, double <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#a2474a5474cbff19523a51eb1de01cda4">width</a>=1, double scale=1)</td></tr>
<tr class="separator:a3dec762c32c18d5d8a7f3259662a79cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402">open3d::geometry::Geometry3D</a></td></tr>
<tr class="memitem:ab557dd1610ea7fae73d00c706bbd529f inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab557dd1610ea7fae73d00c706bbd529f">GetRotationMatrixFromXYZ</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:ab557dd1610ea7fae73d00c706bbd529f inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from XYZ RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab557dd1610ea7fae73d00c706bbd529f">More...</a><br /></td></tr>
<tr class="separator:ab557dd1610ea7fae73d00c706bbd529f inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b8ef97b798c623b4e2fe72d2afda03 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#af5b8ef97b798c623b4e2fe72d2afda03">GetRotationMatrixFromYZX</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:af5b8ef97b798c623b4e2fe72d2afda03 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from YZX RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#af5b8ef97b798c623b4e2fe72d2afda03">More...</a><br /></td></tr>
<tr class="separator:af5b8ef97b798c623b4e2fe72d2afda03 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb9b2eabab1ced5c25358c3a69c8d13 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#afbb9b2eabab1ced5c25358c3a69c8d13">GetRotationMatrixFromZXY</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:afbb9b2eabab1ced5c25358c3a69c8d13 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from ZXY RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#afbb9b2eabab1ced5c25358c3a69c8d13">More...</a><br /></td></tr>
<tr class="separator:afbb9b2eabab1ced5c25358c3a69c8d13 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f91e4bddbb07a3ccd6692db599eca7 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a82f91e4bddbb07a3ccd6692db599eca7">GetRotationMatrixFromXZY</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:a82f91e4bddbb07a3ccd6692db599eca7 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from XZY RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a82f91e4bddbb07a3ccd6692db599eca7">More...</a><br /></td></tr>
<tr class="separator:a82f91e4bddbb07a3ccd6692db599eca7 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96c4285c5d5cc80f14458559c7a3826 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac96c4285c5d5cc80f14458559c7a3826">GetRotationMatrixFromZYX</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:ac96c4285c5d5cc80f14458559c7a3826 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from ZYX RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac96c4285c5d5cc80f14458559c7a3826">More...</a><br /></td></tr>
<tr class="separator:ac96c4285c5d5cc80f14458559c7a3826 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ee2e4c68c2c55ac4ab8b533b11dad0 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a16ee2e4c68c2c55ac4ab8b533b11dad0">GetRotationMatrixFromYXZ</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:a16ee2e4c68c2c55ac4ab8b533b11dad0 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from YXZ RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a16ee2e4c68c2c55ac4ab8b533b11dad0">More...</a><br /></td></tr>
<tr class="separator:a16ee2e4c68c2c55ac4ab8b533b11dad0 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9356dfe2ba6a44df60588f4b2a29056 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa9356dfe2ba6a44df60588f4b2a29056">GetRotationMatrixFromAxisAngle</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:aa9356dfe2ba6a44df60588f4b2a29056 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from AxisAngle RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa9356dfe2ba6a44df60588f4b2a29056">More...</a><br /></td></tr>
<tr class="separator:aa9356dfe2ba6a44df60588f4b2a29056 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9966dec46a4808e5acd9318fa6bf73a inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ad9966dec46a4808e5acd9318fa6bf73a">GetRotationMatrixFromQuaternion</a> (const Eigen::Vector4d &amp;rotation)</td></tr>
<tr class="memdesc:ad9966dec46a4808e5acd9318fa6bf73a inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from Quaternion.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ad9966dec46a4808e5acd9318fa6bf73a">More...</a><br /></td></tr>
<tr class="separator:ad9966dec46a4808e5acd9318fa6bf73a inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a7dcddd5784eaa2efedfa5e274aa50e3e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3i &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7dcddd5784eaa2efedfa5e274aa50e3e">triangles_</a></td></tr>
<tr class="memdesc:a7dcddd5784eaa2efedfa5e274aa50e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of triangles denoted by the index of points forming the triangle.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7dcddd5784eaa2efedfa5e274aa50e3e">More...</a><br /></td></tr>
<tr class="separator:a7dcddd5784eaa2efedfa5e274aa50e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90341a2a76590e3a9ce4d507d3a2285c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a90341a2a76590e3a9ce4d507d3a2285c">triangle_normals_</a></td></tr>
<tr class="memdesc:a90341a2a76590e3a9ce4d507d3a2285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangle normals.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a90341a2a76590e3a9ce4d507d3a2285c">More...</a><br /></td></tr>
<tr class="separator:a90341a2a76590e3a9ce4d507d3a2285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37984016ded7bbceb893c5dba0e8b6c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unordered_set&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a37984016ded7bbceb893c5dba0e8b6c8">adjacency_list_</a></td></tr>
<tr class="separator:a37984016ded7bbceb893c5dba0e8b6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da74c05d87cfef5ca025b39d8e6efc3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector2d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a6da74c05d87cfef5ca025b39d8e6efc3">triangle_uvs_</a></td></tr>
<tr class="memdesc:a6da74c05d87cfef5ca025b39d8e6efc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of uv coordinates per triangle.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a6da74c05d87cfef5ca025b39d8e6efc3">More...</a><br /></td></tr>
<tr class="separator:a6da74c05d87cfef5ca025b39d8e6efc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa415bc74025604428db8b7d2f97b5d8d"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="structopen3d_1_1geometry_1_1_triangle_mesh_1">Material</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aa415bc74025604428db8b7d2f97b5d8d">materials_</a></td></tr>
<tr class="separator:aa415bc74025604428db8b7d2f97b5d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade007ba5e10cb3c60c9d7f4d2e8f2611"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ade007ba5e10cb3c60c9d7f4d2e8f2611">triangle_material_ids_</a></td></tr>
<tr class="memdesc:ade007ba5e10cb3c60c9d7f4d2e8f2611"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of material ids.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#ade007ba5e10cb3c60c9d7f4d2e8f2611">More...</a><br /></td></tr>
<tr class="separator:ade007ba5e10cb3c60c9d7f4d2e8f2611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0babf96deb5056e1b36b5ee3517d0a80"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classopen3d_1_1geometry_1_1_image.406.delaye">Image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a0babf96deb5056e1b36b5ee3517d0a80">textures_</a></td></tr>
<tr class="memdesc:a0babf96deb5056e1b36b5ee3517d0a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Textures of the image.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a0babf96deb5056e1b36b5ee3517d0a80">More...</a><br /></td></tr>
<tr class="separator:a0babf96deb5056e1b36b5ee3517d0a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classopen3d_1_1geometry_1_1_mesh_base')"><img src="closed.png" alt="-"/>&#160;Data Fields inherited from <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">open3d::geometry::MeshBase</a></td></tr>
<tr class="memitem:a004aeef2268433b07feb4ee32e560292 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a004aeef2268433b07feb4ee32e560292">vertices_</a></td></tr>
<tr class="memdesc:a004aeef2268433b07feb4ee32e560292 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex coordinates.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a004aeef2268433b07feb4ee32e560292">More...</a><br /></td></tr>
<tr class="separator:a004aeef2268433b07feb4ee32e560292 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d33d6cd75814858c797096c605fc55 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ad3d33d6cd75814858c797096c605fc55">vertex_normals_</a></td></tr>
<tr class="memdesc:ad3d33d6cd75814858c797096c605fc55 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex normals.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ad3d33d6cd75814858c797096c605fc55">More...</a><br /></td></tr>
<tr class="separator:ad3d33d6cd75814858c797096c605fc55 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ab85a9c0d063d22ddbe058daa86751 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a41ab85a9c0d063d22ddbe058daa86751">vertex_colors_</a></td></tr>
<tr class="memdesc:a41ab85a9c0d063d22ddbe058daa86751 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB colors of vertices.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a41ab85a9c0d063d22ddbe058daa86751">More...</a><br /></td></tr>
<tr class="separator:a41ab85a9c0d063d22ddbe058daa86751 inherit pub_attribs_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a07a3a1b482040ffce65063cc4dde9a2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a07a3a1b482040ffce65063cc4dde9a2c">TriangleMesh</a> (<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">Geometry::GeometryType</a> <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aff17911edc8208aa8ddb1c7c52c78389">type</a>)</td></tr>
<tr class="separator:a07a3a1b482040ffce65063cc4dde9a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e48df0de848bf8137bc2fe5e1981e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a6e48df0de848bf8137bc2fe5e1981e90">FilterSmoothLaplacianHelper</a> (std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; &amp;mesh, const std::vector&lt; Eigen::Vector3d &gt; &amp;prev_vertices, const std::vector&lt; Eigen::Vector3d &gt; &amp;prev_vertex_normals, const std::vector&lt; Eigen::Vector3d &gt; &amp;prev_vertex_colors, const std::vector&lt; std::unordered_set&lt; int &gt;&gt; &amp;adjacency_list, double lambda_filter, bool filter_vertex, bool filter_normal, bool filter_color) const</td></tr>
<tr class="separator:a6e48df0de848bf8137bc2fe5e1981e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d293d2770e0c98de7c21a1a36975ad5"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Eigen::Vector2i, double, <a class="el" href="structopen3d_1_1utility_1_1hash__eigen.44c.d">utility::hash_eigen</a>&lt; Eigen::Vector2i &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7d293d2770e0c98de7c21a1a36975ad5">ComputeEdgeWeightsCot</a> (const std::unordered_map&lt; Eigen::Vector2i, std::vector&lt; int &gt;, <a class="el" href="structopen3d_1_1utility_1_1hash__eigen.44c.d">utility::hash_eigen</a>&lt; Eigen::Vector2i &gt;&gt; &amp;edges_to_vertices, double min_weight=std::numeric_limits&lt; double &gt;::lowest()) const</td></tr>
<tr class="memdesc:a7d293d2770e0c98de7c21a1a36975ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes for each edge in the triangle mesh and passed as parameter edges_to_vertices the cot weight.  <a href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7d293d2770e0c98de7c21a1a36975ad5">More...</a><br /></td></tr>
<tr class="separator:a7d293d2770e0c98de7c21a1a36975ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classopen3d_1_1geometry_1_1_mesh_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classopen3d_1_1geometry_1_1_mesh_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">open3d::geometry::MeshBase</a></td></tr>
<tr class="memitem:a07940523af0c82dff28ca957845b1088 inherit pro_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a07940523af0c82dff28ca957845b1088">MeshBase</a> (<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">Geometry::GeometryType</a> <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aff17911edc8208aa8ddb1c7c52c78389">type</a>)</td></tr>
<tr class="separator:a07940523af0c82dff28ca957845b1088 inherit pro_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5267f51298df2bf8a85eba695396c7ad inherit pro_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a5267f51298df2bf8a85eba695396c7ad">MeshBase</a> (<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">Geometry::GeometryType</a> <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aff17911edc8208aa8ddb1c7c52c78389">type</a>, const std::vector&lt; Eigen::Vector3d &gt; &amp;vertices)</td></tr>
<tr class="separator:a5267f51298df2bf8a85eba695396c7ad inherit pro_methods_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classopen3d_1_1geometry_1_1_geometry3_d')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402">open3d::geometry::Geometry3D</a></td></tr>
<tr class="memitem:ab7c4a13882fb57765e55e164e34eedfb inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab7c4a13882fb57765e55e164e34eedfb">Geometry3D</a> (<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">GeometryType</a> <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aff17911edc8208aa8ddb1c7c52c78389">type</a>)</td></tr>
<tr class="memdesc:ab7c4a13882fb57765e55e164e34eedfb inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized Constructor.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab7c4a13882fb57765e55e164e34eedfb">More...</a><br /></td></tr>
<tr class="separator:ab7c4a13882fb57765e55e164e34eedfb inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03dcc177e8b50632e95d7dd7d838976 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa03dcc177e8b50632e95d7dd7d838976">ComputeMinBound</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>) const</td></tr>
<tr class="memdesc:aa03dcc177e8b50632e95d7dd7d838976 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute min bound of a list points.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa03dcc177e8b50632e95d7dd7d838976">More...</a><br /></td></tr>
<tr class="separator:aa03dcc177e8b50632e95d7dd7d838976 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487b1d81a14ef17bf70e8c4d94d5c18c inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a487b1d81a14ef17bf70e8c4d94d5c18c">ComputeMaxBound</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>) const</td></tr>
<tr class="memdesc:a487b1d81a14ef17bf70e8c4d94d5c18c inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute max bound of a list points.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a487b1d81a14ef17bf70e8c4d94d5c18c">More...</a><br /></td></tr>
<tr class="separator:a487b1d81a14ef17bf70e8c4d94d5c18c inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e6a432ab26afcb7fb572313ddc90ce inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac8e6a432ab26afcb7fb572313ddc90ce">ComputeCenter</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>) const</td></tr>
<tr class="memdesc:ac8e6a432ab26afcb7fb572313ddc90ce inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computer center of a list of points.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac8e6a432ab26afcb7fb572313ddc90ce">More...</a><br /></td></tr>
<tr class="separator:ac8e6a432ab26afcb7fb572313ddc90ce inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb3da9e31897b4279f02327daca34cd inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a1fb3da9e31897b4279f02327daca34cd">ResizeAndPaintUniformColor</a> (std::vector&lt; Eigen::Vector3d &gt; &amp;colors, const size_t <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#a439227feff9d7f55384e8780cfc2eb82">size</a>, const Eigen::Vector3d &amp;<a class="el" href="_triangle_mesh_buffers_8cpp.html#aa332976d803be75beb81e81af320bfcb">color</a>) const</td></tr>
<tr class="memdesc:a1fb3da9e31897b4279f02327daca34cd inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the colors vector and paints a uniform color.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a1fb3da9e31897b4279f02327daca34cd">More...</a><br /></td></tr>
<tr class="separator:a1fb3da9e31897b4279f02327daca34cd inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3a5c603c2c9a0e05c1af1a4a279508 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a0e3a5c603c2c9a0e05c1af1a4a279508">TransformPoints</a> (const Eigen::Matrix4d &amp;transformation, std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>) const</td></tr>
<tr class="memdesc:a0e3a5c603c2c9a0e05c1af1a4a279508 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms all points with the transformation matrix.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a0e3a5c603c2c9a0e05c1af1a4a279508">More...</a><br /></td></tr>
<tr class="separator:a0e3a5c603c2c9a0e05c1af1a4a279508 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1df456f2e6dddac794f7ab2186a7ce5 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac1df456f2e6dddac794f7ab2186a7ce5">TransformNormals</a> (const Eigen::Matrix4d &amp;transformation, std::vector&lt; Eigen::Vector3d &gt; &amp;normals) const</td></tr>
<tr class="memdesc:ac1df456f2e6dddac794f7ab2186a7ce5 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the normals with the transformation matrix.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac1df456f2e6dddac794f7ab2186a7ce5">More...</a><br /></td></tr>
<tr class="separator:ac1df456f2e6dddac794f7ab2186a7ce5 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623c3e7c883e0bcfc2987aaf92c96597 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a623c3e7c883e0bcfc2987aaf92c96597">TransformCovariances</a> (const Eigen::Matrix4d &amp;transformation, std::vector&lt; Eigen::Matrix3d &gt; &amp;covariances) const</td></tr>
<tr class="memdesc:a623c3e7c883e0bcfc2987aaf92c96597 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms all covariance matrices with the transformation.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a623c3e7c883e0bcfc2987aaf92c96597">More...</a><br /></td></tr>
<tr class="separator:a623c3e7c883e0bcfc2987aaf92c96597 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4029dff278938fcf7eb73b4133f76e67 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a4029dff278938fcf7eb73b4133f76e67">TranslatePoints</a> (const Eigen::Vector3d &amp;translation, std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, bool relative) const</td></tr>
<tr class="memdesc:a4029dff278938fcf7eb73b4133f76e67 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply translation to the geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a4029dff278938fcf7eb73b4133f76e67">More...</a><br /></td></tr>
<tr class="separator:a4029dff278938fcf7eb73b4133f76e67 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26106b31a3acecad90f44293c83a3a1b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a26106b31a3acecad90f44293c83a3a1b">ScalePoints</a> (const double scale, std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, const Eigen::Vector3d &amp;center) const</td></tr>
<tr class="memdesc:a26106b31a3acecad90f44293c83a3a1b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the coordinates of all points by the scaling factor <code>scale</code>.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a26106b31a3acecad90f44293c83a3a1b">More...</a><br /></td></tr>
<tr class="separator:a26106b31a3acecad90f44293c83a3a1b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901a9fda0a2b40a8a53ea45ff18a1760 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a901a9fda0a2b40a8a53ea45ff18a1760">RotatePoints</a> (const Eigen::Matrix3d &amp;R, std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, const Eigen::Vector3d &amp;center) const</td></tr>
<tr class="memdesc:a901a9fda0a2b40a8a53ea45ff18a1760 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all points with the rotation matrix <code>R</code>.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a901a9fda0a2b40a8a53ea45ff18a1760">More...</a><br /></td></tr>
<tr class="separator:a901a9fda0a2b40a8a53ea45ff18a1760 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2448e4cfbdb49e90e72289e36113d9b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa2448e4cfbdb49e90e72289e36113d9b">RotateNormals</a> (const Eigen::Matrix3d &amp;R, std::vector&lt; Eigen::Vector3d &gt; &amp;normals) const</td></tr>
<tr class="memdesc:aa2448e4cfbdb49e90e72289e36113d9b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all normals with the rotation matrix <code>R</code>.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa2448e4cfbdb49e90e72289e36113d9b">More...</a><br /></td></tr>
<tr class="separator:aa2448e4cfbdb49e90e72289e36113d9b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce8a11fd0762558a620f448f18ebae3 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a9ce8a11fd0762558a620f448f18ebae3">RotateCovariances</a> (const Eigen::Matrix3d &amp;R, std::vector&lt; Eigen::Matrix3d &gt; &amp;covariances) const</td></tr>
<tr class="memdesc:a9ce8a11fd0762558a620f448f18ebae3 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all covariance matrices with the rotation matrix <code>R</code>.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a9ce8a11fd0762558a620f448f18ebae3">More...</a><br /></td></tr>
<tr class="separator:a9ce8a11fd0762558a620f448f18ebae3 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classopen3d_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classopen3d_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del">open3d::geometry::Geometry</a></td></tr>
<tr class="memitem:ae0bb1c2bed5d65d1ecd0e81370a12d99 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#ae0bb1c2bed5d65d1ecd0e81370a12d99">Geometry</a> (<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">GeometryType</a> <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aff17911edc8208aa8ddb1c7c52c78389">type</a>, int dimension)</td></tr>
<tr class="memdesc:ae0bb1c2bed5d65d1ecd0e81370a12d99 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized Constructor.  <a href="classopen3d_1_1geometry_1_1_geometry.400.del#ae0bb1c2bed5d65d1ecd0e81370a12d99">More...</a><br /></td></tr>
<tr class="separator:ae0bb1c2bed5d65d1ecd0e81370a12d99 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classopen3d_1_1geometry_1_1_mesh_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classopen3d_1_1geometry_1_1_mesh_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de">open3d::geometry::MeshBase</a></td></tr>
<tr class="memitem:a84f9db88a4d0d23d755136ddfa7e6bd7 inherit pub_types_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a84f9db88a4d0d23d755136ddfa7e6bd7">SimplificationContraction</a> { <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a84f9db88a4d0d23d755136ddfa7e6bd7ab1897515d548a960afe49ecf66a29021">Average</a>
, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a84f9db88a4d0d23d755136ddfa7e6bd7add6dfa467092f93b67f60fb75476b794">Quadric</a>
 }</td></tr>
<tr class="memdesc:a84f9db88a4d0d23d755136ddfa7e6bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the method that is used for mesh simplification if multiple vertices are combined to a single one.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a84f9db88a4d0d23d755136ddfa7e6bd7">More...</a><br /></td></tr>
<tr class="separator:a84f9db88a4d0d23d755136ddfa7e6bd7 inherit pub_types_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63b2a09012544530c370e7a3828c89c inherit pub_types_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a> { <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">All</a>
, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cacb5feb1b7314637725a2e73bdc9f7295">Color</a>
, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89ca960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>
, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab22b929ba52471a02d18bb3a4e4472e6">Vertex</a>
 }</td></tr>
<tr class="memdesc:af63b2a09012544530c370e7a3828c89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the scope of filter operations.  <a href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">More...</a><br /></td></tr>
<tr class="separator:af63b2a09012544530c370e7a3828c89c inherit pub_types_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7e206d12e10f059ca530cd04c4d07a inherit pub_types_classopen3d_1_1geometry_1_1_mesh_base"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a6f7e206d12e10f059ca530cd04c4d07a">DeformAsRigidAsPossibleEnergy</a> { <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a6f7e206d12e10f059ca530cd04c4d07aa111552792d2df37209e4e9815a8524a8">Spokes</a>
, <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a6f7e206d12e10f059ca530cd04c4d07aac5d48c613aa395e2f92d06e97b85aa97">Smoothed</a>
 }</td></tr>
<tr class="separator:a6f7e206d12e10f059ca530cd04c4d07a inherit pub_types_classopen3d_1_1geometry_1_1_mesh_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classopen3d_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classopen3d_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del">open3d::geometry::Geometry</a></td></tr>
<tr class="memitem:a69975c2b054d4fd12cf36866a030ed8e inherit pub_types_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">GeometryType</a> { <br />
&#160;&#160;<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea6fcdc090caeade09d0efd6253932b6f5">Unspecified</a> = 0
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eaee9349b5cdfd717c7e1234edce6b72fa">PointCloud</a> = 1
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea7fe2447f30c8de08b433c3631d7d78ff">VoxelGrid</a> = 2
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea3d33fe96c4d284d37a6ee296db5e33ac">Octree</a> = 3
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eae3e5995e4fc46bdc12e733558dd3120a">LineSet</a> = 4
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea2ad6a25f1ccff1433467bae74193446e">MeshBase</a> = 5
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea70be243de75004a602f012fece7c0fad">TriangleMesh</a> = 6
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eaa79a2e14e35ed8368058ad93d3d39dc3">HalfEdgeTriangleMesh</a> = 7
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eabe53a0541a6d36f6ecb879fa2c584b08">Image</a> = 8
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea7d64b6deb2cbf0f1712bd6e93b5755ba">RGBDImage</a> = 9
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea48e9695b4242a3a90ea76c7cc87162de">TetraMesh</a> = 10
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eaff8b20067506aaf814f1e5df2494c2f1">OrientedBoundingBox</a> = 11
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea0446516d578c6abaae2f3adc7239fa61">AxisAlignedBoundingBox</a> = 12
<br />
 }</td></tr>
<tr class="memdesc:a69975c2b054d4fd12cf36866a030ed8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies possible geometry types.  <a href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">More...</a><br /></td></tr>
<tr class="separator:a69975c2b054d4fd12cf36866a030ed8e inherit pub_types_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Triangle mesh contains vertices and triangles represented by the indices to the vertices. </p>
<p>Optionally, the mesh may also contain triangle normals, vertex normals and vertex colors. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae2d8c6f82481d56ba06e849991261924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d8c6f82481d56ba06e849991261924">&#9670;&nbsp;</a></span>TriangleMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">open3d::geometry::TriangleMesh::TriangleMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>

</div>
</div>
<a id="ad1f5666200f972bed5b78dd3b0e1f9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f5666200f972bed5b78dd3b0e1f9ec">&#9670;&nbsp;</a></span>TriangleMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">open3d::geometry::TriangleMesh::TriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3i &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameterized Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>list of vertices. </td></tr>
    <tr><td class="paramname">triangles</td><td>list of triangles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7046aa1902fbc4e5688109930402ca5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7046aa1902fbc4e5688109930402ca5d">&#9670;&nbsp;</a></span>~TriangleMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">open3d::geometry::TriangleMesh::~TriangleMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07a3a1b482040ffce65063cc4dde9a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a3a1b482040ffce65063cc4dde9a2c">&#9670;&nbsp;</a></span>TriangleMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">open3d::geometry::TriangleMesh::TriangleMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">Geometry::GeometryType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ea92820de31c1fcbf62e5c6d9516540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea92820de31c1fcbf62e5c6d9516540">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all elements in the geometry. </p>

<p>Reimplemented from <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#ac3f81cdfc14b1fe903f2d5c3bd3b9cd7">open3d::geometry::MeshBase</a>.</p>

</div>
</div>
<a id="a15ffe6ee562b74d1d48786c97f55bb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ffe6ee562b74d1d48786c97f55bb0e">&#9670;&nbsp;</a></span>ClusterConnectedTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; int &gt;, std::vector&lt; size_t &gt;, std::vector&lt; double &gt; &gt; open3d::geometry::TriangleMesh::ClusterConnectedTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that clusters connected triangles, i.e., triangles that are connected via edges are assigned the same cluster index. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector that contains the cluster index per triangle, a second vector contains the number of triangles per cluster, and a third vector contains the surface area per cluster. </dd></dl>

</div>
</div>
<a id="acf0f8d836ee1eea6ecc540c43bc1e9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0f8d836ee1eea6ecc540c43bc1e9d1">&#9670;&nbsp;</a></span>ComputeAdjacencyList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::ComputeAdjacencyList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute adjacency list, call before adjacency list is needed. </p>

</div>
</div>
<a id="a7d293d2770e0c98de7c21a1a36975ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d293d2770e0c98de7c21a1a36975ad5">&#9670;&nbsp;</a></span>ComputeEdgeWeightsCot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Eigen::Vector2i, double, <a class="el" href="structopen3d_1_1utility_1_1hash__eigen.44c.d">utility::hash_eigen</a>&lt; Eigen::Vector2i &gt; &gt; open3d::geometry::TriangleMesh::ComputeEdgeWeightsCot </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; Eigen::Vector2i, std::vector&lt; int &gt;, <a class="el" href="structopen3d_1_1utility_1_1hash__eigen.44c.d">utility::hash_eigen</a>&lt; Eigen::Vector2i &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges_to_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_weight</em> = <code>std::numeric_limits&lt;double&gt;::lowest()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that computes for each edge in the triangle mesh and passed as parameter edges_to_vertices the cot weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges_to_vertices</td><td>map from edge to vector of neighbouring vertices. </td></tr>
    <tr><td class="paramname">min_weight</td><td>minimum weight returned. Weights smaller than this get clamped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cot weight per edge. </dd></dl>

</div>
</div>
<a id="a0d704fcb8fe632b9d4f310766870a51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d704fcb8fe632b9d4f310766870a51e">&#9670;&nbsp;</a></span>ComputeTriangleArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double open3d::geometry::TriangleMesh::ComputeTriangleArea </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that computes the area of a mesh triangle. </p>

</div>
</div>
<a id="af324cfbefa0bed22b0325a2a34bf6069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af324cfbefa0bed22b0325a2a34bf6069">&#9670;&nbsp;</a></span>ComputeTriangleNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::ComputeTriangleNormals </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute triangle normals, usually called before rendering. </p>

</div>
</div>
<a id="a46707c4a7e41d4e82fc0460d3c568bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46707c4a7e41d4e82fc0460d3c568bda">&#9670;&nbsp;</a></span>ComputeTrianglePlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector4d open3d::geometry::TriangleMesh::ComputeTrianglePlane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that computes the plane equation from the three points. If the three points are co-linear, then this function returns the invalid plane (0, 0, 0, 0). </p>

</div>
</div>
<a id="a4b31309a8d8c1f94a7ff0434a884f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b31309a8d8c1f94a7ff0434a884f0eb">&#9670;&nbsp;</a></span>ComputeVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::ComputeVertexNormals </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute vertex normals, usually called before rendering. </p>

</div>
</div>
<a id="aaa494192578437efa1ba34a5dded2b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa494192578437efa1ba34a5dded2b2f">&#9670;&nbsp;</a></span>CreateArrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateArrow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cylinder_radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cone_radius</em> = <code>1.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cylinder_height</em> = <code>5.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cone_height</em> = <code>4.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cylinder_split</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cone_split</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create an arrow mesh (TriangleMeshFactory.cpp) The axis of the cone with cone_radius will be along the z-axis. The cylinder with cylinder_radius is from (0, 0, 0) to (0, 0, cylinder_height), and the cone is from (0, 0, cylinder_height) to (0, 0, cylinder_height + cone_height). The cone will be split into resolution segments. The cylinder_height will be split into cylinder_split segments. The cone_height will be split into cone_split segments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cylinder_radius</td><td>defines the radius of the cylinder. </td></tr>
    <tr><td class="paramname">cone_radius</td><td>defines the radius of the cone. </td></tr>
    <tr><td class="paramname">cylinder_height</td><td>defines the height of the cylinder. The cylinder is from (0, 0, 0) to (0, 0, cylinder_height) </td></tr>
    <tr><td class="paramname">cone_height</td><td>defines the height of the cone. The axis of the cone will be from (0, 0, cylinder_height) to (0, 0, cylinder_height + cone_height). </td></tr>
    <tr><td class="paramname">resolution</td><td>defines the cone will be split into resolution segments. </td></tr>
    <tr><td class="paramname">cylinder_split</td><td>defines the cylinder_height will be split into cylinder_split segments. </td></tr>
    <tr><td class="paramname">cone_split</td><td>defines the cone_height will be split into cone_split segments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af021770830e75cc803dc449a3d7ea9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af021770830e75cc803dc449a3d7ea9d6">&#9670;&nbsp;</a></span>CreateBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateBox </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_uv_map</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>map_texture_to_each_face</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create a box mesh (TriangleMeshFactory.cpp) The left bottom corner on the front will be placed at (0, 0, 0). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>is x-directional length. </td></tr>
    <tr><td class="paramname">height</td><td>is y-directional length. </td></tr>
    <tr><td class="paramname">depth</td><td>is z-directional length. </td></tr>
    <tr><td class="paramname">create_uv_map</td><td>add default UV map to the shape. </td></tr>
    <tr><td class="paramname">map_texture_to_each_face</td><td>if true, maps the entire texture image to each face. If false, sets the default uv map to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bbf5a268ec72582a78a882f474e198a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbf5a268ec72582a78a882f474e198a">&#9670;&nbsp;</a></span>CreateCone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateCone </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_uv_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create a cone mesh (TriangleMeshFactory.cpp) The axis of the cone will be from (0, 0, 0) to (0, 0, height). The circle with radius will be split into resolution segments. The height will be split into split segments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>defines the radius of the cone. </td></tr>
    <tr><td class="paramname">height</td><td>defines the height of the cone. </td></tr>
    <tr><td class="paramname">resolution</td><td>defines that the circle will be split into resolution segments. </td></tr>
    <tr><td class="paramname">split</td><td>defines that the height will be split into split segments. </td></tr>
    <tr><td class="paramname">create_uv_map</td><td>add default UV map to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9599cdc1c8f4a5efb92016319daee05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9599cdc1c8f4a5efb92016319daee05">&#9670;&nbsp;</a></span>CreateCoordinateFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateCoordinateFrame </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>size</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>origin</em> = <code>Eigen::Vector3d(0.0,&#160;0.0,&#160;0.0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create a coordinate frame mesh (TriangleMeshFactory.cpp). arrows respectively. <code>size</code> is the length of the axes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>defines the size of the coordinate frame. </td></tr>
    <tr><td class="paramname">origin</td><td>defines the origin of the coordinate frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d789a436c3500b1eec51d304dbcb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d789a436c3500b1eec51d304dbcb42">&#9670;&nbsp;</a></span>CreateCylinder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateCylinder </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_uv_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create a cylinder mesh (TriangleMeshFactory.cpp) The axis of the cylinder will be from (0, 0, -height/2) to (0, 0, height/2). The circle with radius will be split into resolution segments. The height will be split into split segments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>defines the radius of the cylinder. </td></tr>
    <tr><td class="paramname">height</td><td>defines the height of the cylinder. </td></tr>
    <tr><td class="paramname">resolution</td><td>defines that the circle will be split into resolution segments. </td></tr>
    <tr><td class="paramname">split</td><td>defines that the height will be split into split segments. </td></tr>
    <tr><td class="paramname">create_uv_map</td><td>add default UV map to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e7518102a6d34c351a0d2746bd97751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7518102a6d34c351a0d2746bd97751">&#9670;&nbsp;</a></span>CreateFromOrientedBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateFromOrientedBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>obox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code>Eigen::Vector3d::Ones()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_uv_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create solid mesh from an <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin" title="A bounding box oriented along an arbitrary frame of reference.">OrientedBoundingBox</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obox</td><td><a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin" title="A bounding box oriented along an arbitrary frame of reference.">OrientedBoundingBox</a> object to create a mesh of </td></tr>
    <tr><td class="paramname">scale</td><td>scale factor along each direction of <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin" title="A bounding box oriented along an arbitrary frame of reference.">OrientedBoundingBox</a> </td></tr>
    <tr><td class="paramname">create_uv_map</td><td>add default UV map to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5965a7bc530e8063507ca47a337c473a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5965a7bc530e8063507ca47a337c473a">&#9670;&nbsp;</a></span>CreateFromPointCloudAlphaShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateFromPointCloudAlphaShape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>pcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_tetra_mesh.423.d">TetraMesh</a> &gt;&#160;</td>
          <td class="paramname"><em>tetra_mesh</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>pt_map</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alpha shapes are a generalization of the convex hull. With decreasing alpha value the shape schrinks and creates cavities. See Edelsbrunner and Muecke, "Three-Dimensional Alpha Shapes", 1994. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcd</td><td><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> for what the alpha shape should be computed. </td></tr>
    <tr><td class="paramname">alpha</td><td>parameter to control the shape. A very big value will give a shape close to the convex hull. </td></tr>
    <tr><td class="paramname">tetra_mesh</td><td>If not a nullptr, then uses this to construct the alpha shape. Otherwise, ComputeDelaunayTetrahedralization is called. </td></tr>
    <tr><td class="paramname">pt_map</td><td>Optional map from tetra_mesh vertex indices to pcd points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40" title="Triangle mesh contains vertices and triangles represented by the indices to the vertices.">TriangleMesh</a> of the alpha shape. </dd></dl>

</div>
</div>
<a id="a6ab3d477f56928c447e28913484cf3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab3d477f56928c447e28913484cf3c9">&#9670;&nbsp;</a></span>CreateFromPointCloudBallPivoting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateFromPointCloudBallPivoting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>pcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>radii</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that computes a triangle mesh from an oriented <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> <code>pcd</code>. This implements the Ball Pivoting algorithm proposed in F. Bernardini et al., "The ball-pivoting algorithm for surface
reconstruction", 1999. The implementation is also based on the algorithms outlined in Digne, "An Analysis and Implementation of a
Parallel Ball Pivoting Algorithm", 2014. The surface reconstruction is done by rolling a ball with a given radius (cf. <code>radii</code>) over the point cloud, whenever the ball touches three points a triangle is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcd</td><td>defines the <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> from which the <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40" title="Triangle mesh contains vertices and triangles represented by the indices to the vertices.">TriangleMesh</a> surface is reconstructed. Has to contain normals. </td></tr>
    <tr><td class="paramname">radii</td><td>defines the radii of the ball that are used for the surface reconstruction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dacf0b62186999a6449f7332a1a5d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dacf0b62186999a6449f7332a1a5d54">&#9670;&nbsp;</a></span>CreateFromPointCloudPoisson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;, std::vector&lt; double &gt; &gt; open3d::geometry::TriangleMesh::CreateFromPointCloudPoisson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>pcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linear_fit</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that computes a triangle mesh from an oriented <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> pcd. This implements the Screened Poisson Reconstruction proposed in Kazhdan and Hoppe, "Screened Poisson Surface
Reconstruction", 2013. This function uses the original implementation by Kazhdan. See <a href="https://github.com/mkazhdan/PoissonRecon">https://github.com/mkazhdan/PoissonRecon</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcd</td><td><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> with normals and optionally colors. </td></tr>
    <tr><td class="paramname">depth</td><td>Maximum depth of the tree that will be used for surface reconstruction. Running at depth d corresponds to solving on a grid whose resolution is no larger than 2^d x 2^d x 2^d. Note that since the reconstructor adapts the octree to the sampling density, the specified reconstruction depth is only an upper bound. </td></tr>
    <tr><td class="paramname">width</td><td>Specifies the target width of the finest level octree cells. This parameter is ignored if depth is specified. </td></tr>
    <tr><td class="paramname">scale</td><td>Specifies the ratio between the diameter of the cube used for reconstruction and the diameter of the samples' bounding cube. </td></tr>
    <tr><td class="paramname">linear_fit</td><td>If true, the reconstructor use linear interpolation to estimate the positions of iso-vertices. </td></tr>
    <tr><td class="paramname">n_threads</td><td>Number of threads used for reconstruction. Set to -1 to automatically determine it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40" title="Triangle mesh contains vertices and triangles represented by the indices to the vertices.">TriangleMesh</a>, and per vertex density values that can be used to to trim the mesh. </dd></dl>

</div>
</div>
<a id="a1a4d59a4dc7706d6dc2497030ec983d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4d59a4dc7706d6dc2497030ec983d3">&#9670;&nbsp;</a></span>CreateIcosahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateIcosahedron </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_uv_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create an icosahedron mesh (trianglemeshfactory.cpp). The mesh centroid will be at (0,0,0) and </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>defines the distance from the center to the mesh vertices. </td></tr>
    <tr><td class="paramname">create_uv_map</td><td>add default UV map to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dec762c32c18d5d8a7f3259662a79cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dec762c32c18d5d8a7f3259662a79cb">&#9670;&nbsp;</a></span>CreateMobius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateMobius </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length_split</em> = <code>70</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width_split</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>twists</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flatness</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create a Mobius strip. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length_split</td><td>defines the number of segments along the Mobius strip. </td></tr>
    <tr><td class="paramname">width_split</td><td>defines the number of segments along the width of the Mobius strip.</td></tr>
    <tr><td class="paramname">twists</td><td>defines the number of twists of the strip. </td></tr>
    <tr><td class="paramname">radius</td><td>defines the radius of the Mobius strip. </td></tr>
    <tr><td class="paramname">flatness</td><td>controls the height of the strip. </td></tr>
    <tr><td class="paramname">width</td><td>controls the width of the Mobius strip. </td></tr>
    <tr><td class="paramname">scale</td><td>is used to scale the entire Mobius strip. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93952e5fd1b8c30d6a9205a2aab55da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93952e5fd1b8c30d6a9205a2aab55da6">&#9670;&nbsp;</a></span>CreateOctahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateOctahedron </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_uv_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create an octahedron mesh (trianglemeshfactory.cpp). the mesh centroid will be at (0,0,0) and <code>radius</code> defines the distance from the center to the mesh vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>defines the distance from centroid to mesh vetices. </td></tr>
    <tr><td class="paramname">create_uv_map</td><td>add default UV map to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc3d6d87ae64e86a20c90e134424ad04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3d6d87ae64e86a20c90e134424ad04">&#9670;&nbsp;</a></span>CreateSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateSphere </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_uv_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create a sphere mesh (TriangleMeshFactory.cpp) The sphere with radius will be centered at (0, 0, 0). Its axis is aligned with z-axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>defines radius of the sphere. </td></tr>
    <tr><td class="paramname">resolution</td><td>defines the resolution of the sphere. The longitudes will be split into resolution segments (i.e. there are resolution + 1 latitude lines including the north and south pole). The latitudes will be split into `2 * resolution segments (i.e. there are 2 * resolution longitude lines.) </td></tr>
    <tr><td class="paramname">create_uv_map</td><td>add default UV map to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7887ba3429f25dd882d4445cade594b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7887ba3429f25dd882d4445cade594b1">&#9670;&nbsp;</a></span>CreateTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateTetrahedron </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_uv_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create a tetrahedron mesh (trianglemeshfactory.cpp). the mesh centroid will be at (0,0,0) and <code>radius</code> defines the distance from the center to the mesh vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>defines the distance from centroid to mesh vetices. </td></tr>
    <tr><td class="paramname">create_uv_map</td><td>add default UV map to the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb9780fe9ca63211dbda959c5e7f4fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9780fe9ca63211dbda959c5e7f4fc0">&#9670;&nbsp;</a></span>CreateTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::CreateTorus </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>torus_radius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tube_radius</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radial_resolution</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tubular_resolution</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory function to create a torus mesh (TriangleMeshFactory.cpp) The torus will be centered at (0, 0, 0) and a radius of torus_radius. The tube of the torus will have a radius of tube_radius. The number of segments in radial and tubular direction are radial_resolution and tubular_resolution respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">torus_radius</td><td>defines the radius from the center of the torus to the center of the tube. </td></tr>
    <tr><td class="paramname">tube_radius</td><td>defines the radius of the torus tube. </td></tr>
    <tr><td class="paramname">radial_resolution</td><td>defines the he number of segments along the radial direction. </td></tr>
    <tr><td class="paramname">tubular_resolution</td><td>defines the number of segments along the tubular direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f547f8869c3094427a184c5fa2ac519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f547f8869c3094427a184c5fa2ac519">&#9670;&nbsp;</a></span>Crop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::Crop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou">AxisAlignedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to crop pointcloud into output pointcloud All points with coordinates outside the bounding box <code>bbox</code> are clipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>defines the input Axis Aligned Bounding Box. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69dcfcf69c0c9ad1cf8e6b1ac70ef525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dcfcf69c0c9ad1cf8e6b1ac70ef525">&#9670;&nbsp;</a></span>Crop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::Crop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to crop pointcloud into output pointcloud All points with coordinates outside the bounding box <code>bbox</code> are clipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>defines the input Oriented Bounding Box. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa52410a1d4ce4f94955d3a15130d7400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52410a1d4ce4f94955d3a15130d7400">&#9670;&nbsp;</a></span>DeformAsRigidAsPossible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::DeformAsRigidAsPossible </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_vertex_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a6f7e206d12e10f059ca530cd04c4d07a">DeformAsRigidAsPossibleEnergy</a>&#160;</td>
          <td class="paramname"><em>energy</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a6f7e206d12e10f059ca530cd04c4d07aa111552792d2df37209e4e9815a8524a8">DeformAsRigidAsPossibleEnergy::Spokes</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>smoothed_alpha</em> = <code>0.01</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deforms the mesh using the method by Sorkine and Alexa, "As-Rigid-As-Possible Surface Modeling", 2007. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint_vertex_indices</td><td>Indices of the triangle vertices that should be constrained by the vertex positions in constraint_vertex_positions. </td></tr>
    <tr><td class="paramname">constraint_vertex_positions</td><td>Vertex positions used for the constraints. </td></tr>
    <tr><td class="paramname">max_iter</td><td>maximum number of iterations to minimize energy functional. </td></tr>
    <tr><td class="paramname">energy</td><td>energy model that should be optimized </td></tr>
    <tr><td class="paramname">smoothed_alpha</td><td>alpha parameter of the smoothed ARAP model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The deformed <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40" title="Triangle mesh contains vertices and triangles represented by the indices to the vertices.">TriangleMesh</a> </dd></dl>

</div>
</div>
<a id="a601b6d4b19f75e1677af5d02e881e2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601b6d4b19f75e1677af5d02e881e2f3">&#9670;&nbsp;</a></span>EulerPoincareCharacteristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int open3d::geometry::TriangleMesh::EulerPoincareCharacteristic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that computes the Euler-Poincar characteristic, i.e., V + F - E, where V is the number of vertices, F is the number of triangles, and E is the number of edges. </p>

</div>
</div>
<a id="add35eb810d82fe03e39dfb3984ccdc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add35eb810d82fe03e39dfb3984ccdc96">&#9670;&nbsp;</a></span>FilterSharpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::FilterSharpen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>strength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a>&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">FilterScope::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to sharpen triangle mesh. </p>
<p>The output value ( \(v_o\)) is the input value ( \(v_i\)) plus strength times the input value minus the sum of he adjacent values. \(v_o = v_i + strength (v_i * |N| - \sum_{n \in N} v_n)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_iterations</td><td>defines the number of repetitions of this operation. </td></tr>
    <tr><td class="paramname">strength</td><td>- The strength of the filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2667927e4b8f4a62a635a1a2f490eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2667927e4b8f4a62a635a1a2f490eb8">&#9670;&nbsp;</a></span>FilterSmoothLaplacian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::FilterSmoothLaplacian </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a>&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">FilterScope::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to smooth triangle mesh using Laplacian. </p>
<p>\(v_o = v_i \cdot \lambda (\sum_{n \in N} w_n v_n - v_i)\), with \(v_i\) being the input value, \(v_o\) the output value, \(N\) is the set of adjacent neighbours, \(w_n\) is the weighting of the neighbour based on the inverse distance (closer neighbours have higher weight),</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_iterations</td><td>defines the number of repetitions of this operation. </td></tr>
    <tr><td class="paramname">lambda_filter</td><td>is the smoothing parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e48df0de848bf8137bc2fe5e1981e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e48df0de848bf8137bc2fe5e1981e90">&#9670;&nbsp;</a></span>FilterSmoothLaplacianHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::TriangleMesh::FilterSmoothLaplacianHelper </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_vertex_normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_vertex_colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::unordered_set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacency_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae15d30fa98b93c2ebc365380e3b3ebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15d30fa98b93c2ebc365380e3b3ebe8">&#9670;&nbsp;</a></span>FilterSmoothSimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::FilterSmoothSimple </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a>&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">FilterScope::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to smooth triangle mesh with simple neighbour average. </p>
<p>\(v_o = \frac{v_i + \sum_{n \in N} v_n)}{|N| + 1}\), with \(v_i\) being the input value, \(v_o\) the output value, and \(N\) is the set of adjacent neighbours.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_iterations</td><td>defines the number of repetitions of this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20ed81f5e181b8342239b3d7c5ec1a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ed81f5e181b8342239b3d7c5ec1a90">&#9670;&nbsp;</a></span>FilterSmoothTaubin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::FilterSmoothTaubin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda_filter</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu</em> = <code>-0.53</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89c">FilterScope</a>&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#af63b2a09012544530c370e7a3828c89cab1c94ca2fbc3e78fc30069c8d0f01680">FilterScope::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to smooth triangle mesh using method of Taubin, "Curve and Surface Smoothing Without Shrinkage", 1995. Applies in each iteration two times FilterSmoothLaplacian, first with lambda_filter and second with mu as smoothing parameter. This method avoids shrinkage of the triangle mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_iterations</td><td>defines the number of repetitions of this operation. </td></tr>
    <tr><td class="paramname">lambda_filter</td><td>is the filter parameter </td></tr>
    <tr><td class="paramname">mu</td><td>is the filter parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a652be3b74a111590f1f41d1bdad8ec14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652be3b74a111590f1f41d1bdad8ec14">&#9670;&nbsp;</a></span>GetEdgeToTrianglesMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Eigen::Vector2i, std::vector&lt; int &gt;, <a class="el" href="structopen3d_1_1utility_1_1hash__eigen.44c.d">utility::hash_eigen</a>&lt; Eigen::Vector2i &gt; &gt; open3d::geometry::TriangleMesh::GetEdgeToTrianglesMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that returns a map from edges (vertex0, vertex1) to the triangle indices the given edge belongs to. </p>

</div>
</div>
<a id="ade21d10ceaf1299ea18d192f0668dd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade21d10ceaf1299ea18d192f0668dd6f">&#9670;&nbsp;</a></span>GetEdgeToVerticesMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; Eigen::Vector2i, std::vector&lt; int &gt;, <a class="el" href="structopen3d_1_1utility_1_1hash__eigen.44c.d">utility::hash_eigen</a>&lt; Eigen::Vector2i &gt; &gt; open3d::geometry::TriangleMesh::GetEdgeToVerticesMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that returns a map from edges (vertex0, vertex1) to the vertex (vertex2) indices the given edge belongs to. </p>

</div>
</div>
<a id="a9e78ff8b6358ef24f5285e6bbc863e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78ff8b6358ef24f5285e6bbc863e61">&#9670;&nbsp;</a></span>GetNonManifoldEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Vector2i &gt; open3d::geometry::TriangleMesh::GetNonManifoldEdges </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_boundary_edges</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that returns the non-manifold edges of the triangle mesh. If</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allow_boundary_edges</td><td>is set to false, then also boundary edges are returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af589b9fdfa2885c95a15977dd0874a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af589b9fdfa2885c95a15977dd0874a24">&#9670;&nbsp;</a></span>GetNonManifoldVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; open3d::geometry::TriangleMesh::GetNonManifoldVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that returns a list of non-manifold vertex indices. A vertex is manifold if its star is edgemanifold and edgeconnected. (Two or more faces connected only by a vertex and not by an edge.) </p>

</div>
</div>
<a id="a52db96d3c6e509bac5a2ceecc9d8c1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52db96d3c6e509bac5a2ceecc9d8c1cc">&#9670;&nbsp;</a></span>GetOrderedEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::Vector2i open3d::geometry::TriangleMesh::GetOrderedEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vidx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vidx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to get an edge with ordered vertex indices. </p>

</div>
</div>
<a id="ad5ce14c4c8ab19d08a179d58533c94bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ce14c4c8ab19d08a179d58533c94bd">&#9670;&nbsp;</a></span>GetOrderedTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::Vector3i open3d::geometry::TriangleMesh::GetOrderedTriangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vidx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vidx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vidx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2895032074c34dd9375e3d3eecc81718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2895032074c34dd9375e3d3eecc81718">&#9670;&nbsp;</a></span>GetSelfIntersectingTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Vector2i &gt; open3d::geometry::TriangleMesh::GetSelfIntersectingTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that returns a list of triangles that are intersecting the mesh. </p>

</div>
</div>
<a id="af3e5e2bcce2ae099a91bec61692b191a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e5e2bcce2ae099a91bec61692b191a">&#9670;&nbsp;</a></span>GetSurfaceArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double open3d::geometry::TriangleMesh::GetSurfaceArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that computes the surface area of the mesh, i.e. the sum of the individual triangle surfaces. </p>

</div>
</div>
<a id="a4f5f651b67b968269a7466875a9e69aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5f651b67b968269a7466875a9e69aa">&#9670;&nbsp;</a></span>GetSurfaceArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double open3d::geometry::TriangleMesh::GetSurfaceArea </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangle_areas</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that computes the surface area of the mesh, i.e. the sum of the individual triangle surfaces. </p>

</div>
</div>
<a id="ac91258e5fa363de720104f55d86ab793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91258e5fa363de720104f55d86ab793">&#9670;&nbsp;</a></span>GetTriangleArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double open3d::geometry::TriangleMesh::GetTriangleArea </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triangle_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that computes the area of a mesh triangle identified by the triangle index </p>

</div>
</div>
<a id="ae0fdc61d44a6569a0b66afa3f4a10229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fdc61d44a6569a0b66afa3f4a10229">&#9670;&nbsp;</a></span>GetTrianglePlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector4d open3d::geometry::TriangleMesh::GetTrianglePlane </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triangle_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that computes the plane equation of a mesh triangle identified by the triangle index. </p>

</div>
</div>
<a id="a18a4bfec706044d1c97edd2df30d9e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a4bfec706044d1c97edd2df30d9e98">&#9670;&nbsp;</a></span>GetVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double open3d::geometry::TriangleMesh::GetVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that computes the volume of the mesh, under the condition that it is watertight and orientable. See Zhang and Chen, "Efficient feature extraction for 2D/3D objects in
mesh representation", 2001. </p>

</div>
</div>
<a id="ac5109ef64ef2e20467e1560935e8ccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5109ef64ef2e20467e1560935e8ccfb">&#9670;&nbsp;</a></span>HasAdjacencyList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::HasAdjacencyList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the mesh contains adjacency normals. </p>

</div>
</div>
<a id="afc871b155b0282561652ab8db5ac5cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc871b155b0282561652ab8db5ac5cc0">&#9670;&nbsp;</a></span>HasMaterials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::HasMaterials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ec00b3beae972048fa4a3e1f711b548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec00b3beae972048fa4a3e1f711b548">&#9670;&nbsp;</a></span>HasTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::HasTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the mesh has texture. </p>

</div>
</div>
<a id="a66abc01744c37d5eeefe0d7b6d3d8c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66abc01744c37d5eeefe0d7b6d3d8c8e">&#9670;&nbsp;</a></span>HasTriangleMaterialIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::HasTriangleMaterialIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6b745727a70875ba9bd3e8b706c131d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b745727a70875ba9bd3e8b706c131d">&#9670;&nbsp;</a></span>HasTriangleNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::HasTriangleNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the mesh contains triangle normals. </p>

</div>
</div>
<a id="a46f81b23e6538ab3d984824e93fb6e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f81b23e6538ab3d984824e93fb6e8c">&#9670;&nbsp;</a></span>HasTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::HasTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the mesh contains triangles. </p>

</div>
</div>
<a id="a84d50d05a4904038823231aa8252c4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d50d05a4904038823231aa8252c4d2">&#9670;&nbsp;</a></span>HasTriangleUvs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::HasTriangleUvs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0597075686ecda8953d33f3cbe57c385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0597075686ecda8953d33f3cbe57c385">&#9670;&nbsp;</a></span>IsBoundingBoxIntersecting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::IsBoundingBoxIntersecting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that tests if the bounding boxes of the triangle meshes are intersecting. </p>

</div>
</div>
<a id="a41b5ac2ab386ac85bfe056f0bf22bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b5ac2ab386ac85bfe056f0bf22bab9">&#9670;&nbsp;</a></span>IsEdgeManifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::IsEdgeManifold </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_boundary_edges</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that checks if the given triangle mesh is edge-manifold. A mesh is edge-manifold if each edge is bounding either one or two triangles. If allow_boundary_edges is set to false, then this function returns false if there exists boundary edges. </p>

</div>
</div>
<a id="ac5abd918be627b6397bd8c149a0b0e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5abd918be627b6397bd8c149a0b0e47">&#9670;&nbsp;</a></span>IsIntersecting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::IsIntersecting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that tests if the triangle mesh intersects another triangle mesh. Tests each triangle against each other triangle. </p>

</div>
</div>
<a id="a7c336042cff2009101c6611a518abadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c336042cff2009101c6611a518abadd">&#9670;&nbsp;</a></span>IsOrientable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::IsOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that tests if the given triangle mesh is orientable, i.e. the triangles can be oriented in such a way that all normals point towards the outside. </p>

</div>
</div>
<a id="ae5ee35dd23c4a786be63e3da3f305062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ee35dd23c4a786be63e3da3f305062">&#9670;&nbsp;</a></span>IsSelfIntersecting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::IsSelfIntersecting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that tests if the triangle mesh is self-intersecting. Tests each triangle pair for intersection. </p>

</div>
</div>
<a id="a292f2d129637b15598fbbeec0b6b57e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292f2d129637b15598fbbeec0b6b57e1">&#9670;&nbsp;</a></span>IsVertexManifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::IsVertexManifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that checks if all vertices in the triangle mesh are manifold. A vertex is manifold if its star is edgemanifold and edgeconnected. (Two or more faces connected only by a vertex and not by an edge.) </p>

</div>
</div>
<a id="abbf57ddb4e13f2ceb33e6785cc864a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf57ddb4e13f2ceb33e6785cc864a46">&#9670;&nbsp;</a></span>IsWatertight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::IsWatertight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that tests if the given triangle mesh is watertight by checking if it is vertex manifold and edge-manifold with no boundary edges, but not self-intersecting. </p>

</div>
</div>
<a id="a51a42d9e899de697300c602bc8ad9251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a42d9e899de697300c602bc8ad9251">&#9670;&nbsp;</a></span>MergeCloseVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::MergeCloseVertices </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that will merge close by vertices to a single one. The vertex position, normal and color will be the average of the vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eps</td><td>defines the maximum distance of close by vertices. This function might help to close triangle soups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac701002ed8fbbf5ec30c261338794501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac701002ed8fbbf5ec30c261338794501">&#9670;&nbsp;</a></span>NormalizeNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a>&amp; open3d::geometry::TriangleMesh::NormalizeNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize both triangle normals and vertex normals to length 1. </p>

</div>
</div>
<a id="ae24042df732dd8cd2b8272c7302a1154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24042df732dd8cd2b8272c7302a1154">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> open3d::geometry::TriangleMesh::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb4bc21a1a623c719892967d996e314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb4bc21a1a623c719892967d996e314">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a804035e82e0a721c23321c63d1697cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804035e82e0a721c23321c63d1697cfc">&#9670;&nbsp;</a></span>OrientTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::TriangleMesh::OrientTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the mesh is orientable then this function rearranges the triangles such that all normals point towards the outside/inside. </p>

</div>
</div>
<a id="aa49a80312d128fbfa70eeb8525cc24ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49a80312d128fbfa70eeb8525cc24ec">&#9670;&nbsp;</a></span>RemoveDegenerateTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::RemoveDegenerateTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that removes degenerate triangles, i.e., triangles that reference a single vertex multiple times in a single triangle. </p>
<p>They are usually the product of removing duplicated vertices. </p>

</div>
</div>
<a id="a9514b3c8075e0066fd041a853f23f0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9514b3c8075e0066fd041a853f23f0b7">&#9670;&nbsp;</a></span>RemoveDuplicatedTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::RemoveDuplicatedTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that removes duplicated triangles, i.e., removes triangles that reference the same three vertices and have the same orientation. </p>

</div>
</div>
<a id="a34f090ed23456400c4192992d199bdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f090ed23456400c4192992d199bdad">&#9670;&nbsp;</a></span>RemoveDuplicatedVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::RemoveDuplicatedVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that removes duplicated verties, i.e., vertices that have identical coordinates. </p>

</div>
</div>
<a id="a0a667e04a73010d302eb60af0ea1cbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a667e04a73010d302eb60af0ea1cbf9">&#9670;&nbsp;</a></span>RemoveNonManifoldEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::RemoveNonManifoldEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that removes all non-manifold edges, by successively deleting triangles with the smallest surface area adjacent to the non-manifold edge until the number of adjacent triangles to the edge is <code>&lt;= 2</code>. </p>

</div>
</div>
<a id="a41c51a951a1ee0110a48b2ef7757b43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c51a951a1ee0110a48b2ef7757b43c">&#9670;&nbsp;</a></span>RemoveTrianglesByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::TriangleMesh::RemoveTrianglesByIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangle_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes the triangles with index in <code>triangle_indices</code>. Call <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aab1782c3de14f8553de0a946b8900bce">RemoveUnreferencedVertices</a> to clean up vertices afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangle_indices</td><td>Indices of the triangles that should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af88fb06b3e541042a8f9f29e1c0e64de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88fb06b3e541042a8f9f29e1c0e64de">&#9670;&nbsp;</a></span>RemoveTrianglesByMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::TriangleMesh::RemoveTrianglesByMask </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangle_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes the triangles that are masked in <code>triangle_mask</code>. Call <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aab1782c3de14f8553de0a946b8900bce">RemoveUnreferencedVertices</a> to clean up vertices afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangle_mask</td><td>Mask of triangles that should be removed. Should have same size as <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a7dcddd5784eaa2efedfa5e274aa50e3e">triangles_</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab1782c3de14f8553de0a946b8900bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1782c3de14f8553de0a946b8900bce">&#9670;&nbsp;</a></span>RemoveUnreferencedVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::RemoveUnreferencedVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes vertices from the triangle mesh that are not referenced in any triangle of the mesh. </p>

</div>
</div>
<a id="a4b3d0d742b2d0fd200b40b852890f5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3d0d742b2d0fd200b40b852890f5ff">&#9670;&nbsp;</a></span>RemoveVerticesByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::TriangleMesh::RemoveVerticesByIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes the vertices with index in <code>vertex_indices</code>. Note that also all triangles associated with the vertices are removeds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_indices</td><td>Indices of the vertices that should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a685b36e7ec28d4dd6655f5a2e72802ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685b36e7ec28d4dd6655f5a2e72802ab">&#9670;&nbsp;</a></span>RemoveVerticesByMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::TriangleMesh::RemoveVerticesByMask </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes the vertices that are masked in <code>vertex_mask</code>. Note that also all triangles associated with the vertices are removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_mask</td><td>Mask of vertices that should be removed. Should have same size as <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a004aeef2268433b07feb4ee32e560292">vertices_</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a039c1d00b33423cb5371d6ba157557a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039c1d00b33423cb5371d6ba157557a1">&#9670;&nbsp;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::Rotate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply rotation to the geometry coordinates and normals. Given a rotation matrix \(R\), and center \(c\), a given point \(p\) is transformed according to \(R (p - c) + c\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3x3 rotation matrix </td></tr>
    <tr><td class="paramname">center</td><td>Rotation center that is used for the rotation. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a3fa1a882c26e318cc9d03b688e91a4f0">open3d::geometry::MeshBase</a>.</p>

</div>
</div>
<a id="a28e1b29798f6e04d80de9e2638bf1c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e1b29798f6e04d80de9e2638bf1c96">&#9670;&nbsp;</a></span>SamplePointsPoissonDisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::TriangleMesh::SamplePointsPoissonDisk </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>init_factor</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td>
          <td class="paramname"><em>pcl_init</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_triangle_normal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to sample points from the mesh with Possion disk, based on the method presented in Yuksel, "Sample Elimination for Generating Poisson
Disk Sample Sets", EUROGRAPHICS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_points</td><td>Number of points that should be sampled. </td></tr>
    <tr><td class="paramname">init_factor</td><td>Factor for the initial uniformly sampled <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a>. This init <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> is used for sample elimination. </td></tr>
    <tr><td class="paramname">pcl_init</td><td>Initial <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> that is used for sample elimination. If this parameter is provided the init_factor is ignored. </td></tr>
    <tr><td class="paramname">use_triangle_normal</td><td>If True assigns the triangle normals instead of the interpolated vertex normals to the returned points. The triangle normals will be computed and added to the mesh if necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2536a9b85f8060c7468da8378d696057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2536a9b85f8060c7468da8378d696057">&#9670;&nbsp;</a></span>SamplePointsUniformly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::TriangleMesh::SamplePointsUniformly </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_triangle_normal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to sample points uniformly from the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_points</td><td>points uniformly from the mesh. </td></tr>
    <tr><td class="paramname">use_triangle_normal</td><td>Set to true to assign the triangle normals to the returned points instead of the interpolated vertex normals. The triangle normals will be computed and added to the mesh if necessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1568965f2cb441cf6439b7ee57cd2929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1568965f2cb441cf6439b7ee57cd2929">&#9670;&nbsp;</a></span>SamplePointsUniformlyImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::TriangleMesh::SamplePointsUniformlyImpl </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangle_areas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>surface_area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_triangle_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to sample</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_points</td><td>points uniformly from the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64a0a850d21ec4d0fa297787ae28868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a0a850d21ec4d0fa297787ae28868c">&#9670;&nbsp;</a></span>SelectByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::SelectByIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to select points from <code>input</code> <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40" title="Triangle mesh contains vertices and triangles represented by the indices to the vertices.">TriangleMesh</a> into output <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40" title="Triangle mesh contains vertices and triangles represented by the indices to the vertices.">TriangleMesh</a> Vertices with indices in <code>indices</code> are selected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>defines Indices of vertices to be selected. </td></tr>
    <tr><td class="paramname">cleanup</td><td>If true it automatically calls <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a34f090ed23456400c4192992d199bdad" title="Function that removes duplicated verties, i.e., vertices that have identical coordinates.">TriangleMesh::RemoveDuplicatedVertices</a>, <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#a9514b3c8075e0066fd041a853f23f0b7" title="Function that removes duplicated triangles, i.e., removes triangles that reference the same three ver...">TriangleMesh::RemoveDuplicatedTriangles</a>, <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aab1782c3de14f8553de0a946b8900bce" title="This function removes vertices from the triangle mesh that are not referenced in any triangle of the ...">TriangleMesh::RemoveUnreferencedVertices</a>, and <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40#aa49a80312d128fbfa70eeb8525cc24ec" title="Function that removes degenerate triangles, i.e., triangles that reference a single vertex multiple t...">TriangleMesh::RemoveDegenerateTriangles</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2a96a4bc20b515c111e3e756d7e4d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a96a4bc20b515c111e3e756d7e4d1e">&#9670;&nbsp;</a></span>SimplifyQuadricDecimation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::SimplifyQuadricDecimation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_number_of_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maximum_error</em> = <code>std::numeric_limits&lt;double&gt;::infinity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>boundary_weight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to simplify mesh using <a class="el" href="classopen3d_1_1geometry_1_1_quadric.424.dela">Quadric</a> Error Metric Decimation by Garland and Heckbert. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_number_of_triangles</td><td>defines the number of triangles that the simplified mesh should have. It is not guaranteed that this number will be reached. </td></tr>
    <tr><td class="paramname">maximum_error</td><td>defines the maximum error where a vertex is allowed to be merged </td></tr>
    <tr><td class="paramname">boundary_weight</td><td>a weight applied to edge vertices used to preserve boundaries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dd07290669043643698e660d9e670ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd07290669043643698e660d9e670ce">&#9670;&nbsp;</a></span>SimplifyVertexClustering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::SimplifyVertexClustering </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a84f9db88a4d0d23d755136ddfa7e6bd7">SimplificationContraction</a>&#160;</td>
          <td class="paramname"><em>contraction</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a84f9db88a4d0d23d755136ddfa7e6bd7ab1897515d548a960afe49ecf66a29021">SimplificationContraction::Average</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to simplify mesh using Vertex Clustering. The result can be a non-manifold mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voxel_size</td><td>- The size of the voxel within vertices are pooled. </td></tr>
    <tr><td class="paramname">contraction</td><td>- Method to aggregate vertex information. Average computes a simple average, <a class="el" href="classopen3d_1_1geometry_1_1_quadric.424.dela">Quadric</a> minimizes the distance to the adjacent planes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19c4ef9c1c9229213ecd05a15845d4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c4ef9c1c9229213ecd05a15845d4d4">&#9670;&nbsp;</a></span>SubdivideLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::SubdivideLoop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_iterations</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to subdivide triangle mesh using Loop's scheme. Cf. Charles T. Loop, "Smooth subdivision surfaces based on triangles",</p><ol type="1">
<li>Each triangle is subdivided into four triangles per iteration. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_iterations</td><td>defines a single iteration splits each triangle into four triangles that cover the same surface. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="a10c0abffb559c91c5f4f5d50b8a2c1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c0abffb559c91c5f4f5d50b8a2c1a4">&#9670;&nbsp;</a></span>SubdivideMidpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt; open3d::geometry::TriangleMesh::SubdivideMidpoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_of_iterations</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to subdivide triangle mesh using the simple midpoint algorithm. Each triangle is subdivided into four triangles per iteration and the new vertices lie on the midpoint of the triangle edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number_of_iterations</td><td>defines a single iteration splits each triangle into four triangles that cover the same surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76a6954168e7b35c70cdcd0f98086783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a6954168e7b35c70cdcd0f98086783">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &amp; open3d::geometry::TriangleMesh::Transform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix4d &amp;&#160;</td>
          <td class="paramname"><em>transformation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply transformation (4x4 matrix) to the geometry coordinates. </p>

<p>Reimplemented from <a class="el" href="classopen3d_1_1geometry_1_1_mesh_base.412.de#a660867be2560d5690b6837dea7ccfac8">open3d::geometry::MeshBase</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a37984016ded7bbceb893c5dba0e8b6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37984016ded7bbceb893c5dba0e8b6c8">&#9670;&nbsp;</a></span>adjacency_list_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unordered_set&lt;int&gt; &gt; open3d::geometry::TriangleMesh::adjacency_list_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The set adjacency_list[i] contains the indices of adjacent vertices of vertex i. </p>

</div>
</div>
<a id="aa415bc74025604428db8b7d2f97b5d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa415bc74025604428db8b7d2f97b5d8d">&#9670;&nbsp;</a></span>materials_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, <a class="el" href="structopen3d_1_1geometry_1_1_triangle_mesh_1">Material</a>&gt; open3d::geometry::TriangleMesh::materials_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0babf96deb5056e1b36b5ee3517d0a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0babf96deb5056e1b36b5ee3517d0a80">&#9670;&nbsp;</a></span>textures_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classopen3d_1_1geometry_1_1_image.406.delaye">Image</a>&gt; open3d::geometry::TriangleMesh::textures_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Textures of the image. </p>

</div>
</div>
<a id="ade007ba5e10cb3c60c9d7f4d2e8f2611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade007ba5e10cb3c60c9d7f4d2e8f2611">&#9670;&nbsp;</a></span>triangle_material_ids_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; open3d::geometry::TriangleMesh::triangle_material_ids_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of material ids. </p>

</div>
</div>
<a id="a90341a2a76590e3a9ce4d507d3a2285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90341a2a76590e3a9ce4d507d3a2285c">&#9670;&nbsp;</a></span>triangle_normals_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; open3d::geometry::TriangleMesh::triangle_normals_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangle normals. </p>

</div>
</div>
<a id="a6da74c05d87cfef5ca025b39d8e6efc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da74c05d87cfef5ca025b39d8e6efc3">&#9670;&nbsp;</a></span>triangle_uvs_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector2d&gt; open3d::geometry::TriangleMesh::triangle_uvs_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of uv coordinates per triangle. </p>

</div>
</div>
<a id="a7dcddd5784eaa2efedfa5e274aa50e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcddd5784eaa2efedfa5e274aa50e3e">&#9670;&nbsp;</a></span>triangles_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3i&gt; open3d::geometry::TriangleMesh::triangles_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of triangles denoted by the index of points forming the triangle. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="geometry_2_triangle_mesh_8h_source.50f.delay">TriangleMesh.h (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_surface_reconstruction_alpha_shape_8cpp.615">SurfaceReconstructionAlphaShape.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_surface_reconstruction_ball_pivoting_8cpp.6">SurfaceReconstructionBallPivoting.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_surface_reconstruction_poisson_8cpp.617.del">SurfaceReconstructionPoisson.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="geometry_2_triangle_mesh_8cpp.html">TriangleMesh.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_triangle_mesh_deformation_8cpp.html">TriangleMeshDeformation.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="geometry_2_triangle_mesh_factory_8cpp.61a.de">TriangleMeshFactory.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_triangle_mesh_simplification_8cpp.61b.delay">TriangleMeshSimplification.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_triangle_mesh_subdivide_8cpp.html">TriangleMeshSubdivide.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/classopen3d_1_1geometry_1_1_triangle_mesh.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:55:59 GMT -->
</html>
