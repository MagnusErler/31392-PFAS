<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/namespaceopen3d_1_1core_1_1nns_1_1impl.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:59:52 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open3D (C++ API): open3d::core::nns::impl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.html", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="../../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3TQPKGV6Z3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-3TQPKGV6Z3');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="open3d_logo.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open3D (C++ API)
   &#160;<span id="projectnumber">0.17.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.html','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopen3d.html">open3d</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1core_1_1nns.html">nns</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1core_1_1nns_1_1impl.546.d">impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">open3d::core::nns::impl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96f4b6d423c4bbf46d59c408fbaedbca"><td class="memTemplParams" colspan="2">template&lt;class T , class TIndex , class OUTPUT_ALLOCATOR &gt; </td></tr>
<tr class="memitem:a96f4b6d423c4bbf46d59c408fbaedbca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1core_1_1nns_1_1impl.546.d#a96f4b6d423c4bbf46d59c408fbaedbca">FixedRadiusSearchCPU</a> (int64_t *query_neighbors_row_splits, const size_t num_points, const T *const <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, const size_t num_queries, const T *const queries, const T radius, const size_t points_row_splits_size, const int64_t *const points_row_splits, const size_t queries_row_splits_size, const int64_t *const queries_row_splits, const uint32_t *const hash_table_splits, const size_t hash_table_cell_splits_size, const uint32_t *const hash_table_cell_splits, const uint32_t *const hash_table_index, const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a> metric, const bool ignore_query_point, const bool return_distances, OUTPUT_ALLOCATOR &amp;output_allocator)</td></tr>
<tr class="separator:a96f4b6d423c4bbf46d59c408fbaedbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339644199ea1f06d0ddee2f690831970"><td class="memTemplParams" colspan="2">template&lt;class T , class TIndex &gt; </td></tr>
<tr class="memitem:a339644199ea1f06d0ddee2f690831970"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structopen3d_1_1core_1_1nns_1_1_nano_flann_i-2">NanoFlannIndexHolderBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1core_1_1nns_1_1impl.546.d#a339644199ea1f06d0ddee2f690831970">BuildKdTree</a> (size_t num_points, const T *const <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, size_t dimension, const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a> metric)</td></tr>
<tr class="separator:a339644199ea1f06d0ddee2f690831970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69df14bdcf3d793e9afd38d42485699"><td class="memTemplParams" colspan="2">template&lt;class T , class TIndex , class OUTPUT_ALLOCATOR &gt; </td></tr>
<tr class="memitem:ae69df14bdcf3d793e9afd38d42485699"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1core_1_1nns_1_1impl.546.d#ae69df14bdcf3d793e9afd38d42485699">KnnSearchCPU</a> (<a class="el" href="structopen3d_1_1core_1_1nns_1_1_nano_flann_i-2">NanoFlannIndexHolderBase</a> *holder, int64_t *query_neighbors_row_splits, size_t num_points, const T *const <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, size_t num_queries, const T *const queries, const size_t dimension, int knn, const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a> metric, bool ignore_query_point, bool return_distances, OUTPUT_ALLOCATOR &amp;output_allocator)</td></tr>
<tr class="separator:ae69df14bdcf3d793e9afd38d42485699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bac913eacce9b60f4a9f1668d98ee5"><td class="memTemplParams" colspan="2">template&lt;class T , class TIndex , class OUTPUT_ALLOCATOR &gt; </td></tr>
<tr class="memitem:a67bac913eacce9b60f4a9f1668d98ee5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1core_1_1nns_1_1impl.546.d#a67bac913eacce9b60f4a9f1668d98ee5">RadiusSearchCPU</a> (<a class="el" href="structopen3d_1_1core_1_1nns_1_1_nano_flann_i-2">NanoFlannIndexHolderBase</a> *holder, int64_t *query_neighbors_row_splits, size_t num_points, const T *const <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, size_t num_queries, const T *const queries, const size_t dimension, const T *const radii, const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a> metric, bool ignore_query_point, bool return_distances, bool normalize_distances, bool sort, OUTPUT_ALLOCATOR &amp;output_allocator)</td></tr>
<tr class="separator:a67bac913eacce9b60f4a9f1668d98ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbec822404a44662879add736fa872a8"><td class="memTemplParams" colspan="2">template&lt;class T , class TIndex , class OUTPUT_ALLOCATOR &gt; </td></tr>
<tr class="memitem:abbec822404a44662879add736fa872a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopen3d_1_1core_1_1nns_1_1impl.546.d#abbec822404a44662879add736fa872a8">HybridSearchCPU</a> (<a class="el" href="structopen3d_1_1core_1_1nns_1_1_nano_flann_i-2">NanoFlannIndexHolderBase</a> *holder, size_t num_points, const T *const <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, size_t num_queries, const T *const queries, const size_t dimension, const T radius, const int max_knn, const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a> metric, bool ignore_query_point, bool return_distances, OUTPUT_ALLOCATOR &amp;output_allocator)</td></tr>
<tr class="separator:abbec822404a44662879add736fa872a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a339644199ea1f06d0ddee2f690831970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339644199ea1f06d0ddee2f690831970">&#9670;&nbsp;</a></span>BuildKdTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structopen3d_1_1core_1_1nns_1_1_nano_flann_i-2">NanoFlannIndexHolderBase</a>&gt; open3d::core::nns::impl::BuildKdTree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a>&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build KD Tree. This function build a KDTree for given dataset points.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating-point data type for the point positions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of points.</td></tr>
    <tr><td class="paramname">points</td><td>Array with the point positions.</td></tr>
    <tr><td class="paramname">dimension</td><td>The dimension of points.</td></tr>
    <tr><td class="paramname">metric</td><td>Onf of L1, L2. Defines the distance metric for the search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96f4b6d423c4bbf46d59c408fbaedbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f4b6d423c4bbf46d59c408fbaedbca">&#9670;&nbsp;</a></span>FixedRadiusSearchCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TIndex , class OUTPUT_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::core::nns::impl::FixedRadiusSearchCPU </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>query_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>points_row_splits_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const&#160;</td>
          <td class="paramname"><em>points_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>queries_row_splits_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *const&#160;</td>
          <td class="paramname"><em>queries_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *const&#160;</td>
          <td class="paramname"><em>hash_table_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>hash_table_cell_splits_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *const&#160;</td>
          <td class="paramname"><em>hash_table_cell_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *const&#160;</td>
          <td class="paramname"><em>hash_table_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a>&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_query_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>return_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUTPUT_ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>output_allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fixed radius search. This function computes a list of neighbor indices for each query point. The lists are stored linearly and an exclusive prefix sum defines the start and end of list in the array. In addition the function optionally can return the distances for each neighbor in the same format as the indices to the neighbors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating-point data type for the point positions.</td></tr>
    <tr><td class="paramname">OUTPUT_ALLOCATOR</td><td>Type of the output_allocator. See <code>output_allocator</code> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query_neighbors_row_splits</td><td>This is the output pointer for the prefix sum. The length of this array is <code>num_queries</code> + 1.</td></tr>
    <tr><td class="paramname">num_points</td><td>The number of points.</td></tr>
    <tr><td class="paramname">points</td><td>Array with the 3D point positions. This must be the array that was used for building the spatial hash table.</td></tr>
    <tr><td class="paramname">num_queries</td><td>The number of query points.</td></tr>
    <tr><td class="paramname">queries</td><td>Array with the 3D query positions. This may be the same array as <code>points</code>.</td></tr>
    <tr><td class="paramname">radius</td><td>The search radius.</td></tr>
    <tr><td class="paramname">points_row_splits_size</td><td>The size of the points_row_splits array. The size of the array is batch_size+1.</td></tr>
    <tr><td class="paramname">points_row_splits</td><td>Defines the start and end of the points in each batch item. The size of the array is batch_size+1. If there is only 1 batch item then this array is [0, num_points]</td></tr>
    <tr><td class="paramname">queries_row_splits_size</td><td>The size of the queries_row_splits array. The size of the array is batch_size+1.</td></tr>
    <tr><td class="paramname">queries_row_splits</td><td>Defines the start and end of the queries in each batch item. The size of the array is batch_size+1. If there is only 1 batch item then this array is [0, num_queries]</td></tr>
    <tr><td class="paramname">hash_table_splits</td><td>Array defining the start and end the hash table for each batch item. This is [0, number of cells] if there is only 1 batch item or [0, hash_table_cell_splits_size-1] which is the same.</td></tr>
    <tr><td class="paramname">hash_table_cell_splits_size</td><td>This is the length of the hash_table_cell_splits array.</td></tr>
    <tr><td class="paramname">hash_table_cell_splits</td><td>This is an output of the function BuildSpatialHashTableCPU. The row splits array describing the start and end of each cell.</td></tr>
    <tr><td class="paramname">hash_table_index</td><td>This is an output of the function BuildSpatialHashTableCPU. This is array storing the values of the hash table, which are the indices to the points. The size of the array must be equal to the number of points.</td></tr>
    <tr><td class="paramname">metric</td><td>One of L1, L2, Linf. Defines the distance metric for the search.</td></tr>
    <tr><td class="paramname">ignore_query_point</td><td>If true then points with the same position as the query point will be ignored.</td></tr>
    <tr><td class="paramname">return_distances</td><td>If true then this function will return the distances for each neighbor to its query point in the same format as the indices. Note that for the L2 metric the squared distances will be returned!!</td></tr>
    <tr><td class="paramname">output_allocator</td><td>An object that implements functions for allocating the output arrays. The object must implement functions AllocIndices(int64_t** ptr, size_t size) and AllocDistances(T** ptr, size_t size). Both functions should allocate memory and return a pointer to that memory in ptr. Argument size specifies the size of the array as the number of elements. Both functions must accept the argument size==0. In this case ptr does not need to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbec822404a44662879add736fa872a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbec822404a44662879add736fa872a8">&#9670;&nbsp;</a></span>HybridSearchCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TIndex , class OUTPUT_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::core::nns::impl::HybridSearchCPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopen3d_1_1core_1_1nns_1_1_nano_flann_i-2">NanoFlannIndexHolderBase</a> *&#160;</td>
          <td class="paramname"><em>holder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_knn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a>&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_query_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUTPUT_ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>output_allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hybrid search. This function computes a list of neighbor indices for each query point. The lists are stored linearly and an exclusive prefix sum defines the start and end of each list in the array. In addition the function optionally can return the distances for each neighbor in the same format as the indices to the neighbors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating-point data type for the point positions.</td></tr>
    <tr><td class="paramname">OUTPUT_ALLOCATOR</td><td>Type of the output_allocator. See <code>output_allocator</code> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">holder</td><td>The pointer that point to NanFlannIndexHolder that is built with BuildKdTree function.</td></tr>
    <tr><td class="paramname">num_points</td><td>The number of points.</td></tr>
    <tr><td class="paramname">points</td><td>Array with the point positions. This may be the same array as <code>queries</code>.</td></tr>
    <tr><td class="paramname">num_queries</td><td>The number of query points.</td></tr>
    <tr><td class="paramname">queries</td><td>Array with the query positions. This may be the same array as <code>points</code>.</td></tr>
    <tr><td class="paramname">dimension</td><td>The dimension of <code>points</code> and <code>queries</code>.</td></tr>
    <tr><td class="paramname">radius</td><td>The radius value that defines the neighbors region.</td></tr>
    <tr><td class="paramname">max_knn</td><td>The maximum number of neighbors to search.</td></tr>
    <tr><td class="paramname">metric</td><td>One of L1, L2. Defines the distance metric for the search.</td></tr>
    <tr><td class="paramname">ignore_query_point</td><td>If true then points with the same position as the query point will be ignored.</td></tr>
    <tr><td class="paramname">return_distances</td><td>If true then this function will return the distances for each neighbor to its query point in the same format as the indices. Note that for the L2 metric the squared distances will be returned!!</td></tr>
    <tr><td class="paramname">output_allocator</td><td>An object that implements functions for allocating the output arrays. The object must implement functions AllocIndices(int32_t** ptr, size_t size) and AllocDistances(T** ptr, size_t size). Both functions should allocate memory and return a pointer to that memory in ptr. Argument size specifies the size of the array as the number of elements. Both functions must accept the argument size==0. In this case ptr does not need to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae69df14bdcf3d793e9afd38d42485699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69df14bdcf3d793e9afd38d42485699">&#9670;&nbsp;</a></span>KnnSearchCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TIndex , class OUTPUT_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::core::nns::impl::KnnSearchCPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopen3d_1_1core_1_1nns_1_1_nano_flann_i-2">NanoFlannIndexHolderBase</a> *&#160;</td>
          <td class="paramname"><em>holder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>query_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>knn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a>&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_query_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUTPUT_ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>output_allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>KNN search. This function computes a list of neighbor indices for each query point. The lists are stored linearly and an exclusive prefix sum defines the start and end of each list in the array. In addition the function optionally can return the distances for each neighbor in the same format as the indices to the neighbors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating-point data type for the point positions.</td></tr>
    <tr><td class="paramname">OUTPUT_ALLOCATOR</td><td>Type of the output_allocator. See <code>output_allocator</code> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">holder</td><td>The pointer that point to NanFlannIndexHolder that is built with BuildKdTree function.</td></tr>
    <tr><td class="paramname">query_neighbors_row_splits</td><td>This is the output pointer for the prefix sum. The length of this array is <code>num_queries</code> + 1.</td></tr>
    <tr><td class="paramname">num_points</td><td>The number of points.</td></tr>
    <tr><td class="paramname">points</td><td>Array with the point positions. This may be the same array as <code>queries</code>.</td></tr>
    <tr><td class="paramname">num_queries</td><td>The number of query points.</td></tr>
    <tr><td class="paramname">queries</td><td>Array with the query positions. This may be the same array as <code>points</code>.</td></tr>
    <tr><td class="paramname">dimension</td><td>The dimension of <code>points</code> and <code>queries</code>.</td></tr>
    <tr><td class="paramname">knn</td><td>The number of neighbors to search.</td></tr>
    <tr><td class="paramname">metric</td><td>One of L1, L2. Defines the distance metric for the search.</td></tr>
    <tr><td class="paramname">ignore_query_point</td><td>If true then points with the same position as the query point will be ignored.</td></tr>
    <tr><td class="paramname">return_distances</td><td>If true then this function will return the distances for each neighbor to its query point in the same format as the indices. Note that for the L2 metric the squared distances will be returned!!</td></tr>
    <tr><td class="paramname">output_allocator</td><td>An object that implements functions for allocating the output arrays. The object must implement functions AllocIndices(int32_t** ptr, size_t size) and AllocDistances(T** ptr, size_t size). Both functions should allocate memory and return a pointer to that memory in ptr. Argument size specifies the size of the array as the number of elements. Both functions must accept the argument size==0. In this case ptr does not need to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67bac913eacce9b60f4a9f1668d98ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bac913eacce9b60f4a9f1668d98ee5">&#9670;&nbsp;</a></span>RadiusSearchCPU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TIndex , class OUTPUT_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void open3d::core::nns::impl::RadiusSearchCPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopen3d_1_1core_1_1nns_1_1_nano_flann_i-2">NanoFlannIndexHolderBase</a> *&#160;</td>
          <td class="paramname"><em>holder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>query_neighbors_row_splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopen3d_1_1core_1_1nns.html#a1ee06f6e576842e4122fded5bab8b074">Metric</a>&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_query_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUTPUT_ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>output_allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Radius search. This function computes a list of neighbor indices for each query point. The lists are stored linearly and an exclusive prefix sum defines the start and end of each list in the array. In addition the function optionally can return the distances for each neighbor in the same format as the indices to the neighbors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating-point data type for the point positions.</td></tr>
    <tr><td class="paramname">OUTPUT_ALLOCATOR</td><td>Type of the output_allocator. See <code>output_allocator</code> for more information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">holder</td><td>The pointer that point to NanFlannIndexHolder that is built with BuildKdTree function.</td></tr>
    <tr><td class="paramname">query_neighbors_row_splits</td><td>This is the output pointer for the prefix sum. The length of this array is <code>num_queries</code> + 1.</td></tr>
    <tr><td class="paramname">num_points</td><td>The number of points.</td></tr>
    <tr><td class="paramname">points</td><td>Array with the point positions. This may be the same array as <code>queries</code>.</td></tr>
    <tr><td class="paramname">num_queries</td><td>The number of query points.</td></tr>
    <tr><td class="paramname">queries</td><td>Array with the query positions. This may be the same array as <code>points</code>.</td></tr>
    <tr><td class="paramname">dimension</td><td>The dimension of <code>points</code> and <code>queries</code>.</td></tr>
    <tr><td class="paramname">radii</td><td>A vector of search radii with length <code>num_queries</code>.</td></tr>
    <tr><td class="paramname">metric</td><td>One of L1, L2. Defines the distance metric for the search.</td></tr>
    <tr><td class="paramname">ignore_query_point</td><td>If true then points with the same position as the query point will be ignored.</td></tr>
    <tr><td class="paramname">return_distances</td><td>If true then this function will return the distances for each neighbor to its query point in the same format as the indices. Note that for the L2 metric the squared distances will be returned!!</td></tr>
    <tr><td class="paramname">normalize_distances</td><td>If true then the returned distances are normalized in the range [0,1]. Note that for L2 the normalized distance is squared.</td></tr>
    <tr><td class="paramname">sort</td><td>If true then sort the resulting indices and distances in ascending order of distances.</td></tr>
    <tr><td class="paramname">output_allocator</td><td>An object that implements functions for allocating the output arrays. The object must implement functions AllocIndices(int32_t** ptr, size_t size) and AllocDistances(T** ptr, size_t size). Both functions should allocate memory and return a pointer to that memory in ptr. Argument size specifies the size of the array as the number of elements. Both functions must accept the argument size==0. In this case ptr does not need to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/namespaceopen3d_1_1core_1_1nns_1_1impl.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:59:52 GMT -->
</html>
