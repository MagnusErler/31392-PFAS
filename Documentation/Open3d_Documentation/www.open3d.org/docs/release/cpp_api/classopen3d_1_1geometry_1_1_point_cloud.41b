<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/classopen3d_1_1geometry_1_1_point_cloud.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:56:08 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open3D (C++ API): open3d::geometry::PointCloud Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.html", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="../../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3TQPKGV6Z3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-3TQPKGV6Z3');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="open3d_logo.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open3D (C++ API)
   &#160;<span id="projectnumber">0.17.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.html','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopen3d.html">open3d</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">open3d::geometry::PointCloud Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A point cloud consists of point coordinates, and optionally point colors and point normals.  
 <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="geometry_2_point_cloud_8h_source.html">PointCloud.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for open3d::geometry::PointCloud:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classopen3d_1_1geometry_1_1_point_cloud.639" usemap="#open3d::geometry::PointCloud_map" alt=""/>
  <map id="open3d::geometry::PointCloud_map" name="open3d::geometry::PointCloud_map">
<area href="classopen3d_1_1geometry_1_1_geometry3_d.402" title="The base geometry class for 3D geometries." alt="open3d::geometry::Geometry3D" shape="rect" coords="0,56,188,80"/>
<area href="classopen3d_1_1geometry_1_1_geometry.400.del" title="The base geometry class." alt="open3d::geometry::Geometry" shape="rect" coords="0,0,188,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f3049bff64e39b7e6fdcc304342114e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9f3049bff64e39b7e6fdcc304342114e">PointCloud</a> ()</td></tr>
<tr class="memdesc:a9f3049bff64e39b7e6fdcc304342114e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9f3049bff64e39b7e6fdcc304342114e">More...</a><br /></td></tr>
<tr class="separator:a9f3049bff64e39b7e6fdcc304342114e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66589ee57e5ab3cadb947a788dc0a69f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a66589ee57e5ab3cadb947a788dc0a69f">PointCloud</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>)</td></tr>
<tr class="memdesc:a66589ee57e5ab3cadb947a788dc0a69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized Constructor.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a66589ee57e5ab3cadb947a788dc0a69f">More...</a><br /></td></tr>
<tr class="separator:a66589ee57e5ab3cadb947a788dc0a69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d06602984208b2a9c5b57519071467"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a97d06602984208b2a9c5b57519071467">~PointCloud</a> () override</td></tr>
<tr class="separator:a97d06602984208b2a9c5b57519071467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e5242e55046ac9a1e4eb0ae7ed7841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a37e5242e55046ac9a1e4eb0ae7ed7841">Clear</a> () override</td></tr>
<tr class="memdesc:a37e5242e55046ac9a1e4eb0ae7ed7841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all elements in the geometry.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a37e5242e55046ac9a1e4eb0ae7ed7841">More...</a><br /></td></tr>
<tr class="separator:a37e5242e55046ac9a1e4eb0ae7ed7841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81645c9fda2cb8ac2545e2848d7f8e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#af81645c9fda2cb8ac2545e2848d7f8e4">IsEmpty</a> () const override</td></tr>
<tr class="memdesc:af81645c9fda2cb8ac2545e2848d7f8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> iff the geometry is empty.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#af81645c9fda2cb8ac2545e2848d7f8e4">More...</a><br /></td></tr>
<tr class="separator:af81645c9fda2cb8ac2545e2848d7f8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cf5bf8e8fc872afb9de353081e0f40"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a34cf5bf8e8fc872afb9de353081e0f40">GetMinBound</a> () const override</td></tr>
<tr class="memdesc:a34cf5bf8e8fc872afb9de353081e0f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min bounds for geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a34cf5bf8e8fc872afb9de353081e0f40">More...</a><br /></td></tr>
<tr class="separator:a34cf5bf8e8fc872afb9de353081e0f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35afe91567f1ecf04c2dba08892175a6"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a35afe91567f1ecf04c2dba08892175a6">GetMaxBound</a> () const override</td></tr>
<tr class="memdesc:a35afe91567f1ecf04c2dba08892175a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max bounds for geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a35afe91567f1ecf04c2dba08892175a6">More...</a><br /></td></tr>
<tr class="separator:a35afe91567f1ecf04c2dba08892175a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b36be18a575419ecb6a1761f56a4f03"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a1b36be18a575419ecb6a1761f56a4f03">GetCenter</a> () const override</td></tr>
<tr class="memdesc:a1b36be18a575419ecb6a1761f56a4f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the center of the geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a1b36be18a575419ecb6a1761f56a4f03">More...</a><br /></td></tr>
<tr class="separator:a1b36be18a575419ecb6a1761f56a4f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f60f4856e3f665d48628b42c1aa8f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou">AxisAlignedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a0f60f4856e3f665d48628b42c1aa8f28">GetAxisAlignedBoundingBox</a> () const override</td></tr>
<tr class="separator:a0f60f4856e3f665d48628b42c1aa8f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ace5711205c405794b824849e826c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a5ace5711205c405794b824849e826c63">GetOrientedBoundingBox</a> (bool robust=false) const override</td></tr>
<tr class="separator:a5ace5711205c405794b824849e826c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00019e336f74442025fcdaa4c5d20651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a00019e336f74442025fcdaa4c5d20651">GetMinimalOrientedBoundingBox</a> (bool robust=false) const override</td></tr>
<tr class="separator:a00019e336f74442025fcdaa4c5d20651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d10c488777e1d881c1c29cad308bae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9d10c488777e1d881c1c29cad308bae6">Transform</a> (const Eigen::Matrix4d &amp;transformation) override</td></tr>
<tr class="memdesc:a9d10c488777e1d881c1c29cad308bae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation (4x4 matrix) to the geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9d10c488777e1d881c1c29cad308bae6">More...</a><br /></td></tr>
<tr class="separator:a9d10c488777e1d881c1c29cad308bae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff6318cf076cf3f80c2b51bcdf3341c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a0ff6318cf076cf3f80c2b51bcdf3341c">Translate</a> (const Eigen::Vector3d &amp;translation, bool relative=true) override</td></tr>
<tr class="memdesc:a0ff6318cf076cf3f80c2b51bcdf3341c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply translation to the geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a0ff6318cf076cf3f80c2b51bcdf3341c">More...</a><br /></td></tr>
<tr class="separator:a0ff6318cf076cf3f80c2b51bcdf3341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f8f6c660aa06d6a4384d268baa02a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a58f8f6c660aa06d6a4384d268baa02a9">Scale</a> (const double scale, const Eigen::Vector3d &amp;center) override</td></tr>
<tr class="memdesc:a58f8f6c660aa06d6a4384d268baa02a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply scaling to the geometry coordinates. Given a scaling factor \(s\), and center \(c\), a given point \(p\) is transformed according to \(s (p - c) + c\).  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a58f8f6c660aa06d6a4384d268baa02a9">More...</a><br /></td></tr>
<tr class="separator:a58f8f6c660aa06d6a4384d268baa02a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cf4078f98dc88800657a438f036782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a90cf4078f98dc88800657a438f036782">Rotate</a> (const Eigen::Matrix3d &amp;R, const Eigen::Vector3d &amp;center) override</td></tr>
<tr class="memdesc:a90cf4078f98dc88800657a438f036782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rotation to the geometry coordinates and normals. Given a rotation matrix \(R\), and center \(c\), a given point \(p\) is transformed according to \(R (p - c) + c\).  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a90cf4078f98dc88800657a438f036782">More...</a><br /></td></tr>
<tr class="separator:a90cf4078f98dc88800657a438f036782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff8adc02dd574d35c94028f24a4a6d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a3ff8adc02dd574d35c94028f24a4a6d8">operator+=</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;cloud)</td></tr>
<tr class="separator:a3ff8adc02dd574d35c94028f24a4a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4c3d5e50b5fbf1123cb81cf2112e0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a2f4c3d5e50b5fbf1123cb81cf2112e0e">operator+</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;cloud) const</td></tr>
<tr class="separator:a2f4c3d5e50b5fbf1123cb81cf2112e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84480f8e1bb3659dce6dc4ccdc1b1420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a84480f8e1bb3659dce6dc4ccdc1b1420">HasPoints</a> () const</td></tr>
<tr class="memdesc:a84480f8e1bb3659dce6dc4ccdc1b1420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 'true' if the point cloud contains points.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a84480f8e1bb3659dce6dc4ccdc1b1420">More...</a><br /></td></tr>
<tr class="separator:a84480f8e1bb3659dce6dc4ccdc1b1420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46de5f6f1509734d131555e040808f0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a46de5f6f1509734d131555e040808f0b">HasNormals</a> () const</td></tr>
<tr class="memdesc:a46de5f6f1509734d131555e040808f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the point cloud contains point normals.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a46de5f6f1509734d131555e040808f0b">More...</a><br /></td></tr>
<tr class="separator:a46de5f6f1509734d131555e040808f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed16969e4e65179ee464a137bc838525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#aed16969e4e65179ee464a137bc838525">HasColors</a> () const</td></tr>
<tr class="memdesc:aed16969e4e65179ee464a137bc838525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the point cloud contains point colors.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#aed16969e4e65179ee464a137bc838525">More...</a><br /></td></tr>
<tr class="separator:aed16969e4e65179ee464a137bc838525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d506b84909fd80f77e6b4e29b55ab7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#af3d506b84909fd80f77e6b4e29b55ab7">HasCovariances</a> () const</td></tr>
<tr class="memdesc:af3d506b84909fd80f77e6b4e29b55ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 'true' if the point cloud contains per-point covariance matrix.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#af3d506b84909fd80f77e6b4e29b55ab7">More...</a><br /></td></tr>
<tr class="separator:af3d506b84909fd80f77e6b4e29b55ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcc93ef1df6d9a4df7b8de9c6216d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#aefcc93ef1df6d9a4df7b8de9c6216d21">NormalizeNormals</a> ()</td></tr>
<tr class="memdesc:aefcc93ef1df6d9a4df7b8de9c6216d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize point normals to length 1.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#aefcc93ef1df6d9a4df7b8de9c6216d21">More...</a><br /></td></tr>
<tr class="separator:aefcc93ef1df6d9a4df7b8de9c6216d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cdce7eb0b8e4cb14b26579cad0c263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a04cdce7eb0b8e4cb14b26579cad0c263">PaintUniformColor</a> (const Eigen::Vector3d &amp;<a class="el" href="_triangle_mesh_buffers_8cpp.html#aa332976d803be75beb81e81af320bfcb">color</a>)</td></tr>
<tr class="separator:a04cdce7eb0b8e4cb14b26579cad0c263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517e572c2db9967e4016aff27acbb8b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a517e572c2db9967e4016aff27acbb8b3">RemoveNonFinitePoints</a> (bool remove_nan=true, bool remove_infinite=true)</td></tr>
<tr class="memdesc:a517e572c2db9967e4016aff27acbb8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all points from the point cloud that have a nan entry, or infinite entries. It also removes the corresponding attributes associated with the non-finite point such as normals, covariances and color entries. It doesn't re-computes these attributes after removing non-finite points.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a517e572c2db9967e4016aff27acbb8b3">More...</a><br /></td></tr>
<tr class="separator:a517e572c2db9967e4016aff27acbb8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a873f73997f009c6fd34758289899e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9a873f73997f009c6fd34758289899e6">RemoveDuplicatedPoints</a> ()</td></tr>
<tr class="memdesc:a9a873f73997f009c6fd34758289899e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicated points, i.e., points that have identical coordinates. It also removes the corresponding attributes associated with the non-finite point such as normals, covariances and color entries. It doesn't re-computes these attributes after removing duplicated points.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9a873f73997f009c6fd34758289899e6">More...</a><br /></td></tr>
<tr class="separator:a9a873f73997f009c6fd34758289899e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86896913ca21d9829b0783c6fd3f980a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a86896913ca21d9829b0783c6fd3f980a">SelectByIndex</a> (const std::vector&lt; size_t &gt; &amp;indices, bool invert=false) const</td></tr>
<tr class="memdesc:a86896913ca21d9829b0783c6fd3f980a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects points from <code>input</code> pointcloud, with indices in <code>indices</code>, and returns a new point-cloud with selected points.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a86896913ca21d9829b0783c6fd3f980a">More...</a><br /></td></tr>
<tr class="separator:a86896913ca21d9829b0783c6fd3f980a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50efddf2d460dccf3de46cd0d38071af"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a50efddf2d460dccf3de46cd0d38071af">VoxelDownSample</a> (double voxel_size) const</td></tr>
<tr class="memdesc:a50efddf2d460dccf3de46cd0d38071af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsample input pointcloud with a voxel, and return a new point-cloud. Normals, covariances and colors are averaged if they exist.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a50efddf2d460dccf3de46cd0d38071af">More...</a><br /></td></tr>
<tr class="separator:a50efddf2d460dccf3de46cd0d38071af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9501d41a742c2f69f4b01e1921865a3d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;, Eigen::MatrixXi, std::vector&lt; std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9501d41a742c2f69f4b01e1921865a3d">VoxelDownSampleAndTrace</a> (double voxel_size, const Eigen::Vector3d &amp;min_bound, const Eigen::Vector3d &amp;max_bound, bool approximate_class=false) const</td></tr>
<tr class="memdesc:a9501d41a742c2f69f4b01e1921865a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to downsample using <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a50efddf2d460dccf3de46cd0d38071af" title="Downsample input pointcloud with a voxel, and return a new point-cloud. Normals, covariances and colo...">geometry.PointCloud.VoxelDownSample</a>.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9501d41a742c2f69f4b01e1921865a3d">More...</a><br /></td></tr>
<tr class="separator:a9501d41a742c2f69f4b01e1921865a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b4bc4b7dde2faf02252d747e238614"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a73b4bc4b7dde2faf02252d747e238614">UniformDownSample</a> (size_t every_k_points) const</td></tr>
<tr class="memdesc:a73b4bc4b7dde2faf02252d747e238614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to downsample input pointcloud into output pointcloud uniformly.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a73b4bc4b7dde2faf02252d747e238614">More...</a><br /></td></tr>
<tr class="separator:a73b4bc4b7dde2faf02252d747e238614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26dc9de4dbabeb2b4860303fe5772a0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#ac26dc9de4dbabeb2b4860303fe5772a0">RandomDownSample</a> (double sampling_ratio) const</td></tr>
<tr class="memdesc:ac26dc9de4dbabeb2b4860303fe5772a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to downsample input pointcloud into output pointcloud randomly.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#ac26dc9de4dbabeb2b4860303fe5772a0">More...</a><br /></td></tr>
<tr class="separator:ac26dc9de4dbabeb2b4860303fe5772a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb39a7008bee3a502d23abf12a43d91e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#afb39a7008bee3a502d23abf12a43d91e">FarthestPointDownSample</a> (size_t num_samples) const</td></tr>
<tr class="memdesc:afb39a7008bee3a502d23abf12a43d91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to downsample input pointcloud into output pointcloud with a set of points has farthest distance.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#afb39a7008bee3a502d23abf12a43d91e">More...</a><br /></td></tr>
<tr class="separator:afb39a7008bee3a502d23abf12a43d91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b08dd04ee328c9bd186213b94fbaa2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#aa8b08dd04ee328c9bd186213b94fbaa2">Crop</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou">AxisAlignedBoundingBox</a> &amp;bbox) const</td></tr>
<tr class="memdesc:aa8b08dd04ee328c9bd186213b94fbaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to crop pointcloud into output pointcloud.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#aa8b08dd04ee328c9bd186213b94fbaa2">More...</a><br /></td></tr>
<tr class="separator:aa8b08dd04ee328c9bd186213b94fbaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1cf9684475ed4bdbb20923baccc6ee"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a2f1cf9684475ed4bdbb20923baccc6ee">Crop</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> &amp;bbox) const</td></tr>
<tr class="memdesc:a2f1cf9684475ed4bdbb20923baccc6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to crop pointcloud into output pointcloud.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a2f1cf9684475ed4bdbb20923baccc6ee">More...</a><br /></td></tr>
<tr class="separator:a2f1cf9684475ed4bdbb20923baccc6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe271fc07cb3bd428834fb8cbc48dafb"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#afe271fc07cb3bd428834fb8cbc48dafb">RemoveRadiusOutliers</a> (size_t nb_points, double search_radius, bool print_progress=false) const</td></tr>
<tr class="memdesc:afe271fc07cb3bd428834fb8cbc48dafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to remove points that have less than <code>nb_points</code> in a sphere of a given radius.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#afe271fc07cb3bd428834fb8cbc48dafb">More...</a><br /></td></tr>
<tr class="separator:afe271fc07cb3bd428834fb8cbc48dafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c34dee60f36ec36a7de4ae2d55623cd"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9c34dee60f36ec36a7de4ae2d55623cd">RemoveStatisticalOutliers</a> (size_t nb_neighbors, double std_ratio, bool print_progress=false) const</td></tr>
<tr class="memdesc:a9c34dee60f36ec36a7de4ae2d55623cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to remove points that are further away from their <code>nb_neighbor</code> neighbors in average.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a9c34dee60f36ec36a7de4ae2d55623cd">More...</a><br /></td></tr>
<tr class="separator:a9c34dee60f36ec36a7de4ae2d55623cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb1b6e14c8beb0073bded699b3c81a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a0eb1b6e14c8beb0073bded699b3c81a7">EstimateNormals</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_">KDTreeSearchParam</a> &amp;search_param=<a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_-2">KDTreeSearchParamKNN</a>(), bool fast_normal_computation=true)</td></tr>
<tr class="memdesc:a0eb1b6e14c8beb0073bded699b3c81a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the normals of a point cloud.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a0eb1b6e14c8beb0073bded699b3c81a7">More...</a><br /></td></tr>
<tr class="separator:a0eb1b6e14c8beb0073bded699b3c81a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94623ab5a749a0bead96a1b26eaeaaf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a94623ab5a749a0bead96a1b26eaeaaf6">OrientNormalsToAlignWithDirection</a> (const Eigen::Vector3d &amp;orientation_reference=Eigen::Vector3d(0.0, 0.0, 1.0))</td></tr>
<tr class="memdesc:a94623ab5a749a0bead96a1b26eaeaaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to orient the normals of a point cloud.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a94623ab5a749a0bead96a1b26eaeaaf6">More...</a><br /></td></tr>
<tr class="separator:a94623ab5a749a0bead96a1b26eaeaaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc225cbe48338500beed676bbd45c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#aabc225cbe48338500beed676bbd45c59">OrientNormalsTowardsCameraLocation</a> (const Eigen::Vector3d &amp;camera_location=Eigen::Vector3d::Zero())</td></tr>
<tr class="memdesc:aabc225cbe48338500beed676bbd45c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to orient the normals of a point cloud.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#aabc225cbe48338500beed676bbd45c59">More...</a><br /></td></tr>
<tr class="separator:aabc225cbe48338500beed676bbd45c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace86de742d9caa4fe26ff7d50c4cd237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#ace86de742d9caa4fe26ff7d50c4cd237">OrientNormalsConsistentTangentPlane</a> (size_t k)</td></tr>
<tr class="memdesc:ace86de742d9caa4fe26ff7d50c4cd237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to consistently orient estimated normals based on consistent tangent planes as described in Hoppe et al., "Surface
Reconstruction from Unorganized Points", 1992.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#ace86de742d9caa4fe26ff7d50c4cd237">More...</a><br /></td></tr>
<tr class="separator:ace86de742d9caa4fe26ff7d50c4cd237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e37814040c0ee07ee32f7f31e255e7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a24e37814040c0ee07ee32f7f31e255e7">ComputePointCloudDistance</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;target)</td></tr>
<tr class="memdesc:a24e37814040c0ee07ee32f7f31e255e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the point to point distances between point clouds.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a24e37814040c0ee07ee32f7f31e255e7">More...</a><br /></td></tr>
<tr class="separator:a24e37814040c0ee07ee32f7f31e255e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91d8bc82f2f60ad2c8ace905447e8b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#ac91d8bc82f2f60ad2c8ace905447e8b5">EstimateCovariances</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_">KDTreeSearchParam</a> &amp;search_param=<a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_-2">KDTreeSearchParamKNN</a>())</td></tr>
<tr class="memdesc:ac91d8bc82f2f60ad2c8ace905447e8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the covariance matrix for each point of a point cloud.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#ac91d8bc82f2f60ad2c8ace905447e8b5">More...</a><br /></td></tr>
<tr class="separator:ac91d8bc82f2f60ad2c8ace905447e8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7002669d00844ebd7f979f202418cc66"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Vector3d, Eigen::Matrix3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a7002669d00844ebd7f979f202418cc66">ComputeMeanAndCovariance</a> () const</td></tr>
<tr class="separator:a7002669d00844ebd7f979f202418cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c120976c065fd0e23d7e3fd624b2dd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a22c120976c065fd0e23d7e3fd624b2dd">ComputeMahalanobisDistance</a> () const</td></tr>
<tr class="memdesc:a22c120976c065fd0e23d7e3fd624b2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the Mahalanobis distance for points in an input point cloud.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a22c120976c065fd0e23d7e3fd624b2dd">More...</a><br /></td></tr>
<tr class="separator:a22c120976c065fd0e23d7e3fd624b2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2f8d22bba8e951124fe78f658bfd9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a4c2f8d22bba8e951124fe78f658bfd9c">ComputeNearestNeighborDistance</a> () const</td></tr>
<tr class="separator:a4c2f8d22bba8e951124fe78f658bfd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb6e65b3b79a125a2574ba74e039770"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a6fb6e65b3b79a125a2574ba74e039770">ComputeConvexHull</a> (bool joggle_inputs=false) const</td></tr>
<tr class="separator:a6fb6e65b3b79a125a2574ba74e039770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33652146eb25e593ec4e9076ad05f42b"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a33652146eb25e593ec4e9076ad05f42b">HiddenPointRemoval</a> (const Eigen::Vector3d &amp;camera_location, const double radius) const</td></tr>
<tr class="memdesc:a33652146eb25e593ec4e9076ad05f42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation of the Hidden Point Removal operator described in Katz et. al. 'Direct Visibility of Point Sets', 2007.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a33652146eb25e593ec4e9076ad05f42b">More...</a><br /></td></tr>
<tr class="separator:a33652146eb25e593ec4e9076ad05f42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b23bffa301a32bea7825c01aa017f06"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a2b23bffa301a32bea7825c01aa017f06">ClusterDBSCAN</a> (double eps, size_t min_points, bool print_progress=false) const</td></tr>
<tr class="memdesc:a2b23bffa301a32bea7825c01aa017f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> using the DBSCAN algorithm Ester et al., "A Density-Based Algorithm for Discovering Clusters
in Large Spatial Databases with Noise", 1996.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a2b23bffa301a32bea7825c01aa017f06">More...</a><br /></td></tr>
<tr class="separator:a2b23bffa301a32bea7825c01aa017f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00754712b015e2fe8a411bac6b916b4a"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Vector4d, std::vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a00754712b015e2fe8a411bac6b916b4a">SegmentPlane</a> (const double distance_threshold=0.01, const int ransac_n=3, const int num_iterations=100, const double probability=0.99999999) const</td></tr>
<tr class="memdesc:a00754712b015e2fe8a411bac6b916b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> plane using the RANSAC algorithm.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a00754712b015e2fe8a411bac6b916b4a">More...</a><br /></td></tr>
<tr class="separator:a00754712b015e2fe8a411bac6b916b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f8768a5724081b8df2799f49348d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a251f8768a5724081b8df2799f49348d2">DetectPlanarPatches</a> (double normal_variance_threshold_deg=60, double coplanarity_deg=75, double outlier_ratio=0.75, double min_plane_edge_length=0.0, size_t min_num_points=0, const <a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_">geometry::KDTreeSearchParam</a> &amp;search_param=<a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_-2">geometry::KDTreeSearchParamKNN</a>()) const</td></tr>
<tr class="memdesc:a251f8768a5724081b8df2799f49348d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Robustly detect planar patches in the point cloud using. Araújo and Oliveira, “A robust statistics approach for plane detection in unorganized point clouds,” Pattern Recognition, 2020.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a251f8768a5724081b8df2799f49348d2">More...</a><br /></td></tr>
<tr class="separator:a251f8768a5724081b8df2799f49348d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classopen3d_1_1geometry_1_1_geometry3_d')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402">open3d::geometry::Geometry3D</a></td></tr>
<tr class="memitem:a3bee61a0da428535d0eb9f62786fcab1 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a3bee61a0da428535d0eb9f62786fcab1">~Geometry3D</a> () override</td></tr>
<tr class="separator:a3bee61a0da428535d0eb9f62786fcab1 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2ab7fb19c0fc8f4ccbc9a776be2e23 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402">Geometry3D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a5c2ab7fb19c0fc8f4ccbc9a776be2e23">Rotate</a> (const Eigen::Matrix3d &amp;R)</td></tr>
<tr class="separator:a5c2ab7fb19c0fc8f4ccbc9a776be2e23 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classopen3d_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classopen3d_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del">open3d::geometry::Geometry</a></td></tr>
<tr class="memitem:a1c2eb5a3e6c0a47cc31e38d086d07c54 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a1c2eb5a3e6c0a47cc31e38d086d07c54">~Geometry</a> ()</td></tr>
<tr class="separator:a1c2eb5a3e6c0a47cc31e38d086d07c54 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194473f920417162aa501bfb7df1d4b9 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">GeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a194473f920417162aa501bfb7df1d4b9">GetGeometryType</a> () const</td></tr>
<tr class="memdesc:a194473f920417162aa501bfb7df1d4b9 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of registered geometry types.  <a href="classopen3d_1_1geometry_1_1_geometry.400.del#a194473f920417162aa501bfb7df1d4b9">More...</a><br /></td></tr>
<tr class="separator:a194473f920417162aa501bfb7df1d4b9 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669ce49f3f489ec8816fb3ad228de081 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a669ce49f3f489ec8816fb3ad228de081">Dimension</a> () const</td></tr>
<tr class="memdesc:a669ce49f3f489ec8816fb3ad228de081 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the geometry is 2D or 3D.  <a href="classopen3d_1_1geometry_1_1_geometry.400.del#a669ce49f3f489ec8816fb3ad228de081">More...</a><br /></td></tr>
<tr class="separator:a669ce49f3f489ec8816fb3ad228de081 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cba98e39c57eb2544eedfb525807a06 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a7cba98e39c57eb2544eedfb525807a06">GetName</a> () const</td></tr>
<tr class="separator:a7cba98e39c57eb2544eedfb525807a06 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229d9bdaded622121f443cbb81626b8 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a4229d9bdaded622121f443cbb81626b8">SetName</a> (const std::string &amp;<a class="el" href="_o3_d_visualizer_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="separator:a4229d9bdaded622121f443cbb81626b8 inherit pub_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a18527af0e9a1a0e8f609ac47ca7a6178"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Eigen::Matrix3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a18527af0e9a1a0e8f609ac47ca7a6178">EstimatePerPointCovariances</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;input, const <a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_">KDTreeSearchParam</a> &amp;search_param=<a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_-2">KDTreeSearchParamKNN</a>())</td></tr>
<tr class="memdesc:a18527af0e9a1a0e8f609ac47ca7a6178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function to compute the covariance matrix for each point of a point cloud. Doesn't change the input <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a>, just outputs the covariance matrices.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a18527af0e9a1a0e8f609ac47ca7a6178">More...</a><br /></td></tr>
<tr class="separator:a18527af0e9a1a0e8f609ac47ca7a6178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41ab974470852cc4f4be7bdd262f7e"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a5c41ab974470852cc4f4be7bdd262f7e">CreateFromDepthImage</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_image.406.delaye">Image</a> &amp;depth, const <a class="el" href="classopen3d_1_1camera_1_1_pinhole_camera_int">camera::PinholeCameraIntrinsic</a> &amp;intrinsic, const Eigen::Matrix4d &amp;extrinsic=Eigen::Matrix4d::Identity(), double depth_scale=1000.0, double depth_trunc=1000.0, int <a class="el" href="_triangle_mesh_buffers_8cpp.html#a3f19cd85df5258a38e4618a89bd5ff46">stride</a>=1, bool project_valid_depth_only=true)</td></tr>
<tr class="memdesc:a5c41ab974470852cc4f4be7bdd262f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to create a pointcloud from a depth image and a camera model.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a5c41ab974470852cc4f4be7bdd262f7e">More...</a><br /></td></tr>
<tr class="separator:a5c41ab974470852cc4f4be7bdd262f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa726a64d050c5f7dd46d2419c682ac37"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#aa726a64d050c5f7dd46d2419c682ac37">CreateFromRGBDImage</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_r_g_b_d_image.37">RGBDImage</a> &amp;<a class="el" href="_filament_renderer_8cpp.html#a60b0c69b08810766e366c4b90031cd0d">image</a>, const <a class="el" href="classopen3d_1_1camera_1_1_pinhole_camera_int">camera::PinholeCameraIntrinsic</a> &amp;intrinsic, const Eigen::Matrix4d &amp;extrinsic=Eigen::Matrix4d::Identity(), bool project_valid_depth_only=true)</td></tr>
<tr class="memdesc:aa726a64d050c5f7dd46d2419c682ac37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to create a pointcloud from an RGB-D image and a camera model.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#aa726a64d050c5f7dd46d2419c682ac37">More...</a><br /></td></tr>
<tr class="separator:aa726a64d050c5f7dd46d2419c682ac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82ba6551d1b1eea6daecaaa825c3ebf"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#aa82ba6551d1b1eea6daecaaa825c3ebf">CreateFromVoxelGrid</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_voxel_grid.426.d">VoxelGrid</a> &amp;voxel_grid)</td></tr>
<tr class="memdesc:aa82ba6551d1b1eea6daecaaa825c3ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory Function to create a <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> from a <a class="el" href="classopen3d_1_1geometry_1_1_voxel_grid.426.d" title="VoxelGrid is a collection of voxels which are aligned in grid.">VoxelGrid</a>.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#aa82ba6551d1b1eea6daecaaa825c3ebf">More...</a><br /></td></tr>
<tr class="separator:aa82ba6551d1b1eea6daecaaa825c3ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402">open3d::geometry::Geometry3D</a></td></tr>
<tr class="memitem:ab557dd1610ea7fae73d00c706bbd529f inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab557dd1610ea7fae73d00c706bbd529f">GetRotationMatrixFromXYZ</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:ab557dd1610ea7fae73d00c706bbd529f inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from XYZ RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab557dd1610ea7fae73d00c706bbd529f">More...</a><br /></td></tr>
<tr class="separator:ab557dd1610ea7fae73d00c706bbd529f inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b8ef97b798c623b4e2fe72d2afda03 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#af5b8ef97b798c623b4e2fe72d2afda03">GetRotationMatrixFromYZX</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:af5b8ef97b798c623b4e2fe72d2afda03 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from YZX RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#af5b8ef97b798c623b4e2fe72d2afda03">More...</a><br /></td></tr>
<tr class="separator:af5b8ef97b798c623b4e2fe72d2afda03 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb9b2eabab1ced5c25358c3a69c8d13 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#afbb9b2eabab1ced5c25358c3a69c8d13">GetRotationMatrixFromZXY</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:afbb9b2eabab1ced5c25358c3a69c8d13 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from ZXY RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#afbb9b2eabab1ced5c25358c3a69c8d13">More...</a><br /></td></tr>
<tr class="separator:afbb9b2eabab1ced5c25358c3a69c8d13 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f91e4bddbb07a3ccd6692db599eca7 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a82f91e4bddbb07a3ccd6692db599eca7">GetRotationMatrixFromXZY</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:a82f91e4bddbb07a3ccd6692db599eca7 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from XZY RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a82f91e4bddbb07a3ccd6692db599eca7">More...</a><br /></td></tr>
<tr class="separator:a82f91e4bddbb07a3ccd6692db599eca7 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96c4285c5d5cc80f14458559c7a3826 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac96c4285c5d5cc80f14458559c7a3826">GetRotationMatrixFromZYX</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:ac96c4285c5d5cc80f14458559c7a3826 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from ZYX RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac96c4285c5d5cc80f14458559c7a3826">More...</a><br /></td></tr>
<tr class="separator:ac96c4285c5d5cc80f14458559c7a3826 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ee2e4c68c2c55ac4ab8b533b11dad0 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a16ee2e4c68c2c55ac4ab8b533b11dad0">GetRotationMatrixFromYXZ</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:a16ee2e4c68c2c55ac4ab8b533b11dad0 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from YXZ RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a16ee2e4c68c2c55ac4ab8b533b11dad0">More...</a><br /></td></tr>
<tr class="separator:a16ee2e4c68c2c55ac4ab8b533b11dad0 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9356dfe2ba6a44df60588f4b2a29056 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa9356dfe2ba6a44df60588f4b2a29056">GetRotationMatrixFromAxisAngle</a> (const Eigen::Vector3d &amp;rotation)</td></tr>
<tr class="memdesc:aa9356dfe2ba6a44df60588f4b2a29056 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from AxisAngle RotationType.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa9356dfe2ba6a44df60588f4b2a29056">More...</a><br /></td></tr>
<tr class="separator:aa9356dfe2ba6a44df60588f4b2a29056 inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9966dec46a4808e5acd9318fa6bf73a inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">static Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ad9966dec46a4808e5acd9318fa6bf73a">GetRotationMatrixFromQuaternion</a> (const Eigen::Vector4d &amp;rotation)</td></tr>
<tr class="memdesc:ad9966dec46a4808e5acd9318fa6bf73a inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Rotation Matrix from Quaternion.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ad9966dec46a4808e5acd9318fa6bf73a">More...</a><br /></td></tr>
<tr class="separator:ad9966dec46a4808e5acd9318fa6bf73a inherit pub_static_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ac65618ae6fd935898925293aeb7189e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#ac65618ae6fd935898925293aeb7189e1">points_</a></td></tr>
<tr class="memdesc:ac65618ae6fd935898925293aeb7189e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points coordinates.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#ac65618ae6fd935898925293aeb7189e1">More...</a><br /></td></tr>
<tr class="separator:ac65618ae6fd935898925293aeb7189e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94983bb5c7a3475e3671b64c6280427"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#aa94983bb5c7a3475e3671b64c6280427">normals_</a></td></tr>
<tr class="memdesc:aa94983bb5c7a3475e3671b64c6280427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points normals.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#aa94983bb5c7a3475e3671b64c6280427">More...</a><br /></td></tr>
<tr class="separator:aa94983bb5c7a3475e3671b64c6280427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d9fb6adaf53966279be1cb611b22f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a01d9fb6adaf53966279be1cb611b22f0">colors_</a></td></tr>
<tr class="memdesc:a01d9fb6adaf53966279be1cb611b22f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB colors of points.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a01d9fb6adaf53966279be1cb611b22f0">More...</a><br /></td></tr>
<tr class="separator:a01d9fb6adaf53966279be1cb611b22f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08324d3049f9048c2f8c6224fc564347"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a08324d3049f9048c2f8c6224fc564347">covariances_</a></td></tr>
<tr class="memdesc:a08324d3049f9048c2f8c6224fc564347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Covariance Matrix for each point.  <a href="classopen3d_1_1geometry_1_1_point_cloud.41b#a08324d3049f9048c2f8c6224fc564347">More...</a><br /></td></tr>
<tr class="separator:a08324d3049f9048c2f8c6224fc564347"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classopen3d_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classopen3d_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del">open3d::geometry::Geometry</a></td></tr>
<tr class="memitem:a69975c2b054d4fd12cf36866a030ed8e inherit pub_types_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">GeometryType</a> { <br />
&#160;&#160;<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea6fcdc090caeade09d0efd6253932b6f5">Unspecified</a> = 0
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eaee9349b5cdfd717c7e1234edce6b72fa">PointCloud</a> = 1
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea7fe2447f30c8de08b433c3631d7d78ff">VoxelGrid</a> = 2
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea3d33fe96c4d284d37a6ee296db5e33ac">Octree</a> = 3
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eae3e5995e4fc46bdc12e733558dd3120a">LineSet</a> = 4
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea2ad6a25f1ccff1433467bae74193446e">MeshBase</a> = 5
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea70be243de75004a602f012fece7c0fad">TriangleMesh</a> = 6
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eaa79a2e14e35ed8368058ad93d3d39dc3">HalfEdgeTriangleMesh</a> = 7
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eabe53a0541a6d36f6ecb879fa2c584b08">Image</a> = 8
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea7d64b6deb2cbf0f1712bd6e93b5755ba">RGBDImage</a> = 9
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea48e9695b4242a3a90ea76c7cc87162de">TetraMesh</a> = 10
, <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8eaff8b20067506aaf814f1e5df2494c2f1">OrientedBoundingBox</a> = 11
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8ea0446516d578c6abaae2f3adc7239fa61">AxisAlignedBoundingBox</a> = 12
<br />
 }</td></tr>
<tr class="memdesc:a69975c2b054d4fd12cf36866a030ed8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies possible geometry types.  <a href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">More...</a><br /></td></tr>
<tr class="separator:a69975c2b054d4fd12cf36866a030ed8e inherit pub_types_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classopen3d_1_1geometry_1_1_geometry3_d')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402">open3d::geometry::Geometry3D</a></td></tr>
<tr class="memitem:ab7c4a13882fb57765e55e164e34eedfb inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab7c4a13882fb57765e55e164e34eedfb">Geometry3D</a> (<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">GeometryType</a> <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aff17911edc8208aa8ddb1c7c52c78389">type</a>)</td></tr>
<tr class="memdesc:ab7c4a13882fb57765e55e164e34eedfb inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized Constructor.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab7c4a13882fb57765e55e164e34eedfb">More...</a><br /></td></tr>
<tr class="separator:ab7c4a13882fb57765e55e164e34eedfb inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03dcc177e8b50632e95d7dd7d838976 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa03dcc177e8b50632e95d7dd7d838976">ComputeMinBound</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>) const</td></tr>
<tr class="memdesc:aa03dcc177e8b50632e95d7dd7d838976 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute min bound of a list points.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa03dcc177e8b50632e95d7dd7d838976">More...</a><br /></td></tr>
<tr class="separator:aa03dcc177e8b50632e95d7dd7d838976 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487b1d81a14ef17bf70e8c4d94d5c18c inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a487b1d81a14ef17bf70e8c4d94d5c18c">ComputeMaxBound</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>) const</td></tr>
<tr class="memdesc:a487b1d81a14ef17bf70e8c4d94d5c18c inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute max bound of a list points.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a487b1d81a14ef17bf70e8c4d94d5c18c">More...</a><br /></td></tr>
<tr class="separator:a487b1d81a14ef17bf70e8c4d94d5c18c inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e6a432ab26afcb7fb572313ddc90ce inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac8e6a432ab26afcb7fb572313ddc90ce">ComputeCenter</a> (const std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>) const</td></tr>
<tr class="memdesc:ac8e6a432ab26afcb7fb572313ddc90ce inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computer center of a list of points.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac8e6a432ab26afcb7fb572313ddc90ce">More...</a><br /></td></tr>
<tr class="separator:ac8e6a432ab26afcb7fb572313ddc90ce inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb3da9e31897b4279f02327daca34cd inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a1fb3da9e31897b4279f02327daca34cd">ResizeAndPaintUniformColor</a> (std::vector&lt; Eigen::Vector3d &gt; &amp;colors, const size_t <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#a439227feff9d7f55384e8780cfc2eb82">size</a>, const Eigen::Vector3d &amp;<a class="el" href="_triangle_mesh_buffers_8cpp.html#aa332976d803be75beb81e81af320bfcb">color</a>) const</td></tr>
<tr class="memdesc:a1fb3da9e31897b4279f02327daca34cd inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the colors vector and paints a uniform color.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a1fb3da9e31897b4279f02327daca34cd">More...</a><br /></td></tr>
<tr class="separator:a1fb3da9e31897b4279f02327daca34cd inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3a5c603c2c9a0e05c1af1a4a279508 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a0e3a5c603c2c9a0e05c1af1a4a279508">TransformPoints</a> (const Eigen::Matrix4d &amp;transformation, std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>) const</td></tr>
<tr class="memdesc:a0e3a5c603c2c9a0e05c1af1a4a279508 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms all points with the transformation matrix.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a0e3a5c603c2c9a0e05c1af1a4a279508">More...</a><br /></td></tr>
<tr class="separator:a0e3a5c603c2c9a0e05c1af1a4a279508 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1df456f2e6dddac794f7ab2186a7ce5 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac1df456f2e6dddac794f7ab2186a7ce5">TransformNormals</a> (const Eigen::Matrix4d &amp;transformation, std::vector&lt; Eigen::Vector3d &gt; &amp;normals) const</td></tr>
<tr class="memdesc:ac1df456f2e6dddac794f7ab2186a7ce5 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the normals with the transformation matrix.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#ac1df456f2e6dddac794f7ab2186a7ce5">More...</a><br /></td></tr>
<tr class="separator:ac1df456f2e6dddac794f7ab2186a7ce5 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623c3e7c883e0bcfc2987aaf92c96597 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a623c3e7c883e0bcfc2987aaf92c96597">TransformCovariances</a> (const Eigen::Matrix4d &amp;transformation, std::vector&lt; Eigen::Matrix3d &gt; &amp;covariances) const</td></tr>
<tr class="memdesc:a623c3e7c883e0bcfc2987aaf92c96597 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms all covariance matrices with the transformation.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a623c3e7c883e0bcfc2987aaf92c96597">More...</a><br /></td></tr>
<tr class="separator:a623c3e7c883e0bcfc2987aaf92c96597 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4029dff278938fcf7eb73b4133f76e67 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a4029dff278938fcf7eb73b4133f76e67">TranslatePoints</a> (const Eigen::Vector3d &amp;translation, std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, bool relative) const</td></tr>
<tr class="memdesc:a4029dff278938fcf7eb73b4133f76e67 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply translation to the geometry coordinates.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a4029dff278938fcf7eb73b4133f76e67">More...</a><br /></td></tr>
<tr class="separator:a4029dff278938fcf7eb73b4133f76e67 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26106b31a3acecad90f44293c83a3a1b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a26106b31a3acecad90f44293c83a3a1b">ScalePoints</a> (const double scale, std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, const Eigen::Vector3d &amp;center) const</td></tr>
<tr class="memdesc:a26106b31a3acecad90f44293c83a3a1b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the coordinates of all points by the scaling factor <code>scale</code>.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a26106b31a3acecad90f44293c83a3a1b">More...</a><br /></td></tr>
<tr class="separator:a26106b31a3acecad90f44293c83a3a1b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901a9fda0a2b40a8a53ea45ff18a1760 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a901a9fda0a2b40a8a53ea45ff18a1760">RotatePoints</a> (const Eigen::Matrix3d &amp;R, std::vector&lt; Eigen::Vector3d &gt; &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>, const Eigen::Vector3d &amp;center) const</td></tr>
<tr class="memdesc:a901a9fda0a2b40a8a53ea45ff18a1760 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all points with the rotation matrix <code>R</code>.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a901a9fda0a2b40a8a53ea45ff18a1760">More...</a><br /></td></tr>
<tr class="separator:a901a9fda0a2b40a8a53ea45ff18a1760 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2448e4cfbdb49e90e72289e36113d9b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa2448e4cfbdb49e90e72289e36113d9b">RotateNormals</a> (const Eigen::Matrix3d &amp;R, std::vector&lt; Eigen::Vector3d &gt; &amp;normals) const</td></tr>
<tr class="memdesc:aa2448e4cfbdb49e90e72289e36113d9b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all normals with the rotation matrix <code>R</code>.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa2448e4cfbdb49e90e72289e36113d9b">More...</a><br /></td></tr>
<tr class="separator:aa2448e4cfbdb49e90e72289e36113d9b inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce8a11fd0762558a620f448f18ebae3 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a9ce8a11fd0762558a620f448f18ebae3">RotateCovariances</a> (const Eigen::Matrix3d &amp;R, std::vector&lt; Eigen::Matrix3d &gt; &amp;covariances) const</td></tr>
<tr class="memdesc:a9ce8a11fd0762558a620f448f18ebae3 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all covariance matrices with the rotation matrix <code>R</code>.  <a href="classopen3d_1_1geometry_1_1_geometry3_d.402#a9ce8a11fd0762558a620f448f18ebae3">More...</a><br /></td></tr>
<tr class="separator:a9ce8a11fd0762558a620f448f18ebae3 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry3_d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classopen3d_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classopen3d_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del">open3d::geometry::Geometry</a></td></tr>
<tr class="memitem:ae0bb1c2bed5d65d1ecd0e81370a12d99 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#ae0bb1c2bed5d65d1ecd0e81370a12d99">Geometry</a> (<a class="el" href="classopen3d_1_1geometry_1_1_geometry.400.del#a69975c2b054d4fd12cf36866a030ed8e">GeometryType</a> <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aff17911edc8208aa8ddb1c7c52c78389">type</a>, int dimension)</td></tr>
<tr class="memdesc:ae0bb1c2bed5d65d1ecd0e81370a12d99 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized Constructor.  <a href="classopen3d_1_1geometry_1_1_geometry.400.del#ae0bb1c2bed5d65d1ecd0e81370a12d99">More...</a><br /></td></tr>
<tr class="separator:ae0bb1c2bed5d65d1ecd0e81370a12d99 inherit pro_methods_classopen3d_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A point cloud consists of point coordinates, and optionally point colors and point normals. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9f3049bff64e39b7e6fdcc304342114e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3049bff64e39b7e6fdcc304342114e">&#9670;&nbsp;</a></span>PointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">open3d::geometry::PointCloud::PointCloud </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default Constructor. </p>

</div>
</div>
<a id="a66589ee57e5ab3cadb947a788dc0a69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66589ee57e5ab3cadb947a788dc0a69f">&#9670;&nbsp;</a></span>PointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">open3d::geometry::PointCloud::PointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameterized Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Points coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97d06602984208b2a9c5b57519071467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d06602984208b2a9c5b57519071467">&#9670;&nbsp;</a></span>~PointCloud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">open3d::geometry::PointCloud::~PointCloud </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a37e5242e55046ac9a1e4eb0ae7ed7841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e5242e55046ac9a1e4eb0ae7ed7841">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp; open3d::geometry::PointCloud::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all elements in the geometry. </p>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a5d18d746cde60c2e79cd6109c505ea22">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a2b23bffa301a32bea7825c01aa017f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b23bffa301a32bea7825c01aa017f06">&#9670;&nbsp;</a></span>ClusterDBSCAN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; open3d::geometry::PointCloud::ClusterDBSCAN </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cluster <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> using the DBSCAN algorithm Ester et al., "A Density-Based Algorithm for Discovering Clusters
in Large Spatial Databases with Noise", 1996. </p>
<p>Returns a list of point labels, -1 indicates noise according to the algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eps</td><td>Density parameter that is used to find neighbouring points. </td></tr>
    <tr><td class="paramname">min_points</td><td>Minimum number of points to form a cluster. </td></tr>
    <tr><td class="paramname">print_progress</td><td>If <code>true</code> the progress is visualized in the console. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb6e65b3b79a125a2574ba74e039770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb6e65b3b79a125a2574ba74e039770">&#9670;&nbsp;</a></span>ComputeConvexHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;, std::vector&lt; size_t &gt; &gt; open3d::geometry::PointCloud::ComputeConvexHull </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>joggle_inputs</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that computes the convex hull of the point cloud using qhull </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joggle_inputs</td><td>If true allows the algorithm to add random noise to the points to work around degenerate inputs. This adds the 'QJ' option to the qhull command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The triangle mesh of the convex hull and the list of point indices that are part of the convex hull. </dd></dl>

</div>
</div>
<a id="a22c120976c065fd0e23d7e3fd624b2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c120976c065fd0e23d7e3fd624b2dd">&#9670;&nbsp;</a></span>ComputeMahalanobisDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; open3d::geometry::PointCloud::ComputeMahalanobisDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the Mahalanobis distance for points in an input point cloud. </p>
<p>See: <a href="https://en.wikipedia.org/wiki/Mahalanobis_distance">https://en.wikipedia.org/wiki/Mahalanobis_distance</a> </p>

</div>
</div>
<a id="a7002669d00844ebd7f979f202418cc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7002669d00844ebd7f979f202418cc66">&#9670;&nbsp;</a></span>ComputeMeanAndCovariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; Eigen::Vector3d, Eigen::Matrix3d &gt; open3d::geometry::PointCloud::ComputeMeanAndCovariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to compute the mean and covariance matrix of a point cloud. </p>

</div>
</div>
<a id="a4c2f8d22bba8e951124fe78f658bfd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2f8d22bba8e951124fe78f658bfd9c">&#9670;&nbsp;</a></span>ComputeNearestNeighborDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; open3d::geometry::PointCloud::ComputeNearestNeighborDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to compute the distance from a point to its nearest neighbor in the input point cloud </p>

</div>
</div>
<a id="a24e37814040c0ee07ee32f7f31e255e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e37814040c0ee07ee32f7f31e255e7">&#9670;&nbsp;</a></span>ComputePointCloudDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; open3d::geometry::PointCloud::ComputePointCloudDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the point to point distances between point clouds. </p>
<p>For each point in the <code>source</code> point cloud, compute the distance to the <code>target</code> point cloud.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target point cloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c41ab974470852cc4f4be7bdd262f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c41ab974470852cc4f4be7bdd262f7e">&#9670;&nbsp;</a></span>CreateFromDepthImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::CreateFromDepthImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_image.406.delaye">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1camera_1_1_pinhole_camera_int">camera::PinholeCameraIntrinsic</a> &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4d &amp;&#160;</td>
          <td class="paramname"><em>extrinsic</em> = <code>Eigen::Matrix4d::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>depth_scale</em> = <code>1000.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>depth_trunc</em> = <code>1000.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project_valid_depth_only</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to create a pointcloud from a depth image and a camera model. </p>
<p>Given depth value d at (u, v) image coordinate, the corresponding 3d point is: z = d / depth_scale<br  />
 x = (u - cx) * z / fx<br  />
 y = (v - cy) * z / fy<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>The input depth image can be either a float image, or a uint16_t image.</td></tr>
    <tr><td class="paramname">intrinsic</td><td>Intrinsic parameters of the camera. </td></tr>
    <tr><td class="paramname">extrinsic</td><td>Extrinsic parameters of the camera. </td></tr>
    <tr><td class="paramname">depth_scale</td><td>The depth is scaled by 1 / <code>depth_scale</code>. </td></tr>
    <tr><td class="paramname">depth_trunc</td><td>Truncated at <code>depth_trunc</code> distance. </td></tr>
    <tr><td class="paramname">stride</td><td>Sampling factor to support coarse point cloud extraction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An empty pointcloud if the conversion fails. If</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">project_valid_depth_only</td><td>is true, return point cloud, which doesn't have nan point. If the value is false, return point cloud, which has a point for each pixel, whereas invalid depth results in NaN points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa726a64d050c5f7dd46d2419c682ac37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa726a64d050c5f7dd46d2419c682ac37">&#9670;&nbsp;</a></span>CreateFromRGBDImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::CreateFromRGBDImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_r_g_b_d_image.37">RGBDImage</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1camera_1_1_pinhole_camera_int">camera::PinholeCameraIntrinsic</a> &amp;&#160;</td>
          <td class="paramname"><em>intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4d &amp;&#160;</td>
          <td class="paramname"><em>extrinsic</em> = <code>Eigen::Matrix4d::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project_valid_depth_only</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to create a pointcloud from an RGB-D image and a camera model. </p>
<p>Given depth value d at (u, v) image coordinate, the corresponding 3d point is: z = d / depth_scale<br  />
 x = (u - cx) * z / fx<br  />
 y = (v - cy) * z / fy<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The input image. </td></tr>
    <tr><td class="paramname">intrinsic</td><td>Intrinsic parameters of the camera. </td></tr>
    <tr><td class="paramname">extrinsic</td><td>Extrinsic parameters of the camera.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An empty pointcloud if the conversion fails. If</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">project_valid_depth_only</td><td>is true, return point cloud, which doesn't have nan point. If the value is false, return point cloud, which has a point for each pixel, whereas invalid depth results in NaN points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa82ba6551d1b1eea6daecaaa825c3ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82ba6551d1b1eea6daecaaa825c3ebf">&#9670;&nbsp;</a></span>CreateFromVoxelGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::CreateFromVoxelGrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_voxel_grid.426.d">VoxelGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>voxel_grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory Function to create a <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> from a <a class="el" href="classopen3d_1_1geometry_1_1_voxel_grid.426.d" title="VoxelGrid is a collection of voxels which are aligned in grid.">VoxelGrid</a>. </p>
<p>It transforms the voxel centers to 3D points using the original point cloud coordinate (with respect to the center of the voxel grid).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voxel_grid</td><td>The input <a class="el" href="classopen3d_1_1geometry_1_1_voxel_grid.426.d" title="VoxelGrid is a collection of voxels which are aligned in grid.">VoxelGrid</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8b08dd04ee328c9bd186213b94fbaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b08dd04ee328c9bd186213b94fbaa2">&#9670;&nbsp;</a></span>Crop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::Crop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou">AxisAlignedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to crop pointcloud into output pointcloud. </p>
<p>All points with coordinates outside the bounding box <code>bbox</code> are clipped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td><a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou" title="A bounding box that is aligned along the coordinate axes.">AxisAlignedBoundingBox</a> to crop points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f1cf9684475ed4bdbb20923baccc6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1cf9684475ed4bdbb20923baccc6ee">&#9670;&nbsp;</a></span>Crop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::Crop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to crop pointcloud into output pointcloud. </p>
<p>All points with coordinates outside the bounding box <code>bbox</code> are clipped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td><a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin" title="A bounding box oriented along an arbitrary frame of reference.">OrientedBoundingBox</a> to crop points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a251f8768a5724081b8df2799f49348d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251f8768a5724081b8df2799f49348d2">&#9670;&nbsp;</a></span>DetectPlanarPatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> &gt; &gt; open3d::geometry::PointCloud::DetectPlanarPatches </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normal_variance_threshold_deg</em> = <code>60</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coplanarity_deg</em> = <code>75</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outlier_ratio</em> = <code>0.75</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_plane_edge_length</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_num_points</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_">geometry::KDTreeSearchParam</a> &amp;&#160;</td>
          <td class="paramname"><em>search_param</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_-2">geometry::KDTreeSearchParamKNN</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Robustly detect planar patches in the point cloud using. Araújo and Oliveira, “A robust statistics approach for plane detection in unorganized point clouds,” Pattern Recognition, 2020. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal_variance_threshold_deg</td><td>Planes having point normals with high variance are rejected. The default value is 60 deg. Larger values would allow more noisy planes to be detected.</td></tr>
    <tr><td class="paramname">coplanarity_deg</td><td>The curvature of plane detections are scored using the angle between the plane's normal vector and an auxiliary vector. An ideal plane would have a score of 90 deg. The default value for this threshold is 75 deg, and detected planes with scores lower than this are rejected. Large threshold values encourage a tighter distribution of points around the detected plane, i.e., less curvature.</td></tr>
    <tr><td class="paramname">outlier_ratio</td><td>Maximum allowable ratio of outliers in associated plane points before plane is rejected.</td></tr>
    <tr><td class="paramname">min_plane_edge_length</td><td>A patch's largest edge must greater than this value to be considered a true planar patch. If set to 0, defaults to 1% of largest span of point cloud.</td></tr>
    <tr><td class="paramname">min_num_points</td><td>Determines how deep the associated octree becomes and how many points must be used for estimating a plane. If set to 0, defaults to 0.1% of the number of points in point cloud.</td></tr>
    <tr><td class="paramname">search_param</td><td>Point neighbors are used to grow and merge detected planes. Neighbors are found with KDTree search using these params. More neighbors results in higher quality patches at the cost of compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a list of detected planar patches, represented as <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin" title="A bounding box oriented along an arbitrary frame of reference.">OrientedBoundingBox</a> objects, with the third column (z) of R indicating the planar patch normal vector. The extent in the z direction is non-zero so that the <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin" title="A bounding box oriented along an arbitrary frame of reference.">OrientedBoundingBox</a> contains the points that contribute to the plane detection. </dd></dl>

</div>
</div>
<a id="ac91d8bc82f2f60ad2c8ace905447e8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91d8bc82f2f60ad2c8ace905447e8b5">&#9670;&nbsp;</a></span>EstimateCovariances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::PointCloud::EstimateCovariances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_">KDTreeSearchParam</a> &amp;&#160;</td>
          <td class="paramname"><em>search_param</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_-2">KDTreeSearchParamKNN</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the covariance matrix for each point of a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_param</td><td>The KDTree search parameters for neighborhood search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eb1b6e14c8beb0073bded699b3c81a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb1b6e14c8beb0073bded699b3c81a7">&#9670;&nbsp;</a></span>EstimateNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::PointCloud::EstimateNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_">KDTreeSearchParam</a> &amp;&#160;</td>
          <td class="paramname"><em>search_param</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_-2">KDTreeSearchParamKNN</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast_normal_computation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the normals of a point cloud. </p>
<p>Normals are oriented with respect to the input point cloud if normals exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_param</td><td>The KDTree search parameters for neighborhood search. </td></tr>
    <tr><td class="paramname">fast_normal_computation</td><td>If true, the normal estimation uses a non-iterative method to extract the eigenvector from the covariance matrix. This is faster, but is not as numerical stable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18527af0e9a1a0e8f609ac47ca7a6178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18527af0e9a1a0e8f609ac47ca7a6178">&#9670;&nbsp;</a></span>EstimatePerPointCovariances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Matrix3d &gt; open3d::geometry::PointCloud::EstimatePerPointCovariances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_">KDTreeSearchParam</a> &amp;&#160;</td>
          <td class="paramname"><em>search_param</em> = <code><a class="el" href="classopen3d_1_1geometry_1_1_k_d_tree_search_-2">KDTreeSearchParamKNN</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function to compute the covariance matrix for each point of a point cloud. Doesn't change the input <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a>, just outputs the covariance matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> to use for covariance computation</td></tr>
    <tr><td class="paramname">search_param</td><td>The KDTree search parameters for neighborhood search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb39a7008bee3a502d23abf12a43d91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb39a7008bee3a502d23abf12a43d91e">&#9670;&nbsp;</a></span>FarthestPointDownSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::FarthestPointDownSample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_samples</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to downsample input pointcloud into output pointcloud with a set of points has farthest distance. </p>
<p>The sample is performed by selecting the farthest point from previous selected points iteratively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_samples</td><td>Number of points to be sampled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f60f4856e3f665d48628b42c1aa8f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f60f4856e3f665d48628b42c1aa8f28">&#9670;&nbsp;</a></span>GetAxisAlignedBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou">AxisAlignedBoundingBox</a> open3d::geometry::PointCloud::GetAxisAlignedBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates the axis-aligned bounding box around the points of the object. Further details in <a class="el" href="classopen3d_1_1geometry_1_1_axis_aligned_bou#aa697d6ef976789d57c6d8f57711919dc">AxisAlignedBoundingBox::CreateFromPoints()</a> </p>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a6adfe40c8c59be751e3079a2a5cba874">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a1b36be18a575419ecb6a1761f56a4f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b36be18a575419ecb6a1761f56a4f03">&#9670;&nbsp;</a></span>GetCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d open3d::geometry::PointCloud::GetCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the center of the geometry coordinates. </p>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a32d884b24e1a680bf2adecd713182ffb">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a35afe91567f1ecf04c2dba08892175a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35afe91567f1ecf04c2dba08892175a6">&#9670;&nbsp;</a></span>GetMaxBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d open3d::geometry::PointCloud::GetMaxBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns max bounds for geometry coordinates. </p>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a4ba1483835f630921a290c36d0dc0528">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a34cf5bf8e8fc872afb9de353081e0f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cf5bf8e8fc872afb9de353081e0f40">&#9670;&nbsp;</a></span>GetMinBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d open3d::geometry::PointCloud::GetMinBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns min bounds for geometry coordinates. </p>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a5ce0c9ab3b7c4addc07732e69ea0d48d">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a00019e336f74442025fcdaa4c5d20651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00019e336f74442025fcdaa4c5d20651">&#9670;&nbsp;</a></span>GetMinimalOrientedBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> open3d::geometry::PointCloud::GetMinimalOrientedBoundingBox </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>robust</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates the minimal oriented bounding box around the points of the object. Further details in <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin#a00bf997d31d1b43449f89b509ac03f72">OrientedBoundingBox::CreateFromPointsMinimal()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">robust</td><td>If set to true uses a more robust method which works in degenerate cases but introduces noise to the points coordinates. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a371b43251251c0873ca427b8dcb5f309">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a5ace5711205c405794b824849e826c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ace5711205c405794b824849e826c63">&#9670;&nbsp;</a></span>GetOrientedBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin">OrientedBoundingBox</a> open3d::geometry::PointCloud::GetOrientedBoundingBox </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>robust</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an oriented bounding box around the points of the object. Further details in <a class="el" href="classopen3d_1_1geometry_1_1_oriented_boundin#a699fea43ea3dc4e828492e091fc98ba2">OrientedBoundingBox::CreateFromPoints()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">robust</td><td>If set to true uses a more robust method which works in degenerate cases but introduces noise to the points coordinates. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#aa390b8742e15d903bf394cc3b7518d08">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="aed16969e4e65179ee464a137bc838525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed16969e4e65179ee464a137bc838525">&#9670;&nbsp;</a></span>HasColors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::PointCloud::HasColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the point cloud contains point colors. </p>

</div>
</div>
<a id="af3d506b84909fd80f77e6b4e29b55ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d506b84909fd80f77e6b4e29b55ab7">&#9670;&nbsp;</a></span>HasCovariances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::PointCloud::HasCovariances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 'true' if the point cloud contains per-point covariance matrix. </p>

</div>
</div>
<a id="a46de5f6f1509734d131555e040808f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46de5f6f1509734d131555e040808f0b">&#9670;&nbsp;</a></span>HasNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::PointCloud::HasNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the point cloud contains point normals. </p>

</div>
</div>
<a id="a84480f8e1bb3659dce6dc4ccdc1b1420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84480f8e1bb3659dce6dc4ccdc1b1420">&#9670;&nbsp;</a></span>HasPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::PointCloud::HasPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 'true' if the point cloud contains points. </p>

</div>
</div>
<a id="a33652146eb25e593ec4e9076ad05f42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33652146eb25e593ec4e9076ad05f42b">&#9670;&nbsp;</a></span>HiddenPointRemoval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_triangle_mesh.40">TriangleMesh</a> &gt;, std::vector&lt; size_t &gt; &gt; open3d::geometry::PointCloud::HiddenPointRemoval </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>camera_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an implementation of the Hidden Point Removal operator described in Katz et. al. 'Direct Visibility of Point Sets', 2007. </p>
<p>Additional information about the choice of radius for noisy point clouds can be found in Mehra et. al. 'Visibility of Noisy Point Cloud Data', 2010.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera_location</td><td>All points not visible from that location will be removed.</td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the spherical projection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af81645c9fda2cb8ac2545e2848d7f8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81645c9fda2cb8ac2545e2848d7f8e4">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::geometry::PointCloud::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> iff the geometry is empty. </p>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a5cece4be56baea48a365ab22f88f89ea">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="aefcc93ef1df6d9a4df7b8de9c6216d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcc93ef1df6d9a4df7b8de9c6216d21">&#9670;&nbsp;</a></span>NormalizeNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a>&amp; open3d::geometry::PointCloud::NormalizeNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize point normals to length 1. </p>

</div>
</div>
<a id="a2f4c3d5e50b5fbf1123cb81cf2112e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4c3d5e50b5fbf1123cb81cf2112e0e">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> open3d::geometry::PointCloud::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ff8adc02dd574d35c94028f24a4a6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff8adc02dd574d35c94028f24a4a6d8">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp; open3d::geometry::PointCloud::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace86de742d9caa4fe26ff7d50c4cd237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace86de742d9caa4fe26ff7d50c4cd237">&#9670;&nbsp;</a></span>OrientNormalsConsistentTangentPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::PointCloud::OrientNormalsConsistentTangentPlane </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to consistently orient estimated normals based on consistent tangent planes as described in Hoppe et al., "Surface
Reconstruction from Unorganized Points", 1992. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>k nearest neighbour for graph reconstruction for normal propagation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94623ab5a749a0bead96a1b26eaeaaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94623ab5a749a0bead96a1b26eaeaaf6">&#9670;&nbsp;</a></span>OrientNormalsToAlignWithDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::PointCloud::OrientNormalsToAlignWithDirection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>orientation_reference</em> = <code>Eigen::Vector3d(0.0,&#160;0.0,&#160;1.0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to orient the normals of a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation_reference</td><td>Normals are oriented with respect to orientation_reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabc225cbe48338500beed676bbd45c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc225cbe48338500beed676bbd45c59">&#9670;&nbsp;</a></span>OrientNormalsTowardsCameraLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::geometry::PointCloud::OrientNormalsTowardsCameraLocation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>camera_location</em> = <code>Eigen::Vector3d::Zero()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to orient the normals of a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera_location</td><td>Normals are oriented with towards the camera_location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04cdce7eb0b8e4cb14b26579cad0c263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cdce7eb0b8e4cb14b26579cad0c263">&#9670;&nbsp;</a></span>PaintUniformColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a>&amp; open3d::geometry::PointCloud::PaintUniformColor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assigns each point in the <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> the same color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>RGB colors of points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac26dc9de4dbabeb2b4860303fe5772a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26dc9de4dbabeb2b4860303fe5772a0">&#9670;&nbsp;</a></span>RandomDownSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::RandomDownSample </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to downsample input pointcloud into output pointcloud randomly. </p>
<p>The sample is performed by randomly selecting the index of the points in the pointcloud.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampling_ratio</td><td>Sampling ratio, the ratio of sample to total number of points in the pointcloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a873f73997f009c6fd34758289899e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a873f73997f009c6fd34758289899e6">&#9670;&nbsp;</a></span>RemoveDuplicatedPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp; open3d::geometry::PointCloud::RemoveDuplicatedPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes duplicated points, i.e., points that have identical coordinates. It also removes the corresponding attributes associated with the non-finite point such as normals, covariances and color entries. It doesn't re-computes these attributes after removing duplicated points. </p>

</div>
</div>
<a id="a517e572c2db9967e4016aff27acbb8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517e572c2db9967e4016aff27acbb8b3">&#9670;&nbsp;</a></span>RemoveNonFinitePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp; open3d::geometry::PointCloud::RemoveNonFinitePoints </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_nan</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_infinite</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all points from the point cloud that have a nan entry, or infinite entries. It also removes the corresponding attributes associated with the non-finite point such as normals, covariances and color entries. It doesn't re-computes these attributes after removing non-finite points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove_nan</td><td>Remove NaN values from the <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a>. </td></tr>
    <tr><td class="paramname">remove_infinite</td><td>Remove infinite values from the <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe271fc07cb3bd428834fb8cbc48dafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe271fc07cb3bd428834fb8cbc48dafb">&#9670;&nbsp;</a></span>RemoveRadiusOutliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;, std::vector&lt; size_t &gt; &gt; open3d::geometry::PointCloud::RemoveRadiusOutliers </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>search_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to remove points that have less than <code>nb_points</code> in a sphere of a given radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_points</td><td>Number of points within the radius. </td></tr>
    <tr><td class="paramname">search_radius</td><td>Radius of the sphere. </td></tr>
    <tr><td class="paramname">print_progress</td><td>Whether to print the progress bar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c34dee60f36ec36a7de4ae2d55623cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c34dee60f36ec36a7de4ae2d55623cd">&#9670;&nbsp;</a></span>RemoveStatisticalOutliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;, std::vector&lt; size_t &gt; &gt; open3d::geometry::PointCloud::RemoveStatisticalOutliers </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to remove points that are further away from their <code>nb_neighbor</code> neighbors in average. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_neighbors</td><td>Number of neighbors around the target point. </td></tr>
    <tr><td class="paramname">std_ratio</td><td>Standard deviation ratio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90cf4078f98dc88800657a438f036782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cf4078f98dc88800657a438f036782">&#9670;&nbsp;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp; open3d::geometry::PointCloud::Rotate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply rotation to the geometry coordinates and normals. Given a rotation matrix \(R\), and center \(c\), a given point \(p\) is transformed according to \(R (p - c) + c\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3x3 rotation matrix </td></tr>
    <tr><td class="paramname">center</td><td>Rotation center that is used for the rotation. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#aab4555d0b3e65d35450a2ec57a14ff4d">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a58f8f6c660aa06d6a4384d268baa02a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f8f6c660aa06d6a4384d268baa02a9">&#9670;&nbsp;</a></span>Scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp; open3d::geometry::PointCloud::Scale </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply scaling to the geometry coordinates. Given a scaling factor \(s\), and center \(c\), a given point \(p\) is transformed according to \(s (p - c) + c\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The scale parameter that is multiplied to the points/vertices of the geometry. </td></tr>
    <tr><td class="paramname">center</td><td>Scale center that is used to resize the geometry. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a54876d016ceed8e4885dc25b22fa176e">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a00754712b015e2fe8a411bac6b916b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00754712b015e2fe8a411bac6b916b4a">&#9670;&nbsp;</a></span>SegmentPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; Eigen::Vector4d, std::vector&lt; size_t &gt; &gt; open3d::geometry::PointCloud::SegmentPlane </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>distance_threshold</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ransac_n</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_iterations</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>probability</em> = <code>0.99999999</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segment <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b" title="A point cloud consists of point coordinates, and optionally point colors and point normals.">PointCloud</a> plane using the RANSAC algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance_threshold</td><td>Max distance a point can be from the plane model, and still be considered an inlier. </td></tr>
    <tr><td class="paramname">ransac_n</td><td>Number of initial points to be considered inliers in each iteration. </td></tr>
    <tr><td class="paramname">num_iterations</td><td>Maximum number of iterations. </td></tr>
    <tr><td class="paramname">probability</td><td>Expected probability of finding the optimal plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the plane model ax + by + cz + d = 0 and the indices of the plane inliers. </dd></dl>

</div>
</div>
<a id="a86896913ca21d9829b0783c6fd3f980a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86896913ca21d9829b0783c6fd3f980a">&#9670;&nbsp;</a></span>SelectByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::SelectByIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects points from <code>input</code> pointcloud, with indices in <code>indices</code>, and returns a new point-cloud with selected points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Indices of points to be selected. </td></tr>
    <tr><td class="paramname">invert</td><td>Set to <code>True</code> to invert the selection of indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d10c488777e1d881c1c29cad308bae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d10c488777e1d881c1c29cad308bae6">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp; open3d::geometry::PointCloud::Transform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix4d &amp;&#160;</td>
          <td class="paramname"><em>transformation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply transformation (4x4 matrix) to the geometry coordinates. </p>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#ab99e2171cafbe1039aaebd76d178db0d">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a0ff6318cf076cf3f80c2b51bcdf3341c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff6318cf076cf3f80c2b51bcdf3341c">&#9670;&nbsp;</a></span>Translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &amp; open3d::geometry::PointCloud::Translate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relative</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply translation to the geometry coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translation</td><td>A 3D vector to transform the geometry. </td></tr>
    <tr><td class="paramname">relative</td><td>If <code>true</code>, the <code>translation</code> is directly applied to the geometry. Otherwise, the geometry center is moved to the <code>translation</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classopen3d_1_1geometry_1_1_geometry3_d.402#a167e8cb72ba68af89c6f418d59dc8bfd">open3d::geometry::Geometry3D</a>.</p>

</div>
</div>
<a id="a73b4bc4b7dde2faf02252d747e238614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b4bc4b7dde2faf02252d747e238614">&#9670;&nbsp;</a></span>UniformDownSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::UniformDownSample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>every_k_points</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to downsample input pointcloud into output pointcloud uniformly. </p>
<p>The sample is performed in the order of the points with the 0-th point always chosen, not at random.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">every_k_points</td><td>Sample rate, the selected point indices are [0, k, 2k, …]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50efddf2d460dccf3de46cd0d38071af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50efddf2d460dccf3de46cd0d38071af">&#9670;&nbsp;</a></span>VoxelDownSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt; open3d::geometry::PointCloud::VoxelDownSample </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>voxel_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downsample input pointcloud with a voxel, and return a new point-cloud. Normals, covariances and colors are averaged if they exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voxel_size</td><td>Defines the resolution of the voxel grid, smaller value leads to denser output point cloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9501d41a742c2f69f4b01e1921865a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9501d41a742c2f69f4b01e1921865a3d">&#9670;&nbsp;</a></span>VoxelDownSampleAndTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">PointCloud</a> &gt;, Eigen::MatrixXi, std::vector&lt; std::vector&lt; int &gt; &gt; &gt; open3d::geometry::PointCloud::VoxelDownSampleAndTrace </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>min_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>max_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>approximate_class</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to downsample using <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b#a50efddf2d460dccf3de46cd0d38071af" title="Downsample input pointcloud with a voxel, and return a new point-cloud. Normals, covariances and colo...">geometry.PointCloud.VoxelDownSample</a>. </p>
<p>Also records point cloud index before downsampling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voxel_size</td><td><a class="el" href="classopen3d_1_1geometry_1_1_voxel.425.delaye" title="Base Voxel class, containing grid id and color.">Voxel</a> size to downsample into. </td></tr>
    <tr><td class="paramname">min_bound</td><td>Minimum coordinate of voxel boundaries </td></tr>
    <tr><td class="paramname">max_bound</td><td>Maximum coordinate of voxel boundaries </td></tr>
    <tr><td class="paramname">approximate_class</td><td>Whether to approximate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a01d9fb6adaf53966279be1cb611b22f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d9fb6adaf53966279be1cb611b22f0">&#9670;&nbsp;</a></span>colors_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; open3d::geometry::PointCloud::colors_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RGB colors of points. </p>

</div>
</div>
<a id="a08324d3049f9048c2f8c6224fc564347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08324d3049f9048c2f8c6224fc564347">&#9670;&nbsp;</a></span>covariances_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Matrix3d&gt; open3d::geometry::PointCloud::covariances_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Covariance Matrix for each point. </p>

</div>
</div>
<a id="aa94983bb5c7a3475e3671b64c6280427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94983bb5c7a3475e3671b64c6280427">&#9670;&nbsp;</a></span>normals_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; open3d::geometry::PointCloud::normals_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Points normals. </p>

</div>
</div>
<a id="ac65618ae6fd935898925293aeb7189e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65618ae6fd935898925293aeb7189e1">&#9670;&nbsp;</a></span>points_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Vector3d&gt; open3d::geometry::PointCloud::points_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Points coordinates. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="geometry_2_point_cloud_8h_source.html">PointCloud.h (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_estimate_normals_8cpp.html">EstimateNormals.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="geometry_2_point_cloud_8cpp.html">PointCloud.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_point_cloud_cluster_8cpp.html">PointCloudCluster.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_point_cloud_factory_8cpp.html">PointCloudFactory.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_point_cloud_planar_patch_detection_8cpp.3c3">PointCloudPlanarPatchDetection.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/geometry/<a class="el" href="_point_cloud_segmentation_8cpp.html">PointCloudSegmentation.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/classopen3d_1_1geometry_1_1_point_cloud.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:56:10 GMT -->
</html>
