<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/classopen3d_1_1t_1_1geometry_1_1_point_cloud.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:53:55 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open3D (C++ API): open3d::t::geometry::PointCloud Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.html", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="../../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3TQPKGV6Z3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-3TQPKGV6Z3');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="open3d_logo.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open3D (C++ API)
   &#160;<span id="projectnumber">0.17.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.html','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopen3d.html">open3d</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1t.html">t</a></li><li class="navelem"><a class="el" href="namespaceopen3d_1_1t_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">open3d::t::geometry::PointCloud Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A point cloud contains a list of 3D points.  
 <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="t_2geometry_2_point_cloud_8h_source.4c1.dela">PointCloud.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for open3d::t::geometry::PointCloud:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classopen3d_1_1t_1_1geometry_1_1_point_cloud-2" usemap="#open3d::t::geometry::PointCloud_map" alt=""/>
  <map id="open3d::t::geometry::PointCloud_map" name="open3d::t::geometry::PointCloud_map">
<area href="classopen3d_1_1t_1_1geometry_1_1_geometry.36" title="The base geometry class." alt="open3d::t::geometry::Geometry" shape="rect" coords="0,56,235,80"/>
<area href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge" title="Mix-in class for geometry types that can be visualized." alt="open3d::t::geometry::DrawableGeometry" shape="rect" coords="245,56,480,80"/>
<area href="classopen3d_1_1core_1_1_is_device.36f.delaye" alt="open3d::core::IsDevice" shape="rect" coords="0,0,235,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac001f386d9a09c1d3673981bca3af06e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac001f386d9a09c1d3673981bca3af06e">PointCloud</a> (const <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a> &amp;device=<a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;))</td></tr>
<tr class="separator:ac001f386d9a09c1d3673981bca3af06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3700386b81528d462ea77b5a7053755c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a3700386b81528d462ea77b5a7053755c">PointCloud</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;<a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#af7f8f4a4e39e09fdb5e9f02330ecabef">points</a>)</td></tr>
<tr class="separator:a3700386b81528d462ea77b5a7053755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8785b3e979660334bfa20313f7d17869"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a8785b3e979660334bfa20313f7d17869">PointCloud</a> (const std::unordered_map&lt; std::string, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; &amp;map_keys_to_tensors)</td></tr>
<tr class="separator:a8785b3e979660334bfa20313f7d17869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc6dd2187ce0e0a6ec1ee7e0adc4026"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aadc6dd2187ce0e0a6ec1ee7e0adc4026">~PointCloud</a> () override</td></tr>
<tr class="separator:aadc6dd2187ce0e0a6ec1ee7e0adc4026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe724473aae5841aae4ad0a6fd0f2063"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#abe724473aae5841aae4ad0a6fd0f2063">ToString</a> () const</td></tr>
<tr class="memdesc:abe724473aae5841aae4ad0a6fd0f2063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Text description.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#abe724473aae5841aae4ad0a6fd0f2063">More...</a><br /></td></tr>
<tr class="separator:abe724473aae5841aae4ad0a6fd0f2063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accccfd3582713631f3d6c97796da37f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#accccfd3582713631f3d6c97796da37f6">GetPointAttr</a> () const</td></tr>
<tr class="memdesc:accccfd3582713631f3d6c97796da37f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for point_attr_ <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a>. Used in Pybind.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#accccfd3582713631f3d6c97796da37f6">More...</a><br /></td></tr>
<tr class="separator:accccfd3582713631f3d6c97796da37f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fc2674c6746f2573da0f1bb9ff67c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad6fc2674c6746f2573da0f1bb9ff67c5">GetPointAttr</a> ()</td></tr>
<tr class="memdesc:ad6fc2674c6746f2573da0f1bb9ff67c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for point_attr_ <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad6fc2674c6746f2573da0f1bb9ff67c5">More...</a><br /></td></tr>
<tr class="separator:ad6fc2674c6746f2573da0f1bb9ff67c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d7a0f6d3dc6204ed1751f060f1722b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a00d7a0f6d3dc6204ed1751f060f1722b">GetPointAttr</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a00d7a0f6d3dc6204ed1751f060f1722b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb68920f902c562c26835c1e497ae333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#abb68920f902c562c26835c1e497ae333">GetPointPositions</a> ()</td></tr>
<tr class="memdesc:abb68920f902c562c26835c1e497ae333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the "positions" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#abb68920f902c562c26835c1e497ae333">More...</a><br /></td></tr>
<tr class="separator:abb68920f902c562c26835c1e497ae333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85426e69fed8c00e6608d7d1574e88e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a85426e69fed8c00e6608d7d1574e88e7">GetPointColors</a> ()</td></tr>
<tr class="memdesc:a85426e69fed8c00e6608d7d1574e88e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the "colors" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a85426e69fed8c00e6608d7d1574e88e7">More...</a><br /></td></tr>
<tr class="separator:a85426e69fed8c00e6608d7d1574e88e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45095ecce4dfe3bd47c001773ba4c91d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a45095ecce4dfe3bd47c001773ba4c91d">GetPointNormals</a> ()</td></tr>
<tr class="memdesc:a45095ecce4dfe3bd47c001773ba4c91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the "normals" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a45095ecce4dfe3bd47c001773ba4c91d">More...</a><br /></td></tr>
<tr class="separator:a45095ecce4dfe3bd47c001773ba4c91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a47951e42d5a0352ddba68e756f181"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a44a47951e42d5a0352ddba68e756f181">GetPointAttr</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a44a47951e42d5a0352ddba68e756f181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403de24beb059f18d718a6c33aa6d482"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a403de24beb059f18d718a6c33aa6d482">GetPointPositions</a> () const</td></tr>
<tr class="memdesc:a403de24beb059f18d718a6c33aa6d482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the "positions" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a403de24beb059f18d718a6c33aa6d482">More...</a><br /></td></tr>
<tr class="separator:a403de24beb059f18d718a6c33aa6d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d5de91926460a5c243648bde8dda96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a70d5de91926460a5c243648bde8dda96">GetPointColors</a> () const</td></tr>
<tr class="memdesc:a70d5de91926460a5c243648bde8dda96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the "colors" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a70d5de91926460a5c243648bde8dda96">More...</a><br /></td></tr>
<tr class="separator:a70d5de91926460a5c243648bde8dda96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ad2807050ff5303c812d5a182952c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a97ad2807050ff5303c812d5a182952c7">GetPointNormals</a> () const</td></tr>
<tr class="memdesc:a97ad2807050ff5303c812d5a182952c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the "normals" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a97ad2807050ff5303c812d5a182952c7">More...</a><br /></td></tr>
<tr class="separator:a97ad2807050ff5303c812d5a182952c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae798189d80f459ae746850cb67bae964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ae798189d80f459ae746850cb67bae964">SetPointAttr</a> (const std::string &amp;key, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;value)</td></tr>
<tr class="separator:ae798189d80f459ae746850cb67bae964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6264648914705fcb375bbc5f8878ae45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a6264648914705fcb375bbc5f8878ae45">SetPointPositions</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;value)</td></tr>
<tr class="memdesc:a6264648914705fcb375bbc5f8878ae45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the "positions" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a6264648914705fcb375bbc5f8878ae45">More...</a><br /></td></tr>
<tr class="separator:a6264648914705fcb375bbc5f8878ae45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e422ab4b4cc38253ea4861bff3fa07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a64e422ab4b4cc38253ea4861bff3fa07">SetPointColors</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;value)</td></tr>
<tr class="memdesc:a64e422ab4b4cc38253ea4861bff3fa07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the "colors" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a64e422ab4b4cc38253ea4861bff3fa07">More...</a><br /></td></tr>
<tr class="separator:a64e422ab4b4cc38253ea4861bff3fa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05550eef541d8b68af1c08a0e4cdcfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#af05550eef541d8b68af1c08a0e4cdcfe">SetPointNormals</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;value)</td></tr>
<tr class="memdesc:af05550eef541d8b68af1c08a0e4cdcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the "normals" attribute. Convenience function.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#af05550eef541d8b68af1c08a0e4cdcfe">More...</a><br /></td></tr>
<tr class="separator:af05550eef541d8b68af1c08a0e4cdcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf97355470fb6f77273ab149a365f23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a0cf97355470fb6f77273ab149a365f23">HasPointAttr</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a0cf97355470fb6f77273ab149a365f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf172bb1a59d3e7ddb5877183b259d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aaf172bb1a59d3e7ddb5877183b259d23">RemovePointAttr</a> (const std::string &amp;key)</td></tr>
<tr class="separator:aaf172bb1a59d3e7ddb5877183b259d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f6597f210ddb370a944ede9c625798"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a41f6597f210ddb370a944ede9c625798">HasPointPositions</a> () const</td></tr>
<tr class="separator:a41f6597f210ddb370a944ede9c625798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bc1ab5ddb08c22ca053572d9bab104"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a43bc1ab5ddb08c22ca053572d9bab104">HasPointColors</a> () const</td></tr>
<tr class="separator:a43bc1ab5ddb08c22ca053572d9bab104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97367e796ffa8942792d196b832ab16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#af97367e796ffa8942792d196b832ab16">HasPointNormals</a> () const</td></tr>
<tr class="separator:af97367e796ffa8942792d196b832ab16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5274fac4aa6c2dd05aa78226b60cc4c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5274fac4aa6c2dd05aa78226b60cc4c9">To</a> (const <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a> &amp;device, bool <a class="el" href="_vtk_utils_8cpp.html#acad86cc31af25e3d02b6d43041d0c6e9">copy</a>=false) const</td></tr>
<tr class="separator:a5274fac4aa6c2dd05aa78226b60cc4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8dcb1293163a132aac40fdcf921596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aae8dcb1293163a132aac40fdcf921596">Clone</a> () const</td></tr>
<tr class="memdesc:aae8dcb1293163a132aac40fdcf921596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns copy of the point cloud on the same device.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aae8dcb1293163a132aac40fdcf921596">More...</a><br /></td></tr>
<tr class="separator:aae8dcb1293163a132aac40fdcf921596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115ef6bfa45fcac0e19f3c25e7798d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a115ef6bfa45fcac0e19f3c25e7798d02">Clear</a> () override</td></tr>
<tr class="memdesc:a115ef6bfa45fcac0e19f3c25e7798d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all data in the point cloud.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a115ef6bfa45fcac0e19f3c25e7798d02">More...</a><br /></td></tr>
<tr class="separator:a115ef6bfa45fcac0e19f3c25e7798d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e67fbf0b6441e7884ca107215792cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a72e67fbf0b6441e7884ca107215792cf">IsEmpty</a> () const override</td></tr>
<tr class="memdesc:a72e67fbf0b6441e7884ca107215792cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns !HasPointPositions().  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a72e67fbf0b6441e7884ca107215792cf">More...</a><br /></td></tr>
<tr class="separator:a72e67fbf0b6441e7884ca107215792cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adc9d964d5986442169724e9b015a1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a9adc9d964d5986442169724e9b015a1e">GetMinBound</a> () const</td></tr>
<tr class="memdesc:a9adc9d964d5986442169724e9b015a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the min bound for point coordinates.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a9adc9d964d5986442169724e9b015a1e">More...</a><br /></td></tr>
<tr class="separator:a9adc9d964d5986442169724e9b015a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a9818e4fc15f325cc9d987ca81c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad80a9818e4fc15f325cc9d987ca81c57">GetMaxBound</a> () const</td></tr>
<tr class="memdesc:ad80a9818e4fc15f325cc9d987ca81c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max bound for point coordinates.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad80a9818e4fc15f325cc9d987ca81c57">More...</a><br /></td></tr>
<tr class="separator:ad80a9818e4fc15f325cc9d987ca81c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4191167d3be9f3ccab2e4a4341fdfee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac4191167d3be9f3ccab2e4a4341fdfee">GetCenter</a> () const</td></tr>
<tr class="memdesc:ac4191167d3be9f3ccab2e4a4341fdfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the center for point coordinates.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac4191167d3be9f3ccab2e4a4341fdfee">More...</a><br /></td></tr>
<tr class="separator:ac4191167d3be9f3ccab2e4a4341fdfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e31065d101b408dab673e40a7a0dcec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a8e31065d101b408dab673e40a7a0dcec">Append</a> (const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;other) const</td></tr>
<tr class="separator:a8e31065d101b408dab673e40a7a0dcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f1422fe12cd196bbb9a95096ddea78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac6f1422fe12cd196bbb9a95096ddea78">operator+</a> (const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;other) const</td></tr>
<tr class="separator:ac6f1422fe12cd196bbb9a95096ddea78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb83123f5168bb86c788195e2dd9ff5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#abb83123f5168bb86c788195e2dd9ff5f">Transform</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;transformation)</td></tr>
<tr class="memdesc:abb83123f5168bb86c788195e2dd9ff5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the PointPositions and PointNormals (if exist) of the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#abb83123f5168bb86c788195e2dd9ff5f">More...</a><br /></td></tr>
<tr class="separator:abb83123f5168bb86c788195e2dd9ff5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd856dd9bb2c55e4c59d8cfcff861f14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#afd856dd9bb2c55e4c59d8cfcff861f14">Translate</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;translation, bool relative=true)</td></tr>
<tr class="memdesc:afd856dd9bb2c55e4c59d8cfcff861f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the PointPositions of the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#afd856dd9bb2c55e4c59d8cfcff861f14">More...</a><br /></td></tr>
<tr class="separator:afd856dd9bb2c55e4c59d8cfcff861f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4448b7581ace1ea9c62dbf11312a2b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a4448b7581ace1ea9c62dbf11312a2b30">Scale</a> (double scale, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;center)</td></tr>
<tr class="memdesc:a4448b7581ace1ea9c62dbf11312a2b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the PointPositions of the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a4448b7581ace1ea9c62dbf11312a2b30">More...</a><br /></td></tr>
<tr class="separator:a4448b7581ace1ea9c62dbf11312a2b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c12271b77ec218efce5c445be840d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a1c12271b77ec218efce5c445be840d0e">Rotate</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;R, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;center)</td></tr>
<tr class="memdesc:a1c12271b77ec218efce5c445be840d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the PointPositions and PointNormals (if exists).  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a1c12271b77ec218efce5c445be840d0e">More...</a><br /></td></tr>
<tr class="separator:a1c12271b77ec218efce5c445be840d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10907bcfc70eee5d2b18e8055413547f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a10907bcfc70eee5d2b18e8055413547f">PaintUniformColor</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;<a class="el" href="_triangle_mesh_buffers_8cpp.html#aa332976d803be75beb81e81af320bfcb">color</a>)</td></tr>
<tr class="memdesc:a10907bcfc70eee5d2b18e8055413547f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns uniform color to the point cloud.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a10907bcfc70eee5d2b18e8055413547f">More...</a><br /></td></tr>
<tr class="separator:a10907bcfc70eee5d2b18e8055413547f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef837487d72cab185ee929f30b8fba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aeef837487d72cab185ee929f30b8fba7">SelectByMask</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;boolean_mask, bool invert=false) const</td></tr>
<tr class="memdesc:aeef837487d72cab185ee929f30b8fba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select points from input pointcloud, based on boolean mask indices into output point cloud.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aeef837487d72cab185ee929f30b8fba7">More...</a><br /></td></tr>
<tr class="separator:aeef837487d72cab185ee929f30b8fba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99efd0de12ffb7f7d955fd6d1a4b6c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ae99efd0de12ffb7f7d955fd6d1a4b6c0">SelectByIndex</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;indices, bool invert=false, bool remove_duplicates=false) const</td></tr>
<tr class="memdesc:ae99efd0de12ffb7f7d955fd6d1a4b6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select points from input pointcloud, based on indices list into output point cloud.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ae99efd0de12ffb7f7d955fd6d1a4b6c0">More...</a><br /></td></tr>
<tr class="separator:ae99efd0de12ffb7f7d955fd6d1a4b6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747e97aeaea54ab600101c892d88eda9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a747e97aeaea54ab600101c892d88eda9">VoxelDownSample</a> (double voxel_size, const <a class="el" href="namespaceopen3d_1_1core.html#aa9cb3aa033abd5eb2b1bd42d3dc10a83">core::HashBackendType</a> &amp;backend=<a class="el" href="namespaceopen3d_1_1core.html#aa9cb3aa033abd5eb2b1bd42d3dc10a83a7a1920d61156abc05a60135aefe8bc67">core::HashBackendType::Default</a>) const</td></tr>
<tr class="memdesc:a747e97aeaea54ab600101c892d88eda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsamples a point cloud with a specified voxel size.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a747e97aeaea54ab600101c892d88eda9">More...</a><br /></td></tr>
<tr class="separator:a747e97aeaea54ab600101c892d88eda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fae69dd8c02835b0e7567089ec5cda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a10fae69dd8c02835b0e7567089ec5cda">UniformDownSample</a> (size_t every_k_points) const</td></tr>
<tr class="memdesc:a10fae69dd8c02835b0e7567089ec5cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsamples a point cloud by selecting every kth index point and its attributes.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a10fae69dd8c02835b0e7567089ec5cda">More...</a><br /></td></tr>
<tr class="separator:a10fae69dd8c02835b0e7567089ec5cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7b27ca434d5b9e2fb35c9a89a4e564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a9e7b27ca434d5b9e2fb35c9a89a4e564">RandomDownSample</a> (double sampling_ratio) const</td></tr>
<tr class="memdesc:a9e7b27ca434d5b9e2fb35c9a89a4e564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsample a pointcloud by selecting random index point and its attributes.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a9e7b27ca434d5b9e2fb35c9a89a4e564">More...</a><br /></td></tr>
<tr class="separator:a9e7b27ca434d5b9e2fb35c9a89a4e564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94240a5ca59426f0ed5f08624d875a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a94240a5ca59426f0ed5f08624d875a60">FarthestPointDownSample</a> (size_t num_samples) const</td></tr>
<tr class="memdesc:a94240a5ca59426f0ed5f08624d875a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsample a pointcloud into output pointcloud with a set of points has farthest distance.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a94240a5ca59426f0ed5f08624d875a60">More...</a><br /></td></tr>
<tr class="separator:a94240a5ca59426f0ed5f08624d875a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0bc045e52dab0aeda39f1e0c408b8c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a3e0bc045e52dab0aeda39f1e0c408b8c">RemoveRadiusOutliers</a> (size_t nb_points, double search_radius) const</td></tr>
<tr class="memdesc:a3e0bc045e52dab0aeda39f1e0c408b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove points that have less than <code>nb_points</code> neighbors in a sphere of a given radius.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a3e0bc045e52dab0aeda39f1e0c408b8c">More...</a><br /></td></tr>
<tr class="separator:a3e0bc045e52dab0aeda39f1e0c408b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c3c5fdea3588af7c3d29f8b05cc36f"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a00c3c5fdea3588af7c3d29f8b05cc36f">RemoveStatisticalOutliers</a> (size_t nb_neighbors, double std_ratio) const</td></tr>
<tr class="memdesc:a00c3c5fdea3588af7c3d29f8b05cc36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove points that are further away from their <code>nb_neighbor</code> neighbors in average. This function is not recommended to use on GPU.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a00c3c5fdea3588af7c3d29f8b05cc36f">More...</a><br /></td></tr>
<tr class="separator:a00c3c5fdea3588af7c3d29f8b05cc36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5fc8650a6a3c84a292711dfb0c6b9b"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a3f5fc8650a6a3c84a292711dfb0c6b9b">RemoveDuplicatedPoints</a> () const</td></tr>
<tr class="memdesc:a3f5fc8650a6a3c84a292711dfb0c6b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicated points and there associated attributes.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a3f5fc8650a6a3c84a292711dfb0c6b9b">More...</a><br /></td></tr>
<tr class="separator:a3f5fc8650a6a3c84a292711dfb0c6b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7da76e90a6f0a7a01cd237d2b2f3d00"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ab7da76e90a6f0a7a01cd237d2b2f3d00">RemoveNonFinitePoints</a> (bool remove_nan=true, bool remove_infinite=true) const</td></tr>
<tr class="memdesc:ab7da76e90a6f0a7a01cd237d2b2f3d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all points from the point cloud that have a nan entry, or infinite value. It also removes the corresponding attributes.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ab7da76e90a6f0a7a01cd237d2b2f3d00">More...</a><br /></td></tr>
<tr class="separator:ab7da76e90a6f0a7a01cd237d2b2f3d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bae0e4f704ba9d8094081abfa24a729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5bae0e4f704ba9d8094081abfa24a729">GetDevice</a> () const override</td></tr>
<tr class="memdesc:a5bae0e4f704ba9d8094081abfa24a729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device attribute of this <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5bae0e4f704ba9d8094081abfa24a729">More...</a><br /></td></tr>
<tr class="separator:a5bae0e4f704ba9d8094081abfa24a729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad275b1cebf88f19caaa4ef4f2b7c162c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_triangle_me">TriangleMesh</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad275b1cebf88f19caaa4ef4f2b7c162c">HiddenPointRemoval</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;camera_location, double radius) const</td></tr>
<tr class="memdesc:ad275b1cebf88f19caaa4ef4f2b7c162c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation of the Hidden Point Removal operator described in Katz et. al. 'Direct Visibility of Point Sets', 2007.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad275b1cebf88f19caaa4ef4f2b7c162c">More...</a><br /></td></tr>
<tr class="separator:ad275b1cebf88f19caaa4ef4f2b7c162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66aae75533c9f4aec317b97d7cb1a7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a66aae75533c9f4aec317b97d7cb1a7d6">ClusterDBSCAN</a> (double eps, size_t min_points, bool print_progress=false) const</td></tr>
<tr class="memdesc:a66aae75533c9f4aec317b97d7cb1a7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> using the DBSCAN algorithm Ester et al., "A Density-Based Algorithm for Discovering Clusters
in Large Spatial Databases with Noise", 1996 This is a wrapper for a CPU implementation and a copy of the point cloud data and resulting labels will be made.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a66aae75533c9f4aec317b97d7cb1a7d6">More...</a><br /></td></tr>
<tr class="separator:a66aae75533c9f4aec317b97d7cb1a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5167a96d3785f29cb410cd059242ae"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a2a5167a96d3785f29cb410cd059242ae">SegmentPlane</a> (const double distance_threshold=0.01, const int ransac_n=3, const int num_iterations=100, const double probability=0.99999999) const</td></tr>
<tr class="memdesc:a2a5167a96d3785f29cb410cd059242ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> plane using the RANSAC algorithm. This is a wrapper for a CPU implementation and a copy of the point cloud data and resulting plane model and inlier indiecs will be made.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a2a5167a96d3785f29cb410cd059242ae">More...</a><br /></td></tr>
<tr class="separator:a2a5167a96d3785f29cb410cd059242ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a72c9991ec940d5c43687169cc263ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_triangle_me">TriangleMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a3a72c9991ec940d5c43687169cc263ab">ComputeConvexHull</a> (bool joggle_inputs=false) const</td></tr>
<tr class="separator:a3a72c9991ec940d5c43687169cc263ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5778a28c894b1abf013eaba881b16e10"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5778a28c894b1abf013eaba881b16e10">ComputeBoundaryPoints</a> (double radius, int max_nn=30, double angle_threshold=90.0) const</td></tr>
<tr class="memdesc:a5778a28c894b1abf013eaba881b16e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the boundary points of a point cloud. The implementation is inspired by the PCL implementation. Reference: <a href="https://pointclouds.org/documentation/classpcl_1_1_boundary_estimation.html">https://pointclouds.org/documentation/classpcl_1_1_boundary_estimation.html</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5778a28c894b1abf013eaba881b16e10">More...</a><br /></td></tr>
<tr class="separator:a5778a28c894b1abf013eaba881b16e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f801ad41fefe62abb126312418778bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a4f801ad41fefe62abb126312418778bf">NormalizeNormals</a> ()</td></tr>
<tr class="memdesc:a4f801ad41fefe62abb126312418778bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize point normals to length 1.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a4f801ad41fefe62abb126312418778bf">More...</a><br /></td></tr>
<tr class="separator:a4f801ad41fefe62abb126312418778bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4937528c4b6194092631f002bccc44d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a4937528c4b6194092631f002bccc44d0">EstimateNormals</a> (const <a class="el" href="classopen3d_1_1utility_1_1optional.3c6.delay">utility::optional</a>&lt; int &gt; max_nn=30, const <a class="el" href="classopen3d_1_1utility_1_1optional.3c6.delay">utility::optional</a>&lt; double &gt; radius=<a class="el" href="namespaceopen3d_1_1utility.html#aecfc2255664b95bf9a25f06442b978e2">utility::nullopt</a>)</td></tr>
<tr class="memdesc:a4937528c4b6194092631f002bccc44d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to estimate point normals. If the point cloud normals exist, the estimated normals are oriented with respect to the same. It uses KNN search (Not recommended to use on GPU) if only max_nn parameter is provided, Radius search (Not recommended to use on GPU) if only radius is provided and Hybrid Search (Recommended) if radius parameter is also provided.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a4937528c4b6194092631f002bccc44d0">More...</a><br /></td></tr>
<tr class="separator:a4937528c4b6194092631f002bccc44d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99387de01a21dca5a14811c420188335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a99387de01a21dca5a14811c420188335">OrientNormalsToAlignWithDirection</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;orientation_reference=<a class="el" href="classopen3d_1_1core_1_1_tensor.html#abdd4023d4d72aaa52a26ac391281c4a0">core::Tensor::Init</a>&lt; float &gt;({0, 0, 1}, <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)))</td></tr>
<tr class="memdesc:a99387de01a21dca5a14811c420188335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to orient the normals of a point cloud.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a99387de01a21dca5a14811c420188335">More...</a><br /></td></tr>
<tr class="separator:a99387de01a21dca5a14811c420188335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4771ebe4e8e260f01309a344159342c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad4771ebe4e8e260f01309a344159342c">OrientNormalsTowardsCameraLocation</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;camera_location=<a class="el" href="classopen3d_1_1core_1_1_tensor.html#a9a878b99906d1bc0d06a6e5bbf9c892d">core::Tensor::Zeros</a>({3}, <a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>, <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)))</td></tr>
<tr class="memdesc:ad4771ebe4e8e260f01309a344159342c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to orient the normals of a point cloud.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad4771ebe4e8e260f01309a344159342c">More...</a><br /></td></tr>
<tr class="separator:ad4771ebe4e8e260f01309a344159342c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad954de9b70a7eb2046da3706ba54fbf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad954de9b70a7eb2046da3706ba54fbf5">OrientNormalsConsistentTangentPlane</a> (size_t k)</td></tr>
<tr class="memdesc:ad954de9b70a7eb2046da3706ba54fbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to consistently orient estimated normals based on consistent tangent planes as described in Hoppe et al., "Surface
Reconstruction from Unorganized Points", 1992.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad954de9b70a7eb2046da3706ba54fbf5">More...</a><br /></td></tr>
<tr class="separator:ad954de9b70a7eb2046da3706ba54fbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae73e32ab104ba5d8e1462d83a186538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aae73e32ab104ba5d8e1462d83a186538">EstimateColorGradients</a> (const <a class="el" href="classopen3d_1_1utility_1_1optional.3c6.delay">utility::optional</a>&lt; int &gt; max_nn=30, const <a class="el" href="classopen3d_1_1utility_1_1optional.3c6.delay">utility::optional</a>&lt; double &gt; radius=<a class="el" href="namespaceopen3d_1_1utility.html#aecfc2255664b95bf9a25f06442b978e2">utility::nullopt</a>)</td></tr>
<tr class="memdesc:aae73e32ab104ba5d8e1462d83a186538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute point color gradients. If radius is provided, then HybridSearch is used, otherwise KNN-Search is used. Reference: Park, Q.-Y. Zhou, and V. Koltun, Colored Point Cloud Registration Revisited, ICCV, 2017. It uses KNN search (Not recommended to use on GPU) if only max_nn parameter is provided, Radius search (Not recommended to use on GPU) if only radius is provided and Hybrid Search (Recommended) if radius parameter is also provided.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aae73e32ab104ba5d8e1462d83a186538">More...</a><br /></td></tr>
<tr class="separator:aae73e32ab104ba5d8e1462d83a186538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8507187480860812b9862396c178950b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">open3d::geometry::PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a8507187480860812b9862396c178950b">ToLegacy</a> () const</td></tr>
<tr class="memdesc:a8507187480860812b9862396c178950b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to a legacy Open3D <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a8507187480860812b9862396c178950b">More...</a><br /></td></tr>
<tr class="separator:a8507187480860812b9862396c178950b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c61cea1a3830b2e2ac4472362fa469e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_image.34e.d">geometry::Image</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5c61cea1a3830b2e2ac4472362fa469e">ProjectToDepthImage</a> (int <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#ad12fc34ce789bce6c8a05d8a17138534">height</a>, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;intrinsics, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;extrinsics=<a class="el" href="classopen3d_1_1core_1_1_tensor.html#ac6bf87480ab991b8efd320e8532c2808">core::Tensor::Eye</a>(4, <a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>, <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)), float depth_scale=1000.0f, float depth_max=3.0f)</td></tr>
<tr class="memdesc:a5c61cea1a3830b2e2ac4472362fa469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a point cloud to a depth image.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5c61cea1a3830b2e2ac4472362fa469e">More...</a><br /></td></tr>
<tr class="separator:a5c61cea1a3830b2e2ac4472362fa469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40430e59ea353f2f48da1a26dcefecd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_r_g_b_d_ima">geometry::RGBDImage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a40430e59ea353f2f48da1a26dcefecd3">ProjectToRGBDImage</a> (int <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#ad12fc34ce789bce6c8a05d8a17138534">height</a>, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;intrinsics, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;extrinsics=<a class="el" href="classopen3d_1_1core_1_1_tensor.html#ac6bf87480ab991b8efd320e8532c2808">core::Tensor::Eye</a>(4, <a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>, <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)), float depth_scale=1000.0f, float depth_max=3.0f)</td></tr>
<tr class="memdesc:a40430e59ea353f2f48da1a26dcefecd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a point cloud to an RGBD image.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a40430e59ea353f2f48da1a26dcefecd3">More...</a><br /></td></tr>
<tr class="separator:a40430e59ea353f2f48da1a26dcefecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728a8183c4ab0f6dc28ec292d62b5a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_axis_aligne">AxisAlignedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a728a8183c4ab0f6dc28ec292d62b5a27">GetAxisAlignedBoundingBox</a> () const</td></tr>
<tr class="memdesc:a728a8183c4ab0f6dc28ec292d62b5a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an axis-aligned bounding box from attribute "positions".  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a728a8183c4ab0f6dc28ec292d62b5a27">More...</a><br /></td></tr>
<tr class="separator:a728a8183c4ab0f6dc28ec292d62b5a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbdd2289dcd7c3c6e3e1e29ebc0d293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_oriented_bo">OrientedBoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5dbdd2289dcd7c3c6e3e1e29ebc0d293">GetOrientedBoundingBox</a> () const</td></tr>
<tr class="memdesc:a5dbdd2289dcd7c3c6e3e1e29ebc0d293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an oriented bounding box from attribute "positions".  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a5dbdd2289dcd7c3c6e3e1e29ebc0d293">More...</a><br /></td></tr>
<tr class="separator:a5dbdd2289dcd7c3c6e3e1e29ebc0d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfb1c8415d4d7216b687ff3b32b5973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a2dfb1c8415d4d7216b687ff3b32b5973">Crop</a> (const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_axis_aligne">AxisAlignedBoundingBox</a> &amp;aabb, bool invert=false) const</td></tr>
<tr class="memdesc:a2dfb1c8415d4d7216b687ff3b32b5973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to crop pointcloud into output pointcloud.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a2dfb1c8415d4d7216b687ff3b32b5973">More...</a><br /></td></tr>
<tr class="separator:a2dfb1c8415d4d7216b687ff3b32b5973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ab6badbab533315f7b7d9113fb2d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac8ab6badbab533315f7b7d9113fb2d9b">Crop</a> (const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_oriented_bo">OrientedBoundingBox</a> &amp;obb, bool invert=false) const</td></tr>
<tr class="memdesc:ac8ab6badbab533315f7b7d9113fb2d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to crop pointcloud into output pointcloud.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac8ab6badbab533315f7b7d9113fb2d9b">More...</a><br /></td></tr>
<tr class="separator:ac8ab6badbab533315f7b7d9113fb2d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8867ee6fd62a878f8fc9a274b810d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_line_set.49">LineSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad8867ee6fd62a878f8fc9a274b810d9d">ExtrudeRotation</a> (double angle, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;axis, int resolution=16, double translation=0.0, bool capping=true) const</td></tr>
<tr class="separator:ad8867ee6fd62a878f8fc9a274b810d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64ccde9d239c907edde85daf2c40d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_line_set.49">LineSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac64ccde9d239c907edde85daf2c40d5a">ExtrudeLinear</a> (const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;vector, double scale=1.0, bool capping=true) const</td></tr>
<tr class="separator:ac64ccde9d239c907edde85daf2c40d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1f669365797bbf4d887b8a3c87f589"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a9b1f669365797bbf4d887b8a3c87f589">PCAPartition</a> (int max_points)</td></tr>
<tr class="separator:a9b1f669365797bbf4d887b8a3c87f589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36">open3d::t::geometry::Geometry</a></td></tr>
<tr class="memitem:aae3fa46ae2c36a9245da717db105a049 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#aae3fa46ae2c36a9245da717db105a049">~Geometry</a> ()</td></tr>
<tr class="separator:aae3fa46ae2c36a9245da717db105a049 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c02f58e26d56a742001b61d5ddb3aee inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88d">GeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a1c02f58e26d56a742001b61d5ddb3aee">GetGeometryType</a> () const</td></tr>
<tr class="memdesc:a1c02f58e26d56a742001b61d5ddb3aee inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of registered geometry types.  <a href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a1c02f58e26d56a742001b61d5ddb3aee">More...</a><br /></td></tr>
<tr class="separator:a1c02f58e26d56a742001b61d5ddb3aee inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d95d1e8e1a279d554140a507d0ece0 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a54d95d1e8e1a279d554140a507d0ece0">Dimension</a> () const</td></tr>
<tr class="memdesc:a54d95d1e8e1a279d554140a507d0ece0 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the geometry is 2D or 3D.  <a href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a54d95d1e8e1a279d554140a507d0ece0">More...</a><br /></td></tr>
<tr class="separator:a54d95d1e8e1a279d554140a507d0ece0 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2d0f2491f0f14b3edc14a6eb458732 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a5f2d0f2491f0f14b3edc14a6eb458732">GetName</a> () const</td></tr>
<tr class="separator:a5f2d0f2491f0f14b3edc14a6eb458732 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f41994b219be5601876f12fe76974de inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a0f41994b219be5601876f12fe76974de">SetName</a> (const std::string &amp;<a class="el" href="_o3_d_visualizer_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="separator:a0f41994b219be5601876f12fe76974de inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classopen3d_1_1core_1_1_is_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classopen3d_1_1core_1_1_is_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classopen3d_1_1core_1_1_is_device.36f.delaye">open3d::core::IsDevice</a></td></tr>
<tr class="memitem:ac8a6c234c0f58bedb9159dd3c4234265 inherit pub_methods_classopen3d_1_1core_1_1_is_device"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1core_1_1_is_device.36f.delaye#ac8a6c234c0f58bedb9159dd3c4234265">IsDevice</a> ()=default</td></tr>
<tr class="separator:ac8a6c234c0f58bedb9159dd3c4234265 inherit pub_methods_classopen3d_1_1core_1_1_is_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c84a4d0808e4c7c2cbf0412097fc7c inherit pub_methods_classopen3d_1_1core_1_1_is_device"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1core_1_1_is_device.36f.delaye#af2c84a4d0808e4c7c2cbf0412097fc7c">~IsDevice</a> ()=default</td></tr>
<tr class="separator:af2c84a4d0808e4c7c2cbf0412097fc7c inherit pub_methods_classopen3d_1_1core_1_1_is_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad123cbf1de3a6b6946af444fa1fc5b39 inherit pub_methods_classopen3d_1_1core_1_1_is_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1core_1_1_is_device.36f.delaye#ad123cbf1de3a6b6946af444fa1fc5b39">IsCPU</a> () const</td></tr>
<tr class="separator:ad123cbf1de3a6b6946af444fa1fc5b39 inherit pub_methods_classopen3d_1_1core_1_1_is_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c611931dafc12b6a40c22799e2316b6 inherit pub_methods_classopen3d_1_1core_1_1_is_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1core_1_1_is_device.36f.delaye#a0c611931dafc12b6a40c22799e2316b6">IsCUDA</a> () const</td></tr>
<tr class="separator:a0c611931dafc12b6a40c22799e2316b6 inherit pub_methods_classopen3d_1_1core_1_1_is_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge">open3d::t::geometry::DrawableGeometry</a></td></tr>
<tr class="memitem:a72987c98386c0a92919cdd2c945af2a2 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#a72987c98386c0a92919cdd2c945af2a2">DrawableGeometry</a> ()</td></tr>
<tr class="separator:a72987c98386c0a92919cdd2c945af2a2 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212ff1f5ddbe6d15294176f3e1a74fe9 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#a212ff1f5ddbe6d15294176f3e1a74fe9">~DrawableGeometry</a> ()</td></tr>
<tr class="separator:a212ff1f5ddbe6d15294176f3e1a74fe9 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabee211f04815b00ceb40719359383b inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#acabee211f04815b00ceb40719359383b">HasMaterial</a> () const</td></tr>
<tr class="memdesc:acabee211f04815b00ceb40719359383b inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a material has been applied to this <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36" title="The base geometry class.">Geometry</a> with SetMaterial.  <a href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#acabee211f04815b00ceb40719359383b">More...</a><br /></td></tr>
<tr class="separator:acabee211f04815b00ceb40719359383b inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8e535253dcc2e15fef36f065b68585 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1visualization_1_1rendering_1_">visualization::rendering::Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#aea8e535253dcc2e15fef36f065b68585">GetMaterial</a> ()</td></tr>
<tr class="memdesc:aea8e535253dcc2e15fef36f065b68585 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get material associated with this <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36" title="The base geometry class.">Geometry</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#aea8e535253dcc2e15fef36f065b68585">More...</a><br /></td></tr>
<tr class="separator:aea8e535253dcc2e15fef36f065b68585 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0d741c69411327df29f4b1701219ce inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopen3d_1_1visualization_1_1rendering_1_">visualization::rendering::Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#a2e0d741c69411327df29f4b1701219ce">GetMaterial</a> () const</td></tr>
<tr class="memdesc:a2e0d741c69411327df29f4b1701219ce inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const reference to material associated with this <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36" title="The base geometry class.">Geometry</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#a2e0d741c69411327df29f4b1701219ce">More...</a><br /></td></tr>
<tr class="separator:a2e0d741c69411327df29f4b1701219ce inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf79ffa4c2bff4e4c4ca97131bef1288 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#acf79ffa4c2bff4e4c4ca97131bef1288">SetMaterial</a> (const <a class="el" href="classopen3d_1_1visualization_1_1rendering_1_">visualization::rendering::Material</a> &amp;material)</td></tr>
<tr class="memdesc:acf79ffa4c2bff4e4c4ca97131bef1288 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the material properties associate with this <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36" title="The base geometry class.">Geometry</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_drawable_ge#acf79ffa4c2bff4e4c4ca97131bef1288">More...</a><br /></td></tr>
<tr class="separator:acf79ffa4c2bff4e4c4ca97131bef1288 inherit pub_methods_classopen3d_1_1t_1_1geometry_1_1_drawable_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa1f3132c5c92a5f8c6d6c2bda20329e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aa1f3132c5c92a5f8c6d6c2bda20329e9">CreateFromDepthImage</a> (const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_image.34e.d">Image</a> &amp;depth, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;intrinsics, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;extrinsics=<a class="el" href="classopen3d_1_1core_1_1_tensor.html#ac6bf87480ab991b8efd320e8532c2808">core::Tensor::Eye</a>(4, <a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>, <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)), float depth_scale=1000.0f, float depth_max=3.0f, int <a class="el" href="_triangle_mesh_buffers_8cpp.html#a3f19cd85df5258a38e4618a89bd5ff46">stride</a>=1, bool with_normals=false)</td></tr>
<tr class="memdesc:aa1f3132c5c92a5f8c6d6c2bda20329e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to create a point cloud from a depth image and a camera model.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aa1f3132c5c92a5f8c6d6c2bda20329e9">More...</a><br /></td></tr>
<tr class="separator:aa1f3132c5c92a5f8c6d6c2bda20329e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa153a7f20a977a9695183884f866938c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aa153a7f20a977a9695183884f866938c">CreateFromRGBDImage</a> (const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_r_g_b_d_ima">RGBDImage</a> &amp;rgbd_image, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;intrinsics, const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;extrinsics=<a class="el" href="classopen3d_1_1core_1_1_tensor.html#ac6bf87480ab991b8efd320e8532c2808">core::Tensor::Eye</a>(4, <a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>, <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)), float depth_scale=1000.0f, float depth_max=3.0f, int <a class="el" href="_triangle_mesh_buffers_8cpp.html#a3f19cd85df5258a38e4618a89bd5ff46">stride</a>=1, bool with_normals=false)</td></tr>
<tr class="memdesc:aa153a7f20a977a9695183884f866938c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to create a point cloud from an RGB-D image and a camera model.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#aa153a7f20a977a9695183884f866938c">More...</a><br /></td></tr>
<tr class="separator:aa153a7f20a977a9695183884f866938c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba5f301a1dab6a56d9a528f2d8107e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac5ba5f301a1dab6a56d9a528f2d8107e">FromLegacy</a> (const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">open3d::geometry::PointCloud</a> &amp;pcd_legacy, <a class="el" href="classopen3d_1_1core_1_1_dtype.html">core::Dtype</a> dtype=<a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>, const <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a> &amp;device=<a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;))</td></tr>
<tr class="memdesc:ac5ba5f301a1dab6a56d9a528f2d8107e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> from a legacy Open3D <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>.  <a href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ac5ba5f301a1dab6a56d9a528f2d8107e">More...</a><br /></td></tr>
<tr class="separator:ac5ba5f301a1dab6a56d9a528f2d8107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4f3f493cc3ae272974eff4becc167b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a4f3f493cc3ae272974eff4becc167b42">device_</a> = <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)</td></tr>
<tr class="separator:a4f3f493cc3ae272974eff4becc167b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6939de5cc0240f2bea082be60975f4cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a6939de5cc0240f2bea082be60975f4cd">point_attr_</a></td></tr>
<tr class="separator:a6939de5cc0240f2bea082be60975f4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classopen3d_1_1t_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classopen3d_1_1t_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36">open3d::t::geometry::Geometry</a></td></tr>
<tr class="memitem:a2058abb1036dfbfb2a9c13fbb7e2a88d inherit pub_types_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88d">GeometryType</a> { <br />
&#160;&#160;<a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88da6fcdc090caeade09d0efd6253932b6f5">Unspecified</a> = 0
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88daee9349b5cdfd717c7e1234edce6b72fa">PointCloud</a> = 1
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88da7fe2447f30c8de08b433c3631d7d78ff">VoxelGrid</a> = 2
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88da3d33fe96c4d284d37a6ee296db5e33ac">Octree</a> = 3
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88dae3e5995e4fc46bdc12e733558dd3120a">LineSet</a> = 4
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88da2ad6a25f1ccff1433467bae74193446e">MeshBase</a> = 5
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88da70be243de75004a602f012fece7c0fad">TriangleMesh</a> = 6
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88daa79a2e14e35ed8368058ad93d3d39dc3">HalfEdgeTriangleMesh</a> = 7
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88dabe53a0541a6d36f6ecb879fa2c584b08">Image</a> = 8
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88da7d64b6deb2cbf0f1712bd6e93b5755ba">RGBDImage</a> = 9
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88da48e9695b4242a3a90ea76c7cc87162de">TetraMesh</a> = 10
, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88daff8b20067506aaf814f1e5df2494c2f1">OrientedBoundingBox</a> = 11
, <br />
&#160;&#160;<a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88da0446516d578c6abaae2f3adc7239fa61">AxisAlignedBoundingBox</a> = 12
<br />
 }</td></tr>
<tr class="memdesc:a2058abb1036dfbfb2a9c13fbb7e2a88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies possible geometry types.  <a href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88d">More...</a><br /></td></tr>
<tr class="separator:a2058abb1036dfbfb2a9c13fbb7e2a88d inherit pub_types_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classopen3d_1_1t_1_1geometry_1_1_geometry')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36">open3d::t::geometry::Geometry</a></td></tr>
<tr class="memitem:a940a78b9e256dbca68764761a4706bcf inherit pro_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a940a78b9e256dbca68764761a4706bcf">Geometry</a> (<a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a2058abb1036dfbfb2a9c13fbb7e2a88d">GeometryType</a> <a class="el" href="io_2file__format_2_file_p_c_d_8cpp.375.delay#aff17911edc8208aa8ddb1c7c52c78389">type</a>, int dimension)</td></tr>
<tr class="memdesc:a940a78b9e256dbca68764761a4706bcf inherit pro_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized Constructor.  <a href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a940a78b9e256dbca68764761a4706bcf">More...</a><br /></td></tr>
<tr class="separator:a940a78b9e256dbca68764761a4706bcf inherit pro_methods_classopen3d_1_1t_1_1geometry_1_1_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A point cloud contains a list of 3D points. </p>
<p>The point cloud class stores the attribute data in key-value maps, where the key is a string representing the attribute name and the value is a Tensor containing the attribute data. In most cases, the length of an attribute should be equal to the length of the point cloud's "positions".</p>
<ul>
<li>Default attribute: "positions".<ul>
<li>Usage<ul>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#abb68920f902c562c26835c1e497ae333" title="Get the value of the &quot;positions&quot; attribute. Convenience function.">PointCloud::GetPointPositions()</a></li>
<li>PointCloud::SetPointPositions(const Tensor&amp; positions)</li>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a41f6597f210ddb370a944ede9c625798">PointCloud::HasPointPositions()</a></li>
</ul>
</li>
<li>Created by default, required for all pointclouds.</li>
<li>Value tensor must have shape {N, 3}.</li>
<li>The device of "positions" determines the device of the point cloud.</li>
</ul>
</li>
<li>Common attributes: "normals", "colors".<ul>
<li>Usage<ul>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a45095ecce4dfe3bd47c001773ba4c91d" title="Get the value of the &quot;normals&quot; attribute. Convenience function.">PointCloud::GetPointNormals()</a></li>
<li>PointCloud::SetPointNormals(const Tensor&amp; normals)</li>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#af97367e796ffa8942792d196b832ab16">PointCloud::HasPointNormals()</a></li>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a85426e69fed8c00e6608d7d1574e88e7" title="Get the value of the &quot;colors&quot; attribute. Convenience function.">PointCloud::GetPointColors()</a></li>
<li>PointCloud::SetPointColors(const Tensor&amp; colors)</li>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a43bc1ab5ddb08c22ca053572d9bab104">PointCloud::HasPointColors()</a></li>
</ul>
</li>
<li>Not created by default.</li>
<li>Value tensor must have shape {N, 3}.</li>
<li>Value tensor must be on the same device as the point cloud.</li>
<li>Value tensor can have any dtype.</li>
</ul>
</li>
<li>Custom attributes, e.g., "labels", "intensities".<ul>
<li>Usage<ul>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a00d7a0f6d3dc6204ed1751f060f1722b">PointCloud::GetPointAttr(const std::string&amp; key)</a></li>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ae798189d80f459ae746850cb67bae964">PointCloud::SetPointAttr</a>(const std::string&amp; key, const Tensor&amp; value)</li>
<li>PointCloud::HasPointAttr(const std::string&amp; key)</li>
</ul>
</li>
<li>Not created by default. Users can add their own custom attributes.</li>
<li>Value tensor must be on the same device as the point cloud.</li>
<li>Value tensor can have any dtype.</li>
</ul>
</li>
</ul>
<p><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ad6fc2674c6746f2573da0f1bb9ff67c5" title="Getter for point_attr_ TensorMap.">PointCloud::GetPointAttr()</a>, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#ae798189d80f459ae746850cb67bae964">PointCloud::SetPointAttr()</a>, <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a0cf97355470fb6f77273ab149a365f23">PointCloud::HasPointAttr()</a> also work for default attribute "position" and common attributes "normals" and "colors", e.g.,</p><ul>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#abb68920f902c562c26835c1e497ae333" title="Get the value of the &quot;positions&quot; attribute. Convenience function.">PointCloud::GetPointPositions()</a> is the same as <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#accccfd3582713631f3d6c97796da37f6" title="Getter for point_attr_ TensorMap. Used in Pybind.">PointCloud::GetPointAttr</a>("positions")</li>
<li><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#af97367e796ffa8942792d196b832ab16">PointCloud::HasPointNormals()</a> is the same as <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud#a0cf97355470fb6f77273ab149a365f23">PointCloud::HasPointAttr</a>("normals") </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac001f386d9a09c1d3673981bca3af06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac001f386d9a09c1d3673981bca3af06e">&#9670;&nbsp;</a></span>PointCloud() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">open3d::t::geometry::PointCloud::PointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a> &amp;&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an empty point cloud on the provided device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device on which to initialize the point cloud (default: 'CPU:0'). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3700386b81528d462ea77b5a7053755c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3700386b81528d462ea77b5a7053755c">&#9670;&nbsp;</a></span>PointCloud() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">open3d::t::geometry::PointCloud::PointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a point cloud from points.</p>
<p>The input tensor will be directly used as the underlying storage of the point cloud (no memory copy).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>A tensor with element shape {3}. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8785b3e979660334bfa20313f7d17869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8785b3e979660334bfa20313f7d17869">&#9670;&nbsp;</a></span>PointCloud() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">open3d::t::geometry::PointCloud::PointCloud </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::string, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_keys_to_tensors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from points and other attributes of the points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map_keys_to_tensors</td><td>A map of string to Tensor containing points and their attributes. point_dict must contain at least the "positions" key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadc6dd2187ce0e0a6ec1ee7e0adc4026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc6dd2187ce0e0a6ec1ee7e0adc4026">&#9670;&nbsp;</a></span>~PointCloud()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual open3d::t::geometry::PointCloud::~PointCloud </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e31065d101b408dab673e40a7a0dcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e31065d101b408dab673e40a7a0dcec">&#9670;&nbsp;</a></span>Append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::Append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a point cloud and returns the resulting point cloud.</p>
<p>The point cloud being appended, must have all the attributes present in the point cloud it is being appended to, with same dtype, device and same shape other than the first dimension / length. </p>

</div>
</div>
<a id="a115ef6bfa45fcac0e19f3c25e7798d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115ef6bfa45fcac0e19f3c25e7798d02">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>&amp; open3d::t::geometry::PointCloud::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all data in the point cloud. </p>

<p>Implements <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#adc2716f5911ea8a88501ce9d2f029a56">open3d::t::geometry::Geometry</a>.</p>

</div>
</div>
<a id="aae8dcb1293163a132aac40fdcf921596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8dcb1293163a132aac40fdcf921596">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns copy of the point cloud on the same device. </p>

</div>
</div>
<a id="a66aae75533c9f4aec317b97d7cb1a7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66aae75533c9f4aec317b97d7cb1a7d6">&#9670;&nbsp;</a></span>ClusterDBSCAN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> open3d::t::geometry::PointCloud::ClusterDBSCAN </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cluster <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> using the DBSCAN algorithm Ester et al., "A Density-Based Algorithm for Discovering Clusters
in Large Spatial Databases with Noise", 1996 This is a wrapper for a CPU implementation and a copy of the point cloud data and resulting labels will be made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eps</td><td>Density parameter that is used to find neighbouring points. </td></tr>
    <tr><td class="paramname">min_points</td><td>Minimum number of points to form a cluster. </td></tr>
    <tr><td class="paramname">print_progress</td><td>If <code>true</code> the progress is visualized in the console. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor list of point labels on the same device as the point cloud, -1 indicates noise according to the algorithm. </dd></dl>

</div>
</div>
<a id="a5778a28c894b1abf013eaba881b16e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5778a28c894b1abf013eaba881b16e10">&#9670;&nbsp;</a></span>ComputeBoundaryPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; open3d::t::geometry::PointCloud::ComputeBoundaryPoints </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_nn</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_threshold</em> = <code>90.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the boundary points of a point cloud. The implementation is inspired by the PCL implementation. Reference: <a href="https://pointclouds.org/documentation/classpcl_1_1_boundary_estimation.html">https://pointclouds.org/documentation/classpcl_1_1_boundary_estimation.html</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>Neighbor search radius parameter. </td></tr>
    <tr><td class="paramname">max_nn</td><td>Neighbor search max neighbors parameter [Default = 30]. </td></tr>
    <tr><td class="paramname">angle_threshold</td><td>Angle threshold to decide if a point is on the boundary [Default = 90.0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor of boundary points and its boolean mask tensor. </dd></dl>

</div>
</div>
<a id="a3a72c9991ec940d5c43687169cc263ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a72c9991ec940d5c43687169cc263ab">&#9670;&nbsp;</a></span>ComputeConvexHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_triangle_me">TriangleMesh</a> open3d::t::geometry::PointCloud::ComputeConvexHull </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>joggle_inputs</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the convex hull of a point cloud using qhull.</p>
<p>This runs on the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joggle_inputs</td><td>(default False). Handle precision problems by randomly perturbing the input data. Set to True if perturbing the input iis acceptable but you need convex simplicial output. If False, neighboring facets may be merged in case of precision problems. See <a href="http://www.qhull.org/html/qh-impre.htm#joggle">QHull docs</a> for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_triangle_me" title="A triangle mesh contains vertices and triangles.">TriangleMesh</a> representing the convexh hull. This contains an extra vertex property "point_map" that contains the index of the corresponding vertex in the original mesh. </dd></dl>

</div>
</div>
<a id="aa1f3132c5c92a5f8c6d6c2bda20329e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f3132c5c92a5f8c6d6c2bda20329e9">&#9670;&nbsp;</a></span>CreateFromDepthImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::CreateFromDepthImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_image.34e.d">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>intrinsics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>extrinsics</em> = <code><a class="el" href="classopen3d_1_1core_1_1_tensor.html#ac6bf87480ab991b8efd320e8532c2808">core::Tensor::Eye</a>(4,&#160;<a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>,&#160;<a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth_scale</em> = <code>1000.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_normals</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to create a point cloud from a depth image and a camera model. </p>
<p>Given depth value d at (u, v) image coordinate, the corresponding 3d point is:</p><ul>
<li>z = d / depth_scale</li>
<li>x = (u - cx) * z / fx</li>
<li>y = (v - cy) * z / fy</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>The input depth image should be a uint16_t or float image. </td></tr>
    <tr><td class="paramname">intrinsics</td><td>Intrinsic parameters of the camera. </td></tr>
    <tr><td class="paramname">extrinsics</td><td>Extrinsic parameters of the camera. </td></tr>
    <tr><td class="paramname">depth_scale</td><td>The depth is scaled by 1 / <code>depth_scale</code>. </td></tr>
    <tr><td class="paramname">depth_max</td><td>Truncated at <code>depth_max</code> distance. </td></tr>
    <tr><td class="paramname">stride</td><td>Sampling factor to support coarse point cloud extraction. Unless <code>with_normals=true</code>, there is no low pass filtering, so aliasing is possible for <code>stride&gt;1</code>. </td></tr>
    <tr><td class="paramname">with_normals</td><td>Also compute normals for the point cloud. If True, the point cloud will only contain points with valid normals. If normals are requested, the depth map is first filtered to ensure smooth normals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created point cloud with the 'points' property set. Thus is empty if the conversion fails. </dd></dl>

</div>
</div>
<a id="aa153a7f20a977a9695183884f866938c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa153a7f20a977a9695183884f866938c">&#9670;&nbsp;</a></span>CreateFromRGBDImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::CreateFromRGBDImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_r_g_b_d_ima">RGBDImage</a> &amp;&#160;</td>
          <td class="paramname"><em>rgbd_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>intrinsics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>extrinsics</em> = <code><a class="el" href="classopen3d_1_1core_1_1_tensor.html#ac6bf87480ab991b8efd320e8532c2808">core::Tensor::Eye</a>(4,&#160;<a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>,&#160;<a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth_scale</em> = <code>1000.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_normals</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to create a point cloud from an RGB-D image and a camera model. </p>
<p>Given depth value d at (u, v) image coordinate, the corresponding 3d point is:</p><ul>
<li>z = d / depth_scale</li>
<li>x = (u - cx) * z / fx</li>
<li>y = (v - cy) * z / fy</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgbd_image</td><td>The input RGBD image should have a uint16_t or float depth image and RGB image with any DType and the same size. </td></tr>
    <tr><td class="paramname">intrinsics</td><td>Intrinsic parameters of the camera. </td></tr>
    <tr><td class="paramname">extrinsics</td><td>Extrinsic parameters of the camera. </td></tr>
    <tr><td class="paramname">depth_scale</td><td>The depth is scaled by 1 / <code>depth_scale</code>. </td></tr>
    <tr><td class="paramname">depth_max</td><td>Truncated at <code>depth_max</code> distance. </td></tr>
    <tr><td class="paramname">stride</td><td>Sampling factor to support coarse point cloud extraction. Unless <code>with_normals=true</code>, there is no low pass filtering, so aliasing is possible for <code>stride&gt;1</code>. </td></tr>
    <tr><td class="paramname">with_normals</td><td>Also compute normals for the point cloud. If True, the point cloud will only contain points with valid normals. If normals are requested, the depth map is first filtered to ensure smooth normals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created point cloud with the 'points' and 'colors' properties set. This is empty if the conversion fails. </dd></dl>

</div>
</div>
<a id="a2dfb1c8415d4d7216b687ff3b32b5973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfb1c8415d4d7216b687ff3b32b5973">&#9670;&nbsp;</a></span>Crop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::Crop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_axis_aligne">AxisAlignedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to crop pointcloud into output pointcloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aabb</td><td><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_axis_aligne" title="A bounding box that is aligned along the coordinate axes and defined by the min_bound and max_bound.">AxisAlignedBoundingBox</a> to crop points. </td></tr>
    <tr><td class="paramname">invert</td><td>Crop the points outside of the bounding box or inside of the bounding box. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8ab6badbab533315f7b7d9113fb2d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ab6badbab533315f7b7d9113fb2d9b">&#9670;&nbsp;</a></span>Crop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::Crop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_oriented_bo">OrientedBoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>obb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to crop pointcloud into output pointcloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obb</td><td><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_oriented_bo" title="A bounding box oriented along an arbitrary frame of reference.">OrientedBoundingBox</a> to crop points. </td></tr>
    <tr><td class="paramname">invert</td><td>Crop the points outside of the bounding box or inside of the bounding box. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae73e32ab104ba5d8e1462d83a186538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae73e32ab104ba5d8e1462d83a186538">&#9670;&nbsp;</a></span>EstimateColorGradients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::EstimateColorGradients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1utility_1_1optional.3c6.delay">utility::optional</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>max_nn</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1utility_1_1optional.3c6.delay">utility::optional</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>radius</em> = <code><a class="el" href="namespaceopen3d_1_1utility.html#aecfc2255664b95bf9a25f06442b978e2">utility::nullopt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute point color gradients. If radius is provided, then HybridSearch is used, otherwise KNN-Search is used. Reference: Park, Q.-Y. Zhou, and V. Koltun, Colored Point Cloud Registration Revisited, ICCV, 2017. It uses KNN search (Not recommended to use on GPU) if only max_nn parameter is provided, Radius search (Not recommended to use on GPU) if only radius is provided and Hybrid Search (Recommended) if radius parameter is also provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_nn</td><td>[optional] Neighbor search max neighbors parameter [Default = 30]. </td></tr>
    <tr><td class="paramname">radius</td><td>[optional] Neighbor search radius parameter to use HybridSearch. [Recommended ~1.4x voxel size]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4937528c4b6194092631f002bccc44d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4937528c4b6194092631f002bccc44d0">&#9670;&nbsp;</a></span>EstimateNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::EstimateNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1utility_1_1optional.3c6.delay">utility::optional</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>max_nn</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1utility_1_1optional.3c6.delay">utility::optional</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>radius</em> = <code><a class="el" href="namespaceopen3d_1_1utility.html#aecfc2255664b95bf9a25f06442b978e2">utility::nullopt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to estimate point normals. If the point cloud normals exist, the estimated normals are oriented with respect to the same. It uses KNN search (Not recommended to use on GPU) if only max_nn parameter is provided, Radius search (Not recommended to use on GPU) if only radius is provided and Hybrid Search (Recommended) if radius parameter is also provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_nn</td><td>[optional] Neighbor search max neighbors parameter [Default = 30]. </td></tr>
    <tr><td class="paramname">radius</td><td>[optional] Neighbor search radius parameter. [Recommended ~1.4x voxel size]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac64ccde9d239c907edde85daf2c40d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64ccde9d239c907edde85daf2c40d5a">&#9670;&nbsp;</a></span>ExtrudeLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_line_set.49">LineSet</a> open3d::t::geometry::PointCloud::ExtrudeLinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>capping</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sweeps the point cloud along a direction vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The direction vector. </td></tr>
    <tr><td class="paramname">scale</td><td>Scalar factor which essentially scales the direction vector.</td></tr>
    <tr><td class="paramname">capping</td><td>If true adds caps to the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A line set with the result of the sweep operation. </dd></dl>

</div>
</div>
<a id="ad8867ee6fd62a878f8fc9a274b810d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8867ee6fd62a878f8fc9a274b810d9d">&#9670;&nbsp;</a></span>ExtrudeRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_line_set.49">LineSet</a> open3d::t::geometry::PointCloud::ExtrudeRotation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>translation</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>capping</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sweeps the point cloud rotationally about an axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The rotation angle in degree. </td></tr>
    <tr><td class="paramname">axis</td><td>The rotation axis. </td></tr>
    <tr><td class="paramname">resolution</td><td>The resolution defines the number of intermediate sweeps about the rotation axis. </td></tr>
    <tr><td class="paramname">translation</td><td>The translation along the rotation axis. </td></tr>
    <tr><td class="paramname">capping</td><td>If true adds caps to the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A line set with the result of the sweep operation. </dd></dl>

</div>
</div>
<a id="a94240a5ca59426f0ed5f08624d875a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94240a5ca59426f0ed5f08624d875a60">&#9670;&nbsp;</a></span>FarthestPointDownSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::FarthestPointDownSample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_samples</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downsample a pointcloud into output pointcloud with a set of points has farthest distance. </p>
<p>The sampling is performed by selecting the farthest point from previous selected points iteratively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_samples</td><td>Number of points to be sampled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5ba5f301a1dab6a56d9a528f2d8107e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ba5f301a1dab6a56d9a528f2d8107e">&#9670;&nbsp;</a></span>FromLegacy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::FromLegacy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">open3d::geometry::PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>pcd_legacy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopen3d_1_1core_1_1_dtype.html">core::Dtype</a>&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a> &amp;&#160;</td>
          <td class="paramname"><em>device</em> = <code><a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> from a legacy Open3D <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>. </p>

</div>
</div>
<a id="a728a8183c4ab0f6dc28ec292d62b5a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728a8183c4ab0f6dc28ec292d62b5a27">&#9670;&nbsp;</a></span>GetAxisAlignedBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_axis_aligne">AxisAlignedBoundingBox</a> open3d::t::geometry::PointCloud::GetAxisAlignedBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an axis-aligned bounding box from attribute "positions". </p>

</div>
</div>
<a id="ac4191167d3be9f3ccab2e4a4341fdfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4191167d3be9f3ccab2e4a4341fdfee">&#9670;&nbsp;</a></span>GetCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> open3d::t::geometry::PointCloud::GetCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the center for point coordinates. </p>

</div>
</div>
<a id="a5bae0e4f704ba9d8094081abfa24a729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bae0e4f704ba9d8094081abfa24a729">&#9670;&nbsp;</a></span>GetDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a> open3d::t::geometry::PointCloud::GetDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the device attribute of this <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>. </p>

<p>Implements <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a409482298c1e3140f1b06f2410c86dee">open3d::t::geometry::Geometry</a>.</p>

</div>
</div>
<a id="ad80a9818e4fc15f325cc9d987ca81c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80a9818e4fc15f325cc9d987ca81c57">&#9670;&nbsp;</a></span>GetMaxBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> open3d::t::geometry::PointCloud::GetMaxBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max bound for point coordinates. </p>

</div>
</div>
<a id="a9adc9d964d5986442169724e9b015a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adc9d964d5986442169724e9b015a1e">&#9670;&nbsp;</a></span>GetMinBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> open3d::t::geometry::PointCloud::GetMinBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the min bound for point coordinates. </p>

</div>
</div>
<a id="a5dbdd2289dcd7c3c6e3e1e29ebc0d293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbdd2289dcd7c3c6e3e1e29ebc0d293">&#9670;&nbsp;</a></span>GetOrientedBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_oriented_bo">OrientedBoundingBox</a> open3d::t::geometry::PointCloud::GetOrientedBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an oriented bounding box from attribute "positions". </p>

</div>
</div>
<a id="ad6fc2674c6746f2573da0f1bb9ff67c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fc2674c6746f2573da0f1bb9ff67c5">&#9670;&nbsp;</a></span>GetPointAttr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a>&amp; open3d::t::geometry::PointCloud::GetPointAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for point_attr_ <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a>. </p>

</div>
</div>
<a id="accccfd3582713631f3d6c97796da37f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accccfd3582713631f3d6c97796da37f6">&#9670;&nbsp;</a></span>GetPointAttr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a>&amp; open3d::t::geometry::PointCloud::GetPointAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for point_attr_ <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a>. Used in Pybind. </p>

</div>
</div>
<a id="a00d7a0f6d3dc6204ed1751f060f1722b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d7a0f6d3dc6204ed1751f060f1722b">&#9670;&nbsp;</a></span>GetPointAttr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&amp; open3d::t::geometry::PointCloud::GetPointAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get attributes. Throws exception if the attribute does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Attribute name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44a47951e42d5a0352ddba68e756f181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a47951e42d5a0352ddba68e756f181">&#9670;&nbsp;</a></span>GetPointAttr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&amp; open3d::t::geometry::PointCloud::GetPointAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get attributes. Throws exception if the attribute does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Attribute name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85426e69fed8c00e6608d7d1574e88e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85426e69fed8c00e6608d7d1574e88e7">&#9670;&nbsp;</a></span>GetPointColors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&amp; open3d::t::geometry::PointCloud::GetPointColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the "colors" attribute. Convenience function. </p>

</div>
</div>
<a id="a70d5de91926460a5c243648bde8dda96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d5de91926460a5c243648bde8dda96">&#9670;&nbsp;</a></span>GetPointColors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&amp; open3d::t::geometry::PointCloud::GetPointColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the "colors" attribute. Convenience function. </p>

</div>
</div>
<a id="a45095ecce4dfe3bd47c001773ba4c91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45095ecce4dfe3bd47c001773ba4c91d">&#9670;&nbsp;</a></span>GetPointNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&amp; open3d::t::geometry::PointCloud::GetPointNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the "normals" attribute. Convenience function. </p>

</div>
</div>
<a id="a97ad2807050ff5303c812d5a182952c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ad2807050ff5303c812d5a182952c7">&#9670;&nbsp;</a></span>GetPointNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&amp; open3d::t::geometry::PointCloud::GetPointNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the "normals" attribute. Convenience function. </p>

</div>
</div>
<a id="abb68920f902c562c26835c1e497ae333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb68920f902c562c26835c1e497ae333">&#9670;&nbsp;</a></span>GetPointPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&amp; open3d::t::geometry::PointCloud::GetPointPositions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the "positions" attribute. Convenience function. </p>

</div>
</div>
<a id="a403de24beb059f18d718a6c33aa6d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403de24beb059f18d718a6c33aa6d482">&#9670;&nbsp;</a></span>GetPointPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>&amp; open3d::t::geometry::PointCloud::GetPointPositions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the "positions" attribute. Convenience function. </p>

</div>
</div>
<a id="a0cf97355470fb6f77273ab149a365f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf97355470fb6f77273ab149a365f23">&#9670;&nbsp;</a></span>HasPointAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::t::geometry::PointCloud::HasPointAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if all of the following are true: 1) attribute key exist 2) attribute's length as points' length 3) attribute's length &gt; 0 </p>

</div>
</div>
<a id="a43bc1ab5ddb08c22ca053572d9bab104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bc1ab5ddb08c22ca053572d9bab104">&#9670;&nbsp;</a></span>HasPointColors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::t::geometry::PointCloud::HasPointColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if all of the following are true: 1) attribute "colors" exist 2) attribute "colors"'s length as points' length 3) attribute "colors"'s length &gt; 0 This is a convenience function. </p>

</div>
</div>
<a id="af97367e796ffa8942792d196b832ab16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97367e796ffa8942792d196b832ab16">&#9670;&nbsp;</a></span>HasPointNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::t::geometry::PointCloud::HasPointNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if all of the following are true: 1) attribute "normals" exist 2) attribute "normals"'s length as points' length 3) attribute "normals"'s length &gt; 0 This is a convenience function. </p>

</div>
</div>
<a id="a41f6597f210ddb370a944ede9c625798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f6597f210ddb370a944ede9c625798">&#9670;&nbsp;</a></span>HasPointPositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::t::geometry::PointCloud::HasPointPositions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the "positions" attribute's value has length &gt; 0. This is a convenience function. </p>

</div>
</div>
<a id="ad275b1cebf88f19caaa4ef4f2b7c162c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad275b1cebf88f19caaa4ef4f2b7c162c">&#9670;&nbsp;</a></span>HiddenPointRemoval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_triangle_me">TriangleMesh</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; open3d::t::geometry::PointCloud::HiddenPointRemoval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>camera_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an implementation of the Hidden Point Removal operator described in Katz et. al. 'Direct Visibility of Point Sets', 2007. </p>
<p>Additional information about the choice of radius for noisy point clouds can be found in Mehra et. al. 'Visibility of Noisy Point Cloud Data', 2010.</p>
<p>This is a wrapper for a CPU implementation and a copy of the point cloud data and resulting visible triangle mesh and indiecs will be made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera_location</td><td>All points not visible from that location will be removed. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the spherical projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of visible triangle mesh and indices of visible points on the same device as the point cloud. </dd></dl>

</div>
</div>
<a id="a72e67fbf0b6441e7884ca107215792cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e67fbf0b6441e7884ca107215792cf">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool open3d::t::geometry::PointCloud::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns !HasPointPositions(). </p>

<p>Implements <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_geometry.36#a96fee92f85f6aa6ea262c38459a85f2d">open3d::t::geometry::Geometry</a>.</p>

</div>
</div>
<a id="a4f801ad41fefe62abb126312418778bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f801ad41fefe62abb126312418778bf">&#9670;&nbsp;</a></span>NormalizeNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp; open3d::t::geometry::PointCloud::NormalizeNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize point normals to length 1. </p>

</div>
</div>
<a id="ac6f1422fe12cd196bbb9a95096ddea78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f1422fe12cd196bbb9a95096ddea78">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator+ for t::PointCloud appends the compatible attributes to the point cloud. </p>

</div>
</div>
<a id="ad954de9b70a7eb2046da3706ba54fbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad954de9b70a7eb2046da3706ba54fbf5">&#9670;&nbsp;</a></span>OrientNormalsConsistentTangentPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::OrientNormalsConsistentTangentPlane </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to consistently orient estimated normals based on consistent tangent planes as described in Hoppe et al., "Surface
Reconstruction from Unorganized Points", 1992. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>k nearest neighbour for graph reconstruction for normal propagation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99387de01a21dca5a14811c420188335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99387de01a21dca5a14811c420188335">&#9670;&nbsp;</a></span>OrientNormalsToAlignWithDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::OrientNormalsToAlignWithDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>orientation_reference</em> = <code><a class="el" href="classopen3d_1_1core_1_1_tensor.html#abdd4023d4d72aaa52a26ac391281c4a0">core::Tensor::Init</a>&lt;float&gt;({0,&#160;0,&#160;1},&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;))</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to orient the normals of a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation_reference</td><td>Normals are oriented with respect to orientation_reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4771ebe4e8e260f01309a344159342c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4771ebe4e8e260f01309a344159342c">&#9670;&nbsp;</a></span>OrientNormalsTowardsCameraLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::OrientNormalsTowardsCameraLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>camera_location</em> = <code><a class="el" href="classopen3d_1_1core_1_1_tensor.html#a9a878b99906d1bc0d06a6e5bbf9c892d">core::Tensor::Zeros</a>(&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{3},&#160;<a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>,&#160;<a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;))</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to orient the normals of a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera_location</td><td>Normals are oriented with towards the camera_location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10907bcfc70eee5d2b18e8055413547f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10907bcfc70eee5d2b18e8055413547f">&#9670;&nbsp;</a></span>PaintUniformColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp; open3d::t::geometry::PointCloud::PaintUniformColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns uniform color to the point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>RGB color for the point cloud. {3,} shaped Tensor. Floating color values are clipped between 0.0 and 1.0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1f669365797bbf4d887b8a3c87f589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1f669365797bbf4d887b8a3c87f589">&#9670;&nbsp;</a></span>PCAPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int open3d::t::geometry::PointCloud::PCAPartition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition the point cloud by recursively doing PCA. This function creates a new point attribute with the name "partition_ids". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_points</td><td>The maximum allowed number of points in a partition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of partitions. </dd></dl>

</div>
</div>
<a id="a5c61cea1a3830b2e2ac4472362fa469e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c61cea1a3830b2e2ac4472362fa469e">&#9670;&nbsp;</a></span>ProjectToDepthImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_image.34e.d">geometry::Image</a> open3d::t::geometry::PointCloud::ProjectToDepthImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>intrinsics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>extrinsics</em> = <code><a class="el" href="classopen3d_1_1core_1_1_tensor.html#ac6bf87480ab991b8efd320e8532c2808">core::Tensor::Eye</a>(4,&#160;<a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>,&#160;<a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth_scale</em> = <code>1000.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>3.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project a point cloud to a depth image. </p>

</div>
</div>
<a id="a40430e59ea353f2f48da1a26dcefecd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40430e59ea353f2f48da1a26dcefecd3">&#9670;&nbsp;</a></span>ProjectToRGBDImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_r_g_b_d_ima">geometry::RGBDImage</a> open3d::t::geometry::PointCloud::ProjectToRGBDImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>intrinsics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>extrinsics</em> = <code><a class="el" href="classopen3d_1_1core_1_1_tensor.html#ac6bf87480ab991b8efd320e8532c2808">core::Tensor::Eye</a>(4,&#160;<a class="el" href="namespaceopen3d_1_1core.html#af1357e9a6250eaf326a9dc7069c02789">core::Float32</a>,&#160;<a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth_scale</em> = <code>1000.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>3.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project a point cloud to an RGBD image. </p>

</div>
</div>
<a id="a9e7b27ca434d5b9e2fb35c9a89a4e564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7b27ca434d5b9e2fb35c9a89a4e564">&#9670;&nbsp;</a></span>RandomDownSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::RandomDownSample </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampling_ratio</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downsample a pointcloud by selecting random index point and its attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampling_ratio</td><td>Sampling ratio, the ratio of sample to total number of points in the pointcloud. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f5fc8650a6a3c84a292711dfb0c6b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5fc8650a6a3c84a292711dfb0c6b9b">&#9670;&nbsp;</a></span>RemoveDuplicatedPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; open3d::t::geometry::PointCloud::RemoveDuplicatedPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicated points and there associated attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>Tuple of filtered <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> and boolean indexing tensor w.r.t. input point cloud. </dd></dl>

</div>
</div>
<a id="ab7da76e90a6f0a7a01cd237d2b2f3d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7da76e90a6f0a7a01cd237d2b2f3d00">&#9670;&nbsp;</a></span>RemoveNonFinitePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; open3d::t::geometry::PointCloud::RemoveNonFinitePoints </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_nan</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_infinite</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all points from the point cloud that have a nan entry, or infinite value. It also removes the corresponding attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove_nan</td><td>Remove NaN values from the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>. </td></tr>
    <tr><td class="paramname">remove_infinite</td><td>Remove infinite values from the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of filtered point cloud and boolean mask tensor for selected values w.r.t. input point cloud. </dd></dl>

</div>
</div>
<a id="aaf172bb1a59d3e7ddb5877183b259d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf172bb1a59d3e7ddb5877183b259d23">&#9670;&nbsp;</a></span>RemovePointAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::RemovePointAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes point attribute by key value. Primary attribute "positions" cannot be removed. Throws warning if attribute key does not exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Attribute name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e0bc045e52dab0aeda39f1e0c408b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0bc045e52dab0aeda39f1e0c408b8c">&#9670;&nbsp;</a></span>RemoveRadiusOutliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; open3d::t::geometry::PointCloud::RemoveRadiusOutliers </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>search_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove points that have less than <code>nb_points</code> neighbors in a sphere of a given radius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_points</td><td>Number of neighbor points required within the radius. </td></tr>
    <tr><td class="paramname">search_radius</td><td>Radius of the sphere. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of filtered point cloud and boolean mask tensor for selected values w.r.t. input point cloud. </dd></dl>

</div>
</div>
<a id="a00c3c5fdea3588af7c3d29f8b05cc36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c3c5fdea3588af7c3d29f8b05cc36f">&#9670;&nbsp;</a></span>RemoveStatisticalOutliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; open3d::t::geometry::PointCloud::RemoveStatisticalOutliers </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove points that are further away from their <code>nb_neighbor</code> neighbors in average. This function is not recommended to use on GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nb_neighbors</td><td>Number of neighbors around the target point. </td></tr>
    <tr><td class="paramname">std_ratio</td><td>Standard deviation ratio. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of filtered point cloud and boolean mask tensor for selected values w.r.t. input point cloud. </dd></dl>

</div>
</div>
<a id="a1c12271b77ec218efce5c445be840d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c12271b77ec218efce5c445be840d0e">&#9670;&nbsp;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp; open3d::t::geometry::PointCloud::Rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates the PointPositions and PointNormals (if exists). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Rotation [Tensor of dim {3,3}]. Should be on the same device as the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> </td></tr>
    <tr><td class="paramname">center</td><td>Center [Tensor of dim {3}] about which the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> is to be scaled. Should be on the same device as the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotated point cloud </dd></dl>

</div>
</div>
<a id="a4448b7581ace1ea9c62dbf11312a2b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4448b7581ace1ea9c62dbf11312a2b30">&#9670;&nbsp;</a></span>Scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp; open3d::t::geometry::PointCloud::Scale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the PointPositions of the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>Scale [double] of dimension </td></tr>
    <tr><td class="paramname">center</td><td>Center [Tensor of dim {3}] about which the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> is to be scaled. Should be on the same device as the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scaled point cloud </dd></dl>

</div>
</div>
<a id="a2a5167a96d3785f29cb410cd059242ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5167a96d3785f29cb410cd059242ae">&#9670;&nbsp;</a></span>SegmentPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a>, <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &gt; open3d::t::geometry::PointCloud::SegmentPlane </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>distance_threshold</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ransac_n</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_iterations</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>probability</em> = <code>0.99999999</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segment <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> plane using the RANSAC algorithm. This is a wrapper for a CPU implementation and a copy of the point cloud data and resulting plane model and inlier indiecs will be made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance_threshold</td><td>Max distance a point can be from the plane model, and still be considered an inlier. </td></tr>
    <tr><td class="paramname">ransac_n</td><td>Number of initial points to be considered inliers in each iteration. </td></tr>
    <tr><td class="paramname">num_iterations</td><td>Maximum number of iterations. </td></tr>
    <tr><td class="paramname">probability</td><td>Expected probability of finding the optimal plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of the plane model ax + by + cz + d = 0 and the indices of the plane inliers on the same device as the point cloud. </dd></dl>

</div>
</div>
<a id="ae99efd0de12ffb7f7d955fd6d1a4b6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99efd0de12ffb7f7d955fd6d1a4b6c0">&#9670;&nbsp;</a></span>SelectByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::SelectByIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select points from input pointcloud, based on indices list into output point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Int64 indexing tensor of shape {n,} containing index value that is to be selected. </td></tr>
    <tr><td class="paramname">invert</td><td>Set to <code>True</code> to invert the selection of indices, and also ignore the duplicated indices. </td></tr>
    <tr><td class="paramname">remove_duplicates</td><td>Set to <code>True</code> to remove the duplicated indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeef837487d72cab185ee929f30b8fba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef837487d72cab185ee929f30b8fba7">&#9670;&nbsp;</a></span>SelectByMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::SelectByMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select points from input pointcloud, based on boolean mask indices into output point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boolean_mask</td><td>Boolean indexing tensor of shape {n,} containing true value for the indices that is to be selected. </td></tr>
    <tr><td class="paramname">invert</td><td>Set to <code>True</code> to invert the selection of indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae798189d80f459ae746850cb67bae964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae798189d80f459ae746850cb67bae964">&#9670;&nbsp;</a></span>SetPointAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::SetPointAttr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set attributes. If the attribute key already exists, its value will be overwritten, otherwise, the new key will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Attribute name. </td></tr>
    <tr><td class="paramname">value</td><td>A tensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64e422ab4b4cc38253ea4861bff3fa07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e422ab4b4cc38253ea4861bff3fa07">&#9670;&nbsp;</a></span>SetPointColors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::SetPointColors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the "colors" attribute. Convenience function. </p>

</div>
</div>
<a id="af05550eef541d8b68af1c08a0e4cdcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05550eef541d8b68af1c08a0e4cdcfe">&#9670;&nbsp;</a></span>SetPointNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::SetPointNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the "normals" attribute. Convenience function. </p>

</div>
</div>
<a id="a6264648914705fcb375bbc5f8878ae45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6264648914705fcb375bbc5f8878ae45">&#9670;&nbsp;</a></span>SetPointPositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void open3d::t::geometry::PointCloud::SetPointPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the "positions" attribute. Convenience function. </p>

</div>
</div>
<a id="a5274fac4aa6c2dd05aa78226b60cc4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5274fac4aa6c2dd05aa78226b60cc4c9">&#9670;&nbsp;</a></span>To()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::To </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a> &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer the point cloud to a specified device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The targeted device to convert to. </td></tr>
    <tr><td class="paramname">copy</td><td>If true, a new point cloud is always created; if false, the copy is avoided when the original point cloud is already on the targeted device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8507187480860812b9862396c178950b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8507187480860812b9862396c178950b">&#9670;&nbsp;</a></span>ToLegacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1geometry_1_1_point_cloud.41b">open3d::geometry::PointCloud</a> open3d::t::geometry::PointCloud::ToLegacy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to a legacy Open3D <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>. </p>

</div>
</div>
<a id="abe724473aae5841aae4ad0a6fd0f2063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe724473aae5841aae4ad0a6fd0f2063">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string open3d::t::geometry::PointCloud::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Text description. </p>

</div>
</div>
<a id="abb83123f5168bb86c788195e2dd9ff5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb83123f5168bb86c788195e2dd9ff5f">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp; open3d::t::geometry::PointCloud::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the PointPositions and PointNormals (if exist) of the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>. </p>
<p>Transformation matrix is a 4x4 matrix. T (4x4) = [[ R(3x3) t(3x1) ], [ O(1x3) s(1x1) ]] (s = 1 for Transformation without scaling)</p>
<p>It applies the following general transform to each <code>positions</code> and <code>normals</code>. |x'| | R(0,0) R(0,1) R(0,2) t(0)| |x| |y'| = | R(1,0) R(1,1) R(1,2) t(1)| @ |y| |z'| | R(2,0) R(2,1) R(2,2) t(2)| |z| |w'| | O(0,0) O(0,1) O(0,2) s | |1|</p>
<p>[x, y, z] = [x', y', z'] / w'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transformation</td><td>Transformation [Tensor of dim {4,4}]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed point cloud </dd></dl>

</div>
</div>
<a id="afd856dd9bb2c55e4c59d8cfcff861f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd856dd9bb2c55e4c59d8cfcff861f14">&#9670;&nbsp;</a></span>Translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> &amp; open3d::t::geometry::PointCloud::Translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopen3d_1_1core_1_1_tensor.html">core::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relative</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the PointPositions of the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translation</td><td>translation tensor of dimension {3} Should be on the same device as the <a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud" title="A point cloud contains a list of 3D points.">PointCloud</a> </td></tr>
    <tr><td class="paramname">relative</td><td>if true (default): translates relative to Center </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Translated point cloud </dd></dl>

</div>
</div>
<a id="a10fae69dd8c02835b0e7567089ec5cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fae69dd8c02835b0e7567089ec5cda">&#9670;&nbsp;</a></span>UniformDownSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::UniformDownSample </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>every_k_points</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downsamples a point cloud by selecting every kth index point and its attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">every_k_points</td><td>Sample rate, the selected point indices are [0, k, 2k, …]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a747e97aeaea54ab600101c892d88eda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747e97aeaea54ab600101c892d88eda9">&#9670;&nbsp;</a></span>VoxelDownSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_point_cloud">PointCloud</a> open3d::t::geometry::PointCloud::VoxelDownSample </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>voxel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopen3d_1_1core.html#aa9cb3aa033abd5eb2b1bd42d3dc10a83">core::HashBackendType</a> &amp;&#160;</td>
          <td class="paramname"><em>backend</em> = <code><a class="el" href="namespaceopen3d_1_1core.html#aa9cb3aa033abd5eb2b1bd42d3dc10a83a7a1920d61156abc05a60135aefe8bc67">core::HashBackendType::Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Downsamples a point cloud with a specified voxel size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voxel_size</td><td>Voxel size. A positive number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a4f3f493cc3ae272974eff4becc167b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3f493cc3ae272974eff4becc167b42">&#9670;&nbsp;</a></span>device_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a> open3d::t::geometry::PointCloud::device_ = <a class="el" href="classopen3d_1_1core_1_1_device.html">core::Device</a>(&quot;CPU:0&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6939de5cc0240f2bea082be60975f4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6939de5cc0240f2bea082be60975f4cd">&#9670;&nbsp;</a></span>point_attr_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopen3d_1_1t_1_1geometry_1_1_tensor_map">TensorMap</a> open3d::t::geometry::PointCloud::point_attr_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/t/geometry/<a class="el" href="t_2geometry_2_point_cloud_8h_source.4c1.dela">PointCloud.h (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
<li>/home/runner/work/Open3D/Open3D/cpp/open3d/t/geometry/<a class="el" href="t_2geometry_2_point_cloud_8cpp.html">PointCloud.cpp (9238339 (Tue Mar 14 18:49:09 2023 -0700))</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>

<!-- Mirrored from www.open3d.org/docs/release/cpp_api/classopen3d_1_1t_1_1geometry_1_1_point_cloud.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 14 May 2023 10:53:57 GMT -->
</html>
